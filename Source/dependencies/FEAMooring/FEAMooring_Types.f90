!STARTOFREGISTRYGENERATEDFILE './FEAMooring_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 14-Jan-2015)
!*********************************************************************************************************************************
! FEAMooring_Types
!.................................................................................................................................
! This file is part of FEAMooring.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE FEAMooring_Types
! This module contains all of the user-defined types needed in FEAMooring. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  FEAM_InputFile  =======
  TYPE, PUBLIC :: FEAM_InputFile
    REAL(DbKi)  :: DT      ! Communication interval for mooring dynamics [s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCI      ! Mooring line inertia coefficient [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCD      ! Mooring line drag coefficient [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LEAStiff      ! Mooring line axial stiffness [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LMassDen      ! Mooring line mass per unit length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDMassDen      ! Mooring line displaced mass per unit length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmStiff      ! Seabed spring stiffness [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LRadAnch      ! Anchor Radius [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAngAnch      ! Anchor Angle [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDpthAnch      ! Anchor Depth [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LRadFair      ! Fairlead Radius [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAngFair      ! Fairlead Radius [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDrftFair      ! Fairlead Draft [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LUnstrLen      ! Line unstretched length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Tension      ! Line Top Tension [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GSL      ! Linear spring stiffness at fairlead [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GSR      ! Rotational spring stiffness at fairlead [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GE      ! Reference tangent vector at fairlead [-]
    INTEGER(IntKi)  :: NumLines      ! Number of lines [-]
    INTEGER(IntKi)  :: NumElems      ! Number of elements [-]
    REAL(ReKi)  :: Eps      ! Tolerance for static iteration [-]
    REAL(ReKi)  :: Gravity      ! Gravity [-]
    REAL(ReKi)  :: WtrDens      ! Water density [-]
    INTEGER(IntKi)  :: MaxIter      ! Maximum number of iteration step for static analysis [-]
    LOGICAL  :: SumPrint      ! Print summary data to <RootName>.fsm? [-]
    INTEGER(IntKi)  :: OutFile      ! Switch to determine where output will be placed: (1: in module output file only; 2: in glue code output file only; 3: both) [-]
    LOGICAL  :: TabDelim      ! Use tab delimiters in text tabular output file? [-]
    CHARACTER(20)  :: OutFmt      ! Format used for text tabular output (except time) [-]
    REAL(DbKi)  :: Tstart      ! Time to start module's tabular output [s]
    INTEGER(IntKi)  :: NumOuts      ! Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: OutList      ! List of user-requested output channels [-]
  END TYPE FEAM_InputFile
! =======================
! =========  FEAM_InitInputType  =======
  TYPE, PUBLIC :: FEAM_InitInputType
    CHARACTER(1024)  :: InputFile      ! Name of the input file [-]
    CHARACTER(1024)  :: RootName      ! RootName for writing output files [-]
    REAL(ReKi) , DIMENSION(1:6)  :: PtfmInit      ! Platform Initial Position [-]
    INTEGER(IntKi)  :: NStepWave      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc0      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel0      !  [-]
    REAL(ReKi)  :: Gravity      ! Gravity [-]
    REAL(ReKi)  :: WtrDens      ! Water density [-]
  END TYPE FEAM_InitInputType
! =======================
! =========  FEAM_InitOutputType  =======
  TYPE, PUBLIC :: FEAM_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      ! Names of the output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      ! Units of the output-to-file channels [-]
    TYPE(ProgDesc)  :: Ver      ! This module's name, version, and date [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchxi      ! Anchor coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchyi      ! Anchor coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchzi      ! Anchor coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairxt      ! Fairlead coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairyt      ! Fairlead coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairzt      ! Fairlead coordinate [-]
  END TYPE FEAM_InitOutputType
! =======================
! =========  FEAM_ContinuousStateType  =======
  TYPE, PUBLIC :: FEAM_ContinuousStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLU      ! Global matrix U (displacement) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLDU      ! Global matrix DU (velocity) [-]
  END TYPE FEAM_ContinuousStateType
! =======================
! =========  FEAM_DiscreteStateType  =======
  TYPE, PUBLIC :: FEAM_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      ! Remove this variable if you have discrete states [-]
  END TYPE FEAM_DiscreteStateType
! =======================
! =========  FEAM_ConstraintStateType  =======
  TYPE, PUBLIC :: FEAM_ConstraintStateType
    REAL(ReKi) , DIMENSION(1:3)  :: TSN      ! Lagrangian multiplier [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TZER      ! Lagrangian multiplier [-]
  END TYPE FEAM_ConstraintStateType
! =======================
! =========  FEAM_OtherStateType  =======
  TYPE, PUBLIC :: FEAM_OtherStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLU0      ! Global matrix U0 (previous state) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLDDU      ! Global matrix DDU (accleration) -- other state [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLF      ! Global forcing matrix [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GLK      ! Global stiffness matrix [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GLUZR      ! Line coordinate & direction cosine [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GTZER      ! Line tension [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GFORC0      ! Old element force matrix [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: GMASS0      ! Old element mass matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_FP      ! Fairlead position [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_FPA      ! Fairlead position [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FAIR_T      ! Fairlead tension [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_RP      ! Fairlead tangent [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ANCH_T      ! Anchor tension [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAIR_ANG      ! Fairlead angle [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANCH_ANG      ! Anchor angle [-]
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: ESTIF      ! Line element stiffness [-]
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: EMASS      ! Line element mass [-]
    REAL(ReKi) , DIMENSION(1:15)  :: FORCE      ! Line external force [-]
    REAL(ReKi) , DIMENSION(1:15)  :: RSDF      ! Line residue force [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_Lines      ! Mooring restoring force [-]
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: U      ! Local matrix U [-]
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: U0      ! Local matrix U0 [-]
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: DU      ! Local matrix DU [-]
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: DDU      ! Local matrix DDU [-]
    REAL(ReKi) , DIMENSION(1:15)  :: FORC0      ! - [Local old element force matrix]
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: EMAS0      ! Local old element mass matrix [-]
    INTEGER(IntKi)  :: INCR      ! FEAM step [-]
    LOGICAL  :: BottomTouch      ! Bottom touch flag [-]
    LOGICAL  :: Iteration1      ! Static iteration flag [-]
    LOGICAL  :: Iteration2      ! Static iteration flag [-]
    REAL(ReKi) , DIMENSION(1:3)  :: R      ! POSITION VECTOR OF NODE OF ROD ELEMENT [-]
    REAL(ReKi) , DIMENSION(1:3)  :: RP      ! DR/DS AT R (TANGENT - NEED NOT BE UNIT VECTOR) [-]
    REAL(ReKi) , DIMENSION(1:3)  :: FP      ! Fairlead position [-]
    REAL(ReKi) , DIMENSION(1:3)  :: SLIN      ! LINEAR SPRING CONSTANT (UNITS OF FORCE/LENGTH) [-]
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: STIFR      ! STIFFNESS COEFFICIENTS FOR 6 DEGREES OF FREEDOM OF ROD NODE (X,DX/DS,Y,DY/DS,Z,DZ/DS) [-]
    REAL(ReKi) , DIMENSION(1:6)  :: RHSR      ! RIGHT HAND SIDE CONTRIBUTION TO 6 DEGREES OF FREEDOM OF ROD NODE [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Line_Coordinate      ! Mooring line coordinate [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Line_Tangent      ! Mooring line tangent vector [-]
    INTEGER(IntKi)  :: LastIndWave      ! FEAM step [-]
  END TYPE FEAM_OtherStateType
! =======================
! =========  FEAM_ParameterType  =======
  TYPE, PUBLIC :: FEAM_ParameterType
    REAL(DbKi)  :: DT      ! Time step for continuous state integration & discrete state update [seconds]
    REAL(ReKi) , DIMENSION(1:3)  :: GRAV      ! Gravity [-]
    REAL(ReKi)  :: Eps      ! Tolerance for static iteration [-]
    REAL(ReKi)  :: Gravity      ! Gravity [-]
    REAL(ReKi)  :: WtrDens      ! Water density [-]
    INTEGER(IntKi)  :: MaxIter      ! Maximum number of iteration step for static analysis [-]
    INTEGER(IntKi)  :: NHBD      ! Bandwidth = (NBAND+1)/2 [-]
    INTEGER(IntKi)  :: NDIM      ! Dimension = 3 [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NEQ      ! Number of equation [-]
    INTEGER(IntKi)  :: NBAND      ! Bandwidth [-]
    INTEGER(IntKi)  :: NumLines      ! Number of lines [-]
    INTEGER(IntKi)  :: NumElems      ! Number of elements [-]
    INTEGER(IntKi)  :: NumNodes      ! Number of nodes [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GSL      ! Linear spring stiffness at fairlead [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GP      ! Fairlead position [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Elength      ! Element length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmElev      ! Bottom elevation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmStiff      ! Bottom stiffness [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LMassDen      ! Line mass per unit length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDMassDen      ! Line displaced mass per unit length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LEAStiff      ! Line axial stiffness [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCI      ! Line inertia coefficient [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCD      ! Line drag coefficient [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Bvp      ! Boundary condtion [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc0      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel0      !  [-]
    INTEGER(IntKi)  :: NStepWave      ! Number of wave steps [-]
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: SHAP      ! Shape function [-]
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: SHAPS      ! Shape function [-]
    REAL(ReKi) , DIMENSION(1:6)  :: GAUSSW      ! Shape function [-]
    INTEGER(IntKi)  :: NGAUSS      ! 6 POINT GAUSSIAN QUADRATURE INTEGRATION [-]
    REAL(ReKi) , DIMENSION(1:10,1:4)  :: SHAPT      ! Shape function [-]
    REAL(ReKi) , DIMENSION(1:10,1:4)  :: SHAPTS      ! Shape function [-]
    INTEGER(IntKi)  :: NTRAP      ! 10 TRANPEZOIDE INTEGRATION point [-]
    REAL(ReKi) , DIMENSION(1:4,1:4)  :: SBEND      ! Internal [-]
    REAL(ReKi) , DIMENSION(1:3,1:4,1:4)  :: STEN      ! Internal [-]
    REAL(ReKi) , DIMENSION(1:4,1:4)  :: RMASS      ! Internal [-]
    REAL(ReKi) , DIMENSION(1:4,1:4,1:4,1:4)  :: RADDM      ! Internal [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: PMPN      ! Internal [-]
    REAL(ReKi) , DIMENSION(1:4)  :: AM      ! Internal [-]
    REAL(ReKi) , DIMENSION(1:3)  :: PM      ! Internal [-]
    INTEGER(IntKi) , DIMENSION(1:3,1:4)  :: IDOF      ! Internal [-]
    INTEGER(IntKi) , DIMENSION(1:3)  :: JDOF      ! Internal [-]
    REAL(ReKi) , DIMENSION(1:3,1:3,1:4)  :: PPA      ! Internal [-]
    REAL(ReKi)  :: PtfmRefzt      ! Platform reference [-]
    INTEGER(IntKi)  :: NumOuts      ! Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(1024)  :: RootName      ! RootName for writing output files [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      ! Names and units (and other characteristics) of all requested output parameters [-]
    CHARACTER(1)  :: Delim      ! Column delimiter for output text files [-]
  END TYPE FEAM_ParameterType
! =======================
! =========  FEAM_InputType  =======
  TYPE, PUBLIC :: FEAM_InputType
    TYPE(MeshType)  :: HydroForceLineMesh      ! Meshed input data [-]
    TYPE(MeshType)  :: PtFairleadDisplacement      ! Meshed input data [-]
  END TYPE FEAM_InputType
! =======================
! =========  FEAM_OutputType  =======
  TYPE, PUBLIC :: FEAM_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! Data to be written to an output file: see WriteOutputHdr for names of each variable [see WriteOutputUnt]
    TYPE(MeshType)  :: PtFairleadLoad      ! Meshed output data [-]
    TYPE(MeshType)  :: LineMeshPosition      ! Meshed output data [-]
  END TYPE FEAM_OutputType
! =======================
CONTAINS
 SUBROUTINE FEAM_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(FEAM_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInputFileData%DT = SrcInputFileData%DT
IF (ALLOCATED(SrcInputFileData%LineCI)) THEN
   i1_l = LBOUND(SrcInputFileData%LineCI,1)
   i1_u = UBOUND(SrcInputFileData%LineCI,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LineCI)) THEN 
      ALLOCATE(DstInputFileData%LineCI(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LineCI.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LineCI = SrcInputFileData%LineCI
ENDIF
IF (ALLOCATED(SrcInputFileData%LineCD)) THEN
   i1_l = LBOUND(SrcInputFileData%LineCD,1)
   i1_u = UBOUND(SrcInputFileData%LineCD,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LineCD)) THEN 
      ALLOCATE(DstInputFileData%LineCD(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LineCD.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LineCD = SrcInputFileData%LineCD
ENDIF
IF (ALLOCATED(SrcInputFileData%LEAStiff)) THEN
   i1_l = LBOUND(SrcInputFileData%LEAStiff,1)
   i1_u = UBOUND(SrcInputFileData%LEAStiff,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LEAStiff)) THEN 
      ALLOCATE(DstInputFileData%LEAStiff(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LEAStiff.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LEAStiff = SrcInputFileData%LEAStiff
ENDIF
IF (ALLOCATED(SrcInputFileData%LMassDen)) THEN
   i1_l = LBOUND(SrcInputFileData%LMassDen,1)
   i1_u = UBOUND(SrcInputFileData%LMassDen,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LMassDen)) THEN 
      ALLOCATE(DstInputFileData%LMassDen(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LMassDen.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LMassDen = SrcInputFileData%LMassDen
ENDIF
IF (ALLOCATED(SrcInputFileData%LDMassDen)) THEN
   i1_l = LBOUND(SrcInputFileData%LDMassDen,1)
   i1_u = UBOUND(SrcInputFileData%LDMassDen,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LDMassDen)) THEN 
      ALLOCATE(DstInputFileData%LDMassDen(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LDMassDen.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LDMassDen = SrcInputFileData%LDMassDen
ENDIF
IF (ALLOCATED(SrcInputFileData%BottmStiff)) THEN
   i1_l = LBOUND(SrcInputFileData%BottmStiff,1)
   i1_u = UBOUND(SrcInputFileData%BottmStiff,1)
   IF (.NOT. ALLOCATED(DstInputFileData%BottmStiff)) THEN 
      ALLOCATE(DstInputFileData%BottmStiff(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%BottmStiff.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%BottmStiff = SrcInputFileData%BottmStiff
ENDIF
IF (ALLOCATED(SrcInputFileData%LRadAnch)) THEN
   i1_l = LBOUND(SrcInputFileData%LRadAnch,1)
   i1_u = UBOUND(SrcInputFileData%LRadAnch,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LRadAnch)) THEN 
      ALLOCATE(DstInputFileData%LRadAnch(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LRadAnch.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LRadAnch = SrcInputFileData%LRadAnch
ENDIF
IF (ALLOCATED(SrcInputFileData%LAngAnch)) THEN
   i1_l = LBOUND(SrcInputFileData%LAngAnch,1)
   i1_u = UBOUND(SrcInputFileData%LAngAnch,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LAngAnch)) THEN 
      ALLOCATE(DstInputFileData%LAngAnch(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LAngAnch.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LAngAnch = SrcInputFileData%LAngAnch
ENDIF
IF (ALLOCATED(SrcInputFileData%LDpthAnch)) THEN
   i1_l = LBOUND(SrcInputFileData%LDpthAnch,1)
   i1_u = UBOUND(SrcInputFileData%LDpthAnch,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LDpthAnch)) THEN 
      ALLOCATE(DstInputFileData%LDpthAnch(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LDpthAnch.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LDpthAnch = SrcInputFileData%LDpthAnch
ENDIF
IF (ALLOCATED(SrcInputFileData%LRadFair)) THEN
   i1_l = LBOUND(SrcInputFileData%LRadFair,1)
   i1_u = UBOUND(SrcInputFileData%LRadFair,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LRadFair)) THEN 
      ALLOCATE(DstInputFileData%LRadFair(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LRadFair.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LRadFair = SrcInputFileData%LRadFair
ENDIF
IF (ALLOCATED(SrcInputFileData%LAngFair)) THEN
   i1_l = LBOUND(SrcInputFileData%LAngFair,1)
   i1_u = UBOUND(SrcInputFileData%LAngFair,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LAngFair)) THEN 
      ALLOCATE(DstInputFileData%LAngFair(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LAngFair.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LAngFair = SrcInputFileData%LAngFair
ENDIF
IF (ALLOCATED(SrcInputFileData%LDrftFair)) THEN
   i1_l = LBOUND(SrcInputFileData%LDrftFair,1)
   i1_u = UBOUND(SrcInputFileData%LDrftFair,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LDrftFair)) THEN 
      ALLOCATE(DstInputFileData%LDrftFair(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LDrftFair.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LDrftFair = SrcInputFileData%LDrftFair
ENDIF
IF (ALLOCATED(SrcInputFileData%LUnstrLen)) THEN
   i1_l = LBOUND(SrcInputFileData%LUnstrLen,1)
   i1_u = UBOUND(SrcInputFileData%LUnstrLen,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LUnstrLen)) THEN 
      ALLOCATE(DstInputFileData%LUnstrLen(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LUnstrLen.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LUnstrLen = SrcInputFileData%LUnstrLen
ENDIF
IF (ALLOCATED(SrcInputFileData%Tension)) THEN
   i1_l = LBOUND(SrcInputFileData%Tension,1)
   i1_u = UBOUND(SrcInputFileData%Tension,1)
   IF (.NOT. ALLOCATED(DstInputFileData%Tension)) THEN 
      ALLOCATE(DstInputFileData%Tension(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%Tension.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%Tension = SrcInputFileData%Tension
ENDIF
IF (ALLOCATED(SrcInputFileData%GSL)) THEN
   i1_l = LBOUND(SrcInputFileData%GSL,1)
   i1_u = UBOUND(SrcInputFileData%GSL,1)
   i2_l = LBOUND(SrcInputFileData%GSL,2)
   i2_u = UBOUND(SrcInputFileData%GSL,2)
   i3_l = LBOUND(SrcInputFileData%GSL,3)
   i3_u = UBOUND(SrcInputFileData%GSL,3)
   IF (.NOT. ALLOCATED(DstInputFileData%GSL)) THEN 
      ALLOCATE(DstInputFileData%GSL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GSL.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%GSL = SrcInputFileData%GSL
ENDIF
IF (ALLOCATED(SrcInputFileData%GSR)) THEN
   i1_l = LBOUND(SrcInputFileData%GSR,1)
   i1_u = UBOUND(SrcInputFileData%GSR,1)
   i2_l = LBOUND(SrcInputFileData%GSR,2)
   i2_u = UBOUND(SrcInputFileData%GSR,2)
   IF (.NOT. ALLOCATED(DstInputFileData%GSR)) THEN 
      ALLOCATE(DstInputFileData%GSR(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GSR.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%GSR = SrcInputFileData%GSR
ENDIF
IF (ALLOCATED(SrcInputFileData%GE)) THEN
   i1_l = LBOUND(SrcInputFileData%GE,1)
   i1_u = UBOUND(SrcInputFileData%GE,1)
   i2_l = LBOUND(SrcInputFileData%GE,2)
   i2_u = UBOUND(SrcInputFileData%GE,2)
   i3_l = LBOUND(SrcInputFileData%GE,3)
   i3_u = UBOUND(SrcInputFileData%GE,3)
   IF (.NOT. ALLOCATED(DstInputFileData%GE)) THEN 
      ALLOCATE(DstInputFileData%GE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GE.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%GE = SrcInputFileData%GE
ENDIF
   DstInputFileData%NumLines = SrcInputFileData%NumLines
   DstInputFileData%NumElems = SrcInputFileData%NumElems
   DstInputFileData%Eps = SrcInputFileData%Eps
   DstInputFileData%Gravity = SrcInputFileData%Gravity
   DstInputFileData%WtrDens = SrcInputFileData%WtrDens
   DstInputFileData%MaxIter = SrcInputFileData%MaxIter
   DstInputFileData%SumPrint = SrcInputFileData%SumPrint
   DstInputFileData%OutFile = SrcInputFileData%OutFile
   DstInputFileData%TabDelim = SrcInputFileData%TabDelim
   DstInputFileData%OutFmt = SrcInputFileData%OutFmt
   DstInputFileData%Tstart = SrcInputFileData%Tstart
   DstInputFileData%NumOuts = SrcInputFileData%NumOuts
IF (ALLOCATED(SrcInputFileData%OutList)) THEN
   i1_l = LBOUND(SrcInputFileData%OutList,1)
   i1_u = UBOUND(SrcInputFileData%OutList,1)
   IF (.NOT. ALLOCATED(DstInputFileData%OutList)) THEN 
      ALLOCATE(DstInputFileData%OutList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg,'FEAM_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%OutList = SrcInputFileData%OutList
ENDIF
 END SUBROUTINE FEAM_CopyInputFile

 SUBROUTINE FEAM_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(FEAM_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputFileData%LineCI)) THEN
   DEALLOCATE(InputFileData%LineCI)
ENDIF
IF (ALLOCATED(InputFileData%LineCD)) THEN
   DEALLOCATE(InputFileData%LineCD)
ENDIF
IF (ALLOCATED(InputFileData%LEAStiff)) THEN
   DEALLOCATE(InputFileData%LEAStiff)
ENDIF
IF (ALLOCATED(InputFileData%LMassDen)) THEN
   DEALLOCATE(InputFileData%LMassDen)
ENDIF
IF (ALLOCATED(InputFileData%LDMassDen)) THEN
   DEALLOCATE(InputFileData%LDMassDen)
ENDIF
IF (ALLOCATED(InputFileData%BottmStiff)) THEN
   DEALLOCATE(InputFileData%BottmStiff)
ENDIF
IF (ALLOCATED(InputFileData%LRadAnch)) THEN
   DEALLOCATE(InputFileData%LRadAnch)
ENDIF
IF (ALLOCATED(InputFileData%LAngAnch)) THEN
   DEALLOCATE(InputFileData%LAngAnch)
ENDIF
IF (ALLOCATED(InputFileData%LDpthAnch)) THEN
   DEALLOCATE(InputFileData%LDpthAnch)
ENDIF
IF (ALLOCATED(InputFileData%LRadFair)) THEN
   DEALLOCATE(InputFileData%LRadFair)
ENDIF
IF (ALLOCATED(InputFileData%LAngFair)) THEN
   DEALLOCATE(InputFileData%LAngFair)
ENDIF
IF (ALLOCATED(InputFileData%LDrftFair)) THEN
   DEALLOCATE(InputFileData%LDrftFair)
ENDIF
IF (ALLOCATED(InputFileData%LUnstrLen)) THEN
   DEALLOCATE(InputFileData%LUnstrLen)
ENDIF
IF (ALLOCATED(InputFileData%Tension)) THEN
   DEALLOCATE(InputFileData%Tension)
ENDIF
IF (ALLOCATED(InputFileData%GSL)) THEN
   DEALLOCATE(InputFileData%GSL)
ENDIF
IF (ALLOCATED(InputFileData%GSR)) THEN
   DEALLOCATE(InputFileData%GSR)
ENDIF
IF (ALLOCATED(InputFileData%GE)) THEN
   DEALLOCATE(InputFileData%GE)
ENDIF
IF (ALLOCATED(InputFileData%OutList)) THEN
   DEALLOCATE(InputFileData%OutList)
ENDIF
 END SUBROUTINE FEAM_DestroyInputFile

 SUBROUTINE FEAM_PackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_InputFile),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  IF ( ALLOCATED(InData%LineCI) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LineCI )  ! LineCI 
  IF ( ALLOCATED(InData%LineCD) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LineCD )  ! LineCD 
  IF ( ALLOCATED(InData%LEAStiff) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LEAStiff )  ! LEAStiff 
  IF ( ALLOCATED(InData%LMassDen) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LMassDen )  ! LMassDen 
  IF ( ALLOCATED(InData%LDMassDen) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LDMassDen )  ! LDMassDen 
  IF ( ALLOCATED(InData%BottmStiff) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BottmStiff )  ! BottmStiff 
  IF ( ALLOCATED(InData%LRadAnch) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LRadAnch )  ! LRadAnch 
  IF ( ALLOCATED(InData%LAngAnch) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LAngAnch )  ! LAngAnch 
  IF ( ALLOCATED(InData%LDpthAnch) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LDpthAnch )  ! LDpthAnch 
  IF ( ALLOCATED(InData%LRadFair) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LRadFair )  ! LRadFair 
  IF ( ALLOCATED(InData%LAngFair) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LAngFair )  ! LAngFair 
  IF ( ALLOCATED(InData%LDrftFair) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LDrftFair )  ! LDrftFair 
  IF ( ALLOCATED(InData%LUnstrLen) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LUnstrLen )  ! LUnstrLen 
  IF ( ALLOCATED(InData%Tension) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Tension )  ! Tension 
  IF ( ALLOCATED(InData%GSL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GSL )  ! GSL 
  IF ( ALLOCATED(InData%GSR) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GSR )  ! GSR 
  IF ( ALLOCATED(InData%GE) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GE )  ! GE 
  Int_BufSz  = Int_BufSz  + 1  ! NumLines
  Int_BufSz  = Int_BufSz  + 1  ! NumElems
  Re_BufSz   = Re_BufSz   + 1  ! Eps
  Re_BufSz   = Re_BufSz   + 1  ! Gravity
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  Int_BufSz  = Int_BufSz  + 1  ! MaxIter
  Int_BufSz  = Int_BufSz  + 1  ! SumPrint
  Int_BufSz  = Int_BufSz  + 1  ! OutFile
  Int_BufSz  = Int_BufSz  + 1  ! TabDelim
!  missing buffer for OutFmt
  Db_BufSz   = Db_BufSz   + 1  ! Tstart
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
!  missing buffer for OutList
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%LineCI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LineCI))-1 ) =  PACK(InData%LineCI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LineCI)
  ENDIF
  IF ( ALLOCATED(InData%LineCD) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LineCD))-1 ) =  PACK(InData%LineCD ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LineCD)
  ENDIF
  IF ( ALLOCATED(InData%LEAStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LEAStiff))-1 ) =  PACK(InData%LEAStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(InData%LMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LMassDen))-1 ) =  PACK(InData%LMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LDMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDMassDen))-1 ) =  PACK(InData%LDMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(InData%BottmStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmStiff))-1 ) =  PACK(InData%BottmStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(InData%LRadAnch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LRadAnch))-1 ) =  PACK(InData%LRadAnch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LRadAnch)
  ENDIF
  IF ( ALLOCATED(InData%LAngAnch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAngAnch))-1 ) =  PACK(InData%LAngAnch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAngAnch)
  ENDIF
  IF ( ALLOCATED(InData%LDpthAnch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDpthAnch))-1 ) =  PACK(InData%LDpthAnch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDpthAnch)
  ENDIF
  IF ( ALLOCATED(InData%LRadFair) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LRadFair))-1 ) =  PACK(InData%LRadFair ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LRadFair)
  ENDIF
  IF ( ALLOCATED(InData%LAngFair) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAngFair))-1 ) =  PACK(InData%LAngFair ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAngFair)
  ENDIF
  IF ( ALLOCATED(InData%LDrftFair) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDrftFair))-1 ) =  PACK(InData%LDrftFair ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDrftFair)
  ENDIF
  IF ( ALLOCATED(InData%LUnstrLen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LUnstrLen))-1 ) =  PACK(InData%LUnstrLen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LUnstrLen)
  ENDIF
  IF ( ALLOCATED(InData%Tension) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Tension))-1 ) =  PACK(InData%Tension ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Tension)
  ENDIF
  IF ( ALLOCATED(InData%GSL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GSL))-1 ) =  PACK(InData%GSL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GSL)
  ENDIF
  IF ( ALLOCATED(InData%GSR) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GSR))-1 ) =  PACK(InData%GSR ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GSR)
  ENDIF
  IF ( ALLOCATED(InData%GE) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GE))-1 ) =  PACK(InData%GE ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GE)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumLines )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumElems )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Eps )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxIter )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%SumPrint ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutFile )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%TabDelim ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%Tstart )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FEAM_PackInputFile

 SUBROUTINE FEAM_UnPackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_InputFile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%LineCI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineCI,1)))
  mask1 = .TRUE.
    OutData%LineCI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LineCI))-1 ),mask1,OutData%LineCI)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LineCI)
  ENDIF
  IF ( ALLOCATED(OutData%LineCD) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineCD,1)))
  mask1 = .TRUE.
    OutData%LineCD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LineCD))-1 ),mask1,OutData%LineCD)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LineCD)
  ENDIF
  IF ( ALLOCATED(OutData%LEAStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LEAStiff,1)))
  mask1 = .TRUE.
    OutData%LEAStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LEAStiff))-1 ),mask1,OutData%LEAStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LMassDen,1)))
  mask1 = .TRUE.
    OutData%LMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LMassDen))-1 ),mask1,OutData%LMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LDMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDMassDen,1)))
  mask1 = .TRUE.
    OutData%LDMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDMassDen))-1 ),mask1,OutData%LDMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%BottmStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmStiff,1)))
  mask1 = .TRUE.
    OutData%BottmStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmStiff))-1 ),mask1,OutData%BottmStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LRadAnch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LRadAnch,1)))
  mask1 = .TRUE.
    OutData%LRadAnch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LRadAnch))-1 ),mask1,OutData%LRadAnch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LRadAnch)
  ENDIF
  IF ( ALLOCATED(OutData%LAngAnch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAngAnch,1)))
  mask1 = .TRUE.
    OutData%LAngAnch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAngAnch))-1 ),mask1,OutData%LAngAnch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAngAnch)
  ENDIF
  IF ( ALLOCATED(OutData%LDpthAnch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDpthAnch,1)))
  mask1 = .TRUE.
    OutData%LDpthAnch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDpthAnch))-1 ),mask1,OutData%LDpthAnch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDpthAnch)
  ENDIF
  IF ( ALLOCATED(OutData%LRadFair) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LRadFair,1)))
  mask1 = .TRUE.
    OutData%LRadFair = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LRadFair))-1 ),mask1,OutData%LRadFair)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LRadFair)
  ENDIF
  IF ( ALLOCATED(OutData%LAngFair) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAngFair,1)))
  mask1 = .TRUE.
    OutData%LAngFair = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAngFair))-1 ),mask1,OutData%LAngFair)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAngFair)
  ENDIF
  IF ( ALLOCATED(OutData%LDrftFair) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDrftFair,1)))
  mask1 = .TRUE.
    OutData%LDrftFair = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDrftFair))-1 ),mask1,OutData%LDrftFair)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDrftFair)
  ENDIF
  IF ( ALLOCATED(OutData%LUnstrLen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LUnstrLen,1)))
  mask1 = .TRUE.
    OutData%LUnstrLen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LUnstrLen))-1 ),mask1,OutData%LUnstrLen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LUnstrLen)
  ENDIF
  IF ( ALLOCATED(OutData%Tension) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Tension,1)))
  mask1 = .TRUE.
    OutData%Tension = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Tension))-1 ),mask1,OutData%Tension)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Tension)
  ENDIF
  IF ( ALLOCATED(OutData%GSL) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GSL,1),SIZE(OutData%GSL,2),SIZE(OutData%GSL,3)))
  mask3 = .TRUE.
    OutData%GSL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GSL))-1 ),mask3,OutData%GSL)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GSL)
  ENDIF
  IF ( ALLOCATED(OutData%GSR) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GSR,1),SIZE(OutData%GSR,2)))
  mask2 = .TRUE.
    OutData%GSR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GSR))-1 ),mask2,OutData%GSR)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GSR)
  ENDIF
  IF ( ALLOCATED(OutData%GE) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GE,1),SIZE(OutData%GE,2),SIZE(OutData%GE,3)))
  mask3 = .TRUE.
    OutData%GE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GE))-1 ),mask3,OutData%GE)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GE)
  ENDIF
  OutData%NumLines = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumElems = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Eps = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MaxIter = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Tstart = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackInputFile

 SUBROUTINE FEAM_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(FEAM_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%InputFile = SrcInitInputData%InputFile
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%PtfmInit = SrcInitInputData%PtfmInit
   DstInitInputData%NStepWave = SrcInitInputData%NStepWave
IF (ALLOCATED(SrcInitInputData%WaveAcc0)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveAcc0,1)
   i1_u = UBOUND(SrcInitInputData%WaveAcc0,1)
   i2_l = LBOUND(SrcInitInputData%WaveAcc0,2)
   i2_u = UBOUND(SrcInitInputData%WaveAcc0,2)
   i3_l = LBOUND(SrcInitInputData%WaveAcc0,3)
   i3_u = UBOUND(SrcInitInputData%WaveAcc0,3)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveAcc0)) THEN 
      ALLOCATE(DstInitInputData%WaveAcc0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveAcc0.', ErrStat, ErrMsg,'FEAM_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveAcc0 = SrcInitInputData%WaveAcc0
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveTime)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveTime,1)
   i1_u = UBOUND(SrcInitInputData%WaveTime,1)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveTime)) THEN 
      ALLOCATE(DstInitInputData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveTime.', ErrStat, ErrMsg,'FEAM_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveTime = SrcInitInputData%WaveTime
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveVel0)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveVel0,1)
   i1_u = UBOUND(SrcInitInputData%WaveVel0,1)
   i2_l = LBOUND(SrcInitInputData%WaveVel0,2)
   i2_u = UBOUND(SrcInitInputData%WaveVel0,2)
   i3_l = LBOUND(SrcInitInputData%WaveVel0,3)
   i3_u = UBOUND(SrcInitInputData%WaveVel0,3)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveVel0)) THEN 
      ALLOCATE(DstInitInputData%WaveVel0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveVel0.', ErrStat, ErrMsg,'FEAM_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveVel0 = SrcInitInputData%WaveVel0
ENDIF
   DstInitInputData%Gravity = SrcInitInputData%Gravity
   DstInitInputData%WtrDens = SrcInitInputData%WtrDens
 END SUBROUTINE FEAM_CopyInitInput

 SUBROUTINE FEAM_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(FEAM_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%WaveAcc0)) THEN
   DEALLOCATE(InitInputData%WaveAcc0)
ENDIF
IF (ALLOCATED(InitInputData%WaveTime)) THEN
   DEALLOCATE(InitInputData%WaveTime)
ENDIF
IF (ALLOCATED(InitInputData%WaveVel0)) THEN
   DEALLOCATE(InitInputData%WaveVel0)
ENDIF
 END SUBROUTINE FEAM_DestroyInitInput

 SUBROUTINE FEAM_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for InputFile
!  missing buffer for RootName
  Re_BufSz    = Re_BufSz    + SIZE( InData%PtfmInit )  ! PtfmInit 
  Int_BufSz  = Int_BufSz  + 1  ! NStepWave
  IF ( ALLOCATED(InData%WaveAcc0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveAcc0 )  ! WaveAcc0 
  IF ( ALLOCATED(InData%WaveTime) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveTime )  ! WaveTime 
  IF ( ALLOCATED(InData%WaveVel0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveVel0 )  ! WaveVel0 
  Re_BufSz   = Re_BufSz   + 1  ! Gravity
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PtfmInit))-1 ) =  PACK(InData%PtfmInit ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PtfmInit)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NStepWave )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%WaveAcc0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveAcc0))-1 ) =  PACK(InData%WaveAcc0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveAcc0)
  ENDIF
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveTime))-1 ) =  PACK(InData%WaveTime ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveTime)
  ENDIF
  IF ( ALLOCATED(InData%WaveVel0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveVel0))-1 ) =  PACK(InData%WaveVel0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveVel0)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE FEAM_PackInitInput

 SUBROUTINE FEAM_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  ALLOCATE(mask1(SIZE(OutData%PtfmInit,1)))
  mask1 = .TRUE.
  OutData%PtfmInit = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PtfmInit))-1 ),mask1,OutData%PtfmInit)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PtfmInit)
  OutData%NStepWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%WaveAcc0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveAcc0,1),SIZE(OutData%WaveAcc0,2),SIZE(OutData%WaveAcc0,3)))
  mask3 = .TRUE.
    OutData%WaveAcc0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveAcc0))-1 ),mask3,OutData%WaveAcc0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveAcc0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveTime) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveTime,1)))
  mask1 = .TRUE.
    OutData%WaveTime = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveTime))-1 ),mask1,OutData%WaveTime)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveTime)
  ENDIF
  IF ( ALLOCATED(OutData%WaveVel0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveVel0,1),SIZE(OutData%WaveVel0,2),SIZE(OutData%WaveVel0,3)))
  mask3 = .TRUE.
    OutData%WaveVel0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveVel0))-1 ),mask3,OutData%WaveVel0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveVel0)
  ENDIF
  OutData%Gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackInitInput

 SUBROUTINE FEAM_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(FEAM_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'FEAM_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'FEAM_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_CopyInitOutput:Ver')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%LAnchxi)) THEN
   i1_l = LBOUND(SrcInitOutputData%LAnchxi,1)
   i1_u = UBOUND(SrcInitOutputData%LAnchxi,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%LAnchxi)) THEN 
      ALLOCATE(DstInitOutputData%LAnchxi(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LAnchxi.', ErrStat, ErrMsg,'FEAM_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%LAnchxi = SrcInitOutputData%LAnchxi
ENDIF
IF (ALLOCATED(SrcInitOutputData%LAnchyi)) THEN
   i1_l = LBOUND(SrcInitOutputData%LAnchyi,1)
   i1_u = UBOUND(SrcInitOutputData%LAnchyi,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%LAnchyi)) THEN 
      ALLOCATE(DstInitOutputData%LAnchyi(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LAnchyi.', ErrStat, ErrMsg,'FEAM_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%LAnchyi = SrcInitOutputData%LAnchyi
ENDIF
IF (ALLOCATED(SrcInitOutputData%LAnchzi)) THEN
   i1_l = LBOUND(SrcInitOutputData%LAnchzi,1)
   i1_u = UBOUND(SrcInitOutputData%LAnchzi,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%LAnchzi)) THEN 
      ALLOCATE(DstInitOutputData%LAnchzi(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LAnchzi.', ErrStat, ErrMsg,'FEAM_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%LAnchzi = SrcInitOutputData%LAnchzi
ENDIF
IF (ALLOCATED(SrcInitOutputData%LFairxt)) THEN
   i1_l = LBOUND(SrcInitOutputData%LFairxt,1)
   i1_u = UBOUND(SrcInitOutputData%LFairxt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%LFairxt)) THEN 
      ALLOCATE(DstInitOutputData%LFairxt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LFairxt.', ErrStat, ErrMsg,'FEAM_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%LFairxt = SrcInitOutputData%LFairxt
ENDIF
IF (ALLOCATED(SrcInitOutputData%LFairyt)) THEN
   i1_l = LBOUND(SrcInitOutputData%LFairyt,1)
   i1_u = UBOUND(SrcInitOutputData%LFairyt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%LFairyt)) THEN 
      ALLOCATE(DstInitOutputData%LFairyt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LFairyt.', ErrStat, ErrMsg,'FEAM_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%LFairyt = SrcInitOutputData%LFairyt
ENDIF
IF (ALLOCATED(SrcInitOutputData%LFairzt)) THEN
   i1_l = LBOUND(SrcInitOutputData%LFairzt,1)
   i1_u = UBOUND(SrcInitOutputData%LFairzt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%LFairzt)) THEN 
      ALLOCATE(DstInitOutputData%LFairzt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LFairzt.', ErrStat, ErrMsg,'FEAM_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%LFairzt = SrcInitOutputData%LFairzt
ENDIF
 END SUBROUTINE FEAM_CopyInitOutput

 SUBROUTINE FEAM_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(FEAM_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
IF (ALLOCATED(InitOutputData%LAnchxi)) THEN
   DEALLOCATE(InitOutputData%LAnchxi)
ENDIF
IF (ALLOCATED(InitOutputData%LAnchyi)) THEN
   DEALLOCATE(InitOutputData%LAnchyi)
ENDIF
IF (ALLOCATED(InitOutputData%LAnchzi)) THEN
   DEALLOCATE(InitOutputData%LAnchzi)
ENDIF
IF (ALLOCATED(InitOutputData%LFairxt)) THEN
   DEALLOCATE(InitOutputData%LFairxt)
ENDIF
IF (ALLOCATED(InitOutputData%LFairyt)) THEN
   DEALLOCATE(InitOutputData%LFairyt)
ENDIF
IF (ALLOCATED(InitOutputData%LFairzt)) THEN
   DEALLOCATE(InitOutputData%LFairzt)
ENDIF
 END SUBROUTINE FEAM_DestroyInitOutput

 SUBROUTINE FEAM_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  IF ( ALLOCATED(InData%LAnchxi) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LAnchxi )  ! LAnchxi 
  IF ( ALLOCATED(InData%LAnchyi) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LAnchyi )  ! LAnchyi 
  IF ( ALLOCATED(InData%LAnchzi) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LAnchzi )  ! LAnchzi 
  IF ( ALLOCATED(InData%LFairxt) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LFairxt )  ! LFairxt 
  IF ( ALLOCATED(InData%LFairyt) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LFairyt )  ! LFairyt 
  IF ( ALLOCATED(InData%LFairzt) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LFairzt )  ! LFairzt 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
  IF ( ALLOCATED(InData%LAnchxi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAnchxi))-1 ) =  PACK(InData%LAnchxi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAnchxi)
  ENDIF
  IF ( ALLOCATED(InData%LAnchyi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAnchyi))-1 ) =  PACK(InData%LAnchyi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAnchyi)
  ENDIF
  IF ( ALLOCATED(InData%LAnchzi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAnchzi))-1 ) =  PACK(InData%LAnchzi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAnchzi)
  ENDIF
  IF ( ALLOCATED(InData%LFairxt) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LFairxt))-1 ) =  PACK(InData%LFairxt ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LFairxt)
  ENDIF
  IF ( ALLOCATED(InData%LFairyt) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LFairyt))-1 ) =  PACK(InData%LFairyt ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LFairyt)
  ENDIF
  IF ( ALLOCATED(InData%LFairzt) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LFairzt))-1 ) =  PACK(InData%LFairzt ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LFairzt)
  ENDIF
 END SUBROUTINE FEAM_PackInitOutput

 SUBROUTINE FEAM_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  IF ( ALLOCATED(OutData%LAnchxi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAnchxi,1)))
  mask1 = .TRUE.
    OutData%LAnchxi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAnchxi))-1 ),mask1,OutData%LAnchxi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAnchxi)
  ENDIF
  IF ( ALLOCATED(OutData%LAnchyi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAnchyi,1)))
  mask1 = .TRUE.
    OutData%LAnchyi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAnchyi))-1 ),mask1,OutData%LAnchyi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAnchyi)
  ENDIF
  IF ( ALLOCATED(OutData%LAnchzi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAnchzi,1)))
  mask1 = .TRUE.
    OutData%LAnchzi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAnchzi))-1 ),mask1,OutData%LAnchzi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAnchzi)
  ENDIF
  IF ( ALLOCATED(OutData%LFairxt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LFairxt,1)))
  mask1 = .TRUE.
    OutData%LFairxt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LFairxt))-1 ),mask1,OutData%LFairxt)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LFairxt)
  ENDIF
  IF ( ALLOCATED(OutData%LFairyt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LFairyt,1)))
  mask1 = .TRUE.
    OutData%LFairyt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LFairyt))-1 ),mask1,OutData%LFairyt)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LFairyt)
  ENDIF
  IF ( ALLOCATED(OutData%LFairzt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LFairzt,1)))
  mask1 = .TRUE.
    OutData%LFairzt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LFairzt))-1 ),mask1,OutData%LFairzt)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LFairzt)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackInitOutput

 SUBROUTINE FEAM_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(FEAM_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%GLU)) THEN
   i1_l = LBOUND(SrcContStateData%GLU,1)
   i1_u = UBOUND(SrcContStateData%GLU,1)
   i2_l = LBOUND(SrcContStateData%GLU,2)
   i2_u = UBOUND(SrcContStateData%GLU,2)
   IF (.NOT. ALLOCATED(DstContStateData%GLU)) THEN 
      ALLOCATE(DstContStateData%GLU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%GLU.', ErrStat, ErrMsg,'FEAM_CopyContState')
         RETURN
      END IF
   END IF
   DstContStateData%GLU = SrcContStateData%GLU
ENDIF
IF (ALLOCATED(SrcContStateData%GLDU)) THEN
   i1_l = LBOUND(SrcContStateData%GLDU,1)
   i1_u = UBOUND(SrcContStateData%GLDU,1)
   i2_l = LBOUND(SrcContStateData%GLDU,2)
   i2_u = UBOUND(SrcContStateData%GLDU,2)
   IF (.NOT. ALLOCATED(DstContStateData%GLDU)) THEN 
      ALLOCATE(DstContStateData%GLDU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%GLDU.', ErrStat, ErrMsg,'FEAM_CopyContState')
         RETURN
      END IF
   END IF
   DstContStateData%GLDU = SrcContStateData%GLDU
ENDIF
 END SUBROUTINE FEAM_CopyContState

 SUBROUTINE FEAM_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(FEAM_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ContStateData%GLU)) THEN
   DEALLOCATE(ContStateData%GLU)
ENDIF
IF (ALLOCATED(ContStateData%GLDU)) THEN
   DEALLOCATE(ContStateData%GLDU)
ENDIF
 END SUBROUTINE FEAM_DestroyContState

 SUBROUTINE FEAM_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%GLU) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GLU )  ! GLU 
  IF ( ALLOCATED(InData%GLDU) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GLDU )  ! GLDU 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%GLU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLU))-1 ) =  PACK(InData%GLU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLU)
  ENDIF
  IF ( ALLOCATED(InData%GLDU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLDU))-1 ) =  PACK(InData%GLDU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLDU)
  ENDIF
 END SUBROUTINE FEAM_PackContState

 SUBROUTINE FEAM_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%GLU) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLU,1),SIZE(OutData%GLU,2)))
  mask2 = .TRUE.
    OutData%GLU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLU))-1 ),mask2,OutData%GLU)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLU)
  ENDIF
  IF ( ALLOCATED(OutData%GLDU) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLDU,1),SIZE(OutData%GLDU,2)))
  mask2 = .TRUE.
    OutData%GLDU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLDU))-1 ),mask2,OutData%GLDU)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLDU)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackContState

 SUBROUTINE FEAM_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(FEAM_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE FEAM_CopyDiscState

 SUBROUTINE FEAM_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(FEAM_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FEAM_DestroyDiscState

 SUBROUTINE FEAM_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE FEAM_PackDiscState

 SUBROUTINE FEAM_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackDiscState

 SUBROUTINE FEAM_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(FEAM_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%TSN = SrcConstrStateData%TSN
   DstConstrStateData%TZER = SrcConstrStateData%TZER
 END SUBROUTINE FEAM_CopyConstrState

 SUBROUTINE FEAM_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(FEAM_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FEAM_DestroyConstrState

 SUBROUTINE FEAM_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%TSN )  ! TSN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%TZER )  ! TZER 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TSN))-1 ) =  PACK(InData%TSN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TSN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TZER))-1 ) =  PACK(InData%TZER ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TZER)
 END SUBROUTINE FEAM_PackConstrState

 SUBROUTINE FEAM_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  ALLOCATE(mask1(SIZE(OutData%TSN,1)))
  mask1 = .TRUE.
  OutData%TSN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TSN))-1 ),mask1,OutData%TSN)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TSN)
  ALLOCATE(mask1(SIZE(OutData%TZER,1)))
  mask1 = .TRUE.
  OutData%TZER = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TZER))-1 ),mask1,OutData%TZER)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TZER)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackConstrState

 SUBROUTINE FEAM_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(FEAM_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%GLU0)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLU0,1)
   i1_u = UBOUND(SrcOtherStateData%GLU0,1)
   i2_l = LBOUND(SrcOtherStateData%GLU0,2)
   i2_u = UBOUND(SrcOtherStateData%GLU0,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%GLU0)) THEN 
      ALLOCATE(DstOtherStateData%GLU0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GLU0.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%GLU0 = SrcOtherStateData%GLU0
ENDIF
IF (ALLOCATED(SrcOtherStateData%GLDDU)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLDDU,1)
   i1_u = UBOUND(SrcOtherStateData%GLDDU,1)
   i2_l = LBOUND(SrcOtherStateData%GLDDU,2)
   i2_u = UBOUND(SrcOtherStateData%GLDDU,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%GLDDU)) THEN 
      ALLOCATE(DstOtherStateData%GLDDU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GLDDU.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%GLDDU = SrcOtherStateData%GLDDU
ENDIF
IF (ALLOCATED(SrcOtherStateData%GLF)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLF,1)
   i1_u = UBOUND(SrcOtherStateData%GLF,1)
   i2_l = LBOUND(SrcOtherStateData%GLF,2)
   i2_u = UBOUND(SrcOtherStateData%GLF,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%GLF)) THEN 
      ALLOCATE(DstOtherStateData%GLF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GLF.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%GLF = SrcOtherStateData%GLF
ENDIF
IF (ALLOCATED(SrcOtherStateData%GLK)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLK,1)
   i1_u = UBOUND(SrcOtherStateData%GLK,1)
   i2_l = LBOUND(SrcOtherStateData%GLK,2)
   i2_u = UBOUND(SrcOtherStateData%GLK,2)
   i3_l = LBOUND(SrcOtherStateData%GLK,3)
   i3_u = UBOUND(SrcOtherStateData%GLK,3)
   IF (.NOT. ALLOCATED(DstOtherStateData%GLK)) THEN 
      ALLOCATE(DstOtherStateData%GLK(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GLK.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%GLK = SrcOtherStateData%GLK
ENDIF
IF (ALLOCATED(SrcOtherStateData%GLUZR)) THEN
   i1_l = LBOUND(SrcOtherStateData%GLUZR,1)
   i1_u = UBOUND(SrcOtherStateData%GLUZR,1)
   i2_l = LBOUND(SrcOtherStateData%GLUZR,2)
   i2_u = UBOUND(SrcOtherStateData%GLUZR,2)
   i3_l = LBOUND(SrcOtherStateData%GLUZR,3)
   i3_u = UBOUND(SrcOtherStateData%GLUZR,3)
   IF (.NOT. ALLOCATED(DstOtherStateData%GLUZR)) THEN 
      ALLOCATE(DstOtherStateData%GLUZR(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GLUZR.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%GLUZR = SrcOtherStateData%GLUZR
ENDIF
IF (ALLOCATED(SrcOtherStateData%GTZER)) THEN
   i1_l = LBOUND(SrcOtherStateData%GTZER,1)
   i1_u = UBOUND(SrcOtherStateData%GTZER,1)
   i2_l = LBOUND(SrcOtherStateData%GTZER,2)
   i2_u = UBOUND(SrcOtherStateData%GTZER,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%GTZER)) THEN 
      ALLOCATE(DstOtherStateData%GTZER(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GTZER.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%GTZER = SrcOtherStateData%GTZER
ENDIF
IF (ALLOCATED(SrcOtherStateData%GFORC0)) THEN
   i1_l = LBOUND(SrcOtherStateData%GFORC0,1)
   i1_u = UBOUND(SrcOtherStateData%GFORC0,1)
   i2_l = LBOUND(SrcOtherStateData%GFORC0,2)
   i2_u = UBOUND(SrcOtherStateData%GFORC0,2)
   i3_l = LBOUND(SrcOtherStateData%GFORC0,3)
   i3_u = UBOUND(SrcOtherStateData%GFORC0,3)
   IF (.NOT. ALLOCATED(DstOtherStateData%GFORC0)) THEN 
      ALLOCATE(DstOtherStateData%GFORC0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GFORC0.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%GFORC0 = SrcOtherStateData%GFORC0
ENDIF
IF (ALLOCATED(SrcOtherStateData%GMASS0)) THEN
   i1_l = LBOUND(SrcOtherStateData%GMASS0,1)
   i1_u = UBOUND(SrcOtherStateData%GMASS0,1)
   i2_l = LBOUND(SrcOtherStateData%GMASS0,2)
   i2_u = UBOUND(SrcOtherStateData%GMASS0,2)
   i3_l = LBOUND(SrcOtherStateData%GMASS0,3)
   i3_u = UBOUND(SrcOtherStateData%GMASS0,3)
   i4_l = LBOUND(SrcOtherStateData%GMASS0,4)
   i4_u = UBOUND(SrcOtherStateData%GMASS0,4)
   IF (.NOT. ALLOCATED(DstOtherStateData%GMASS0)) THEN 
      ALLOCATE(DstOtherStateData%GMASS0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GMASS0.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%GMASS0 = SrcOtherStateData%GMASS0
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAST_FP)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAST_FP,1)
   i1_u = UBOUND(SrcOtherStateData%FAST_FP,1)
   i2_l = LBOUND(SrcOtherStateData%FAST_FP,2)
   i2_u = UBOUND(SrcOtherStateData%FAST_FP,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%FAST_FP)) THEN 
      ALLOCATE(DstOtherStateData%FAST_FP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%FAST_FP.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%FAST_FP = SrcOtherStateData%FAST_FP
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAST_FPA)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAST_FPA,1)
   i1_u = UBOUND(SrcOtherStateData%FAST_FPA,1)
   i2_l = LBOUND(SrcOtherStateData%FAST_FPA,2)
   i2_u = UBOUND(SrcOtherStateData%FAST_FPA,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%FAST_FPA)) THEN 
      ALLOCATE(DstOtherStateData%FAST_FPA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%FAST_FPA.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%FAST_FPA = SrcOtherStateData%FAST_FPA
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAIR_T)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAIR_T,1)
   i1_u = UBOUND(SrcOtherStateData%FAIR_T,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%FAIR_T)) THEN 
      ALLOCATE(DstOtherStateData%FAIR_T(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%FAIR_T.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%FAIR_T = SrcOtherStateData%FAIR_T
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAST_RP)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAST_RP,1)
   i1_u = UBOUND(SrcOtherStateData%FAST_RP,1)
   i2_l = LBOUND(SrcOtherStateData%FAST_RP,2)
   i2_u = UBOUND(SrcOtherStateData%FAST_RP,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%FAST_RP)) THEN 
      ALLOCATE(DstOtherStateData%FAST_RP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%FAST_RP.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%FAST_RP = SrcOtherStateData%FAST_RP
ENDIF
IF (ALLOCATED(SrcOtherStateData%ANCH_T)) THEN
   i1_l = LBOUND(SrcOtherStateData%ANCH_T,1)
   i1_u = UBOUND(SrcOtherStateData%ANCH_T,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%ANCH_T)) THEN 
      ALLOCATE(DstOtherStateData%ANCH_T(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%ANCH_T.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%ANCH_T = SrcOtherStateData%ANCH_T
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAIR_ANG)) THEN
   i1_l = LBOUND(SrcOtherStateData%FAIR_ANG,1)
   i1_u = UBOUND(SrcOtherStateData%FAIR_ANG,1)
   i2_l = LBOUND(SrcOtherStateData%FAIR_ANG,2)
   i2_u = UBOUND(SrcOtherStateData%FAIR_ANG,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%FAIR_ANG)) THEN 
      ALLOCATE(DstOtherStateData%FAIR_ANG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%FAIR_ANG.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%FAIR_ANG = SrcOtherStateData%FAIR_ANG
ENDIF
IF (ALLOCATED(SrcOtherStateData%ANCH_ANG)) THEN
   i1_l = LBOUND(SrcOtherStateData%ANCH_ANG,1)
   i1_u = UBOUND(SrcOtherStateData%ANCH_ANG,1)
   i2_l = LBOUND(SrcOtherStateData%ANCH_ANG,2)
   i2_u = UBOUND(SrcOtherStateData%ANCH_ANG,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%ANCH_ANG)) THEN 
      ALLOCATE(DstOtherStateData%ANCH_ANG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%ANCH_ANG.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%ANCH_ANG = SrcOtherStateData%ANCH_ANG
ENDIF
   DstOtherStateData%ESTIF = SrcOtherStateData%ESTIF
   DstOtherStateData%EMASS = SrcOtherStateData%EMASS
   DstOtherStateData%FORCE = SrcOtherStateData%FORCE
   DstOtherStateData%RSDF = SrcOtherStateData%RSDF
IF (ALLOCATED(SrcOtherStateData%F_Lines)) THEN
   i1_l = LBOUND(SrcOtherStateData%F_Lines,1)
   i1_u = UBOUND(SrcOtherStateData%F_Lines,1)
   i2_l = LBOUND(SrcOtherStateData%F_Lines,2)
   i2_u = UBOUND(SrcOtherStateData%F_Lines,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%F_Lines)) THEN 
      ALLOCATE(DstOtherStateData%F_Lines(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%F_Lines.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%F_Lines = SrcOtherStateData%F_Lines
ENDIF
   DstOtherStateData%U = SrcOtherStateData%U
   DstOtherStateData%U0 = SrcOtherStateData%U0
   DstOtherStateData%DU = SrcOtherStateData%DU
   DstOtherStateData%DDU = SrcOtherStateData%DDU
   DstOtherStateData%FORC0 = SrcOtherStateData%FORC0
   DstOtherStateData%EMAS0 = SrcOtherStateData%EMAS0
   DstOtherStateData%INCR = SrcOtherStateData%INCR
   DstOtherStateData%BottomTouch = SrcOtherStateData%BottomTouch
   DstOtherStateData%Iteration1 = SrcOtherStateData%Iteration1
   DstOtherStateData%Iteration2 = SrcOtherStateData%Iteration2
   DstOtherStateData%R = SrcOtherStateData%R
   DstOtherStateData%RP = SrcOtherStateData%RP
   DstOtherStateData%FP = SrcOtherStateData%FP
   DstOtherStateData%SLIN = SrcOtherStateData%SLIN
   DstOtherStateData%STIFR = SrcOtherStateData%STIFR
   DstOtherStateData%RHSR = SrcOtherStateData%RHSR
IF (ALLOCATED(SrcOtherStateData%Line_Coordinate)) THEN
   i1_l = LBOUND(SrcOtherStateData%Line_Coordinate,1)
   i1_u = UBOUND(SrcOtherStateData%Line_Coordinate,1)
   i2_l = LBOUND(SrcOtherStateData%Line_Coordinate,2)
   i2_u = UBOUND(SrcOtherStateData%Line_Coordinate,2)
   i3_l = LBOUND(SrcOtherStateData%Line_Coordinate,3)
   i3_u = UBOUND(SrcOtherStateData%Line_Coordinate,3)
   IF (.NOT. ALLOCATED(DstOtherStateData%Line_Coordinate)) THEN 
      ALLOCATE(DstOtherStateData%Line_Coordinate(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Line_Coordinate.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%Line_Coordinate = SrcOtherStateData%Line_Coordinate
ENDIF
IF (ALLOCATED(SrcOtherStateData%Line_Tangent)) THEN
   i1_l = LBOUND(SrcOtherStateData%Line_Tangent,1)
   i1_u = UBOUND(SrcOtherStateData%Line_Tangent,1)
   i2_l = LBOUND(SrcOtherStateData%Line_Tangent,2)
   i2_u = UBOUND(SrcOtherStateData%Line_Tangent,2)
   i3_l = LBOUND(SrcOtherStateData%Line_Tangent,3)
   i3_u = UBOUND(SrcOtherStateData%Line_Tangent,3)
   IF (.NOT. ALLOCATED(DstOtherStateData%Line_Tangent)) THEN 
      ALLOCATE(DstOtherStateData%Line_Tangent(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Line_Tangent.', ErrStat, ErrMsg,'FEAM_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%Line_Tangent = SrcOtherStateData%Line_Tangent
ENDIF
   DstOtherStateData%LastIndWave = SrcOtherStateData%LastIndWave
 END SUBROUTINE FEAM_CopyOtherState

 SUBROUTINE FEAM_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(FEAM_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%GLU0)) THEN
   DEALLOCATE(OtherStateData%GLU0)
ENDIF
IF (ALLOCATED(OtherStateData%GLDDU)) THEN
   DEALLOCATE(OtherStateData%GLDDU)
ENDIF
IF (ALLOCATED(OtherStateData%GLF)) THEN
   DEALLOCATE(OtherStateData%GLF)
ENDIF
IF (ALLOCATED(OtherStateData%GLK)) THEN
   DEALLOCATE(OtherStateData%GLK)
ENDIF
IF (ALLOCATED(OtherStateData%GLUZR)) THEN
   DEALLOCATE(OtherStateData%GLUZR)
ENDIF
IF (ALLOCATED(OtherStateData%GTZER)) THEN
   DEALLOCATE(OtherStateData%GTZER)
ENDIF
IF (ALLOCATED(OtherStateData%GFORC0)) THEN
   DEALLOCATE(OtherStateData%GFORC0)
ENDIF
IF (ALLOCATED(OtherStateData%GMASS0)) THEN
   DEALLOCATE(OtherStateData%GMASS0)
ENDIF
IF (ALLOCATED(OtherStateData%FAST_FP)) THEN
   DEALLOCATE(OtherStateData%FAST_FP)
ENDIF
IF (ALLOCATED(OtherStateData%FAST_FPA)) THEN
   DEALLOCATE(OtherStateData%FAST_FPA)
ENDIF
IF (ALLOCATED(OtherStateData%FAIR_T)) THEN
   DEALLOCATE(OtherStateData%FAIR_T)
ENDIF
IF (ALLOCATED(OtherStateData%FAST_RP)) THEN
   DEALLOCATE(OtherStateData%FAST_RP)
ENDIF
IF (ALLOCATED(OtherStateData%ANCH_T)) THEN
   DEALLOCATE(OtherStateData%ANCH_T)
ENDIF
IF (ALLOCATED(OtherStateData%FAIR_ANG)) THEN
   DEALLOCATE(OtherStateData%FAIR_ANG)
ENDIF
IF (ALLOCATED(OtherStateData%ANCH_ANG)) THEN
   DEALLOCATE(OtherStateData%ANCH_ANG)
ENDIF
IF (ALLOCATED(OtherStateData%F_Lines)) THEN
   DEALLOCATE(OtherStateData%F_Lines)
ENDIF
IF (ALLOCATED(OtherStateData%Line_Coordinate)) THEN
   DEALLOCATE(OtherStateData%Line_Coordinate)
ENDIF
IF (ALLOCATED(OtherStateData%Line_Tangent)) THEN
   DEALLOCATE(OtherStateData%Line_Tangent)
ENDIF
 END SUBROUTINE FEAM_DestroyOtherState

 SUBROUTINE FEAM_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%GLU0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GLU0 )  ! GLU0 
  IF ( ALLOCATED(InData%GLDDU) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GLDDU )  ! GLDDU 
  IF ( ALLOCATED(InData%GLF) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GLF )  ! GLF 
  IF ( ALLOCATED(InData%GLK) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GLK )  ! GLK 
  IF ( ALLOCATED(InData%GLUZR) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GLUZR )  ! GLUZR 
  IF ( ALLOCATED(InData%GTZER) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GTZER )  ! GTZER 
  IF ( ALLOCATED(InData%GFORC0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GFORC0 )  ! GFORC0 
  IF ( ALLOCATED(InData%GMASS0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GMASS0 )  ! GMASS0 
  IF ( ALLOCATED(InData%FAST_FP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FAST_FP )  ! FAST_FP 
  IF ( ALLOCATED(InData%FAST_FPA) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FAST_FPA )  ! FAST_FPA 
  IF ( ALLOCATED(InData%FAIR_T) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FAIR_T )  ! FAIR_T 
  IF ( ALLOCATED(InData%FAST_RP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FAST_RP )  ! FAST_RP 
  IF ( ALLOCATED(InData%ANCH_T) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ANCH_T )  ! ANCH_T 
  IF ( ALLOCATED(InData%FAIR_ANG) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FAIR_ANG )  ! FAIR_ANG 
  IF ( ALLOCATED(InData%ANCH_ANG) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ANCH_ANG )  ! ANCH_ANG 
  Re_BufSz    = Re_BufSz    + SIZE( InData%ESTIF )  ! ESTIF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%EMASS )  ! EMASS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FORCE )  ! FORCE 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RSDF )  ! RSDF 
  IF ( ALLOCATED(InData%F_Lines) )   Re_BufSz    = Re_BufSz    + SIZE( InData%F_Lines )  ! F_Lines 
  Re_BufSz    = Re_BufSz    + SIZE( InData%U )  ! U 
  Re_BufSz    = Re_BufSz    + SIZE( InData%U0 )  ! U0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%DU )  ! DU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%DDU )  ! DDU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FORC0 )  ! FORC0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%EMAS0 )  ! EMAS0 
  Int_BufSz  = Int_BufSz  + 1  ! INCR
  Int_BufSz  = Int_BufSz  + 1  ! BottomTouch
  Int_BufSz  = Int_BufSz  + 1  ! Iteration1
  Int_BufSz  = Int_BufSz  + 1  ! Iteration2
  Re_BufSz    = Re_BufSz    + SIZE( InData%R )  ! R 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RP )  ! RP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FP )  ! FP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SLIN )  ! SLIN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%STIFR )  ! STIFR 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RHSR )  ! RHSR 
  IF ( ALLOCATED(InData%Line_Coordinate) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Line_Coordinate )  ! Line_Coordinate 
  IF ( ALLOCATED(InData%Line_Tangent) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Line_Tangent )  ! Line_Tangent 
  Int_BufSz  = Int_BufSz  + 1  ! LastIndWave
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%GLU0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLU0))-1 ) =  PACK(InData%GLU0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLU0)
  ENDIF
  IF ( ALLOCATED(InData%GLDDU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLDDU))-1 ) =  PACK(InData%GLDDU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLDDU)
  ENDIF
  IF ( ALLOCATED(InData%GLF) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLF))-1 ) =  PACK(InData%GLF ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLF)
  ENDIF
  IF ( ALLOCATED(InData%GLK) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLK))-1 ) =  PACK(InData%GLK ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLK)
  ENDIF
  IF ( ALLOCATED(InData%GLUZR) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLUZR))-1 ) =  PACK(InData%GLUZR ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLUZR)
  ENDIF
  IF ( ALLOCATED(InData%GTZER) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GTZER))-1 ) =  PACK(InData%GTZER ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GTZER)
  ENDIF
  IF ( ALLOCATED(InData%GFORC0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GFORC0))-1 ) =  PACK(InData%GFORC0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GFORC0)
  ENDIF
  IF ( ALLOCATED(InData%GMASS0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GMASS0))-1 ) =  PACK(InData%GMASS0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GMASS0)
  ENDIF
  IF ( ALLOCATED(InData%FAST_FP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAST_FP))-1 ) =  PACK(InData%FAST_FP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAST_FP)
  ENDIF
  IF ( ALLOCATED(InData%FAST_FPA) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAST_FPA))-1 ) =  PACK(InData%FAST_FPA ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAST_FPA)
  ENDIF
  IF ( ALLOCATED(InData%FAIR_T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAIR_T))-1 ) =  PACK(InData%FAIR_T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAIR_T)
  ENDIF
  IF ( ALLOCATED(InData%FAST_RP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAST_RP))-1 ) =  PACK(InData%FAST_RP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAST_RP)
  ENDIF
  IF ( ALLOCATED(InData%ANCH_T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ANCH_T))-1 ) =  PACK(InData%ANCH_T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ANCH_T)
  ENDIF
  IF ( ALLOCATED(InData%FAIR_ANG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAIR_ANG))-1 ) =  PACK(InData%FAIR_ANG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAIR_ANG)
  ENDIF
  IF ( ALLOCATED(InData%ANCH_ANG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ANCH_ANG))-1 ) =  PACK(InData%ANCH_ANG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ANCH_ANG)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ESTIF))-1 ) =  PACK(InData%ESTIF ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%ESTIF)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%EMASS))-1 ) =  PACK(InData%EMASS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%EMASS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FORCE))-1 ) =  PACK(InData%FORCE ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%FORCE)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RSDF))-1 ) =  PACK(InData%RSDF ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RSDF)
  IF ( ALLOCATED(InData%F_Lines) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_Lines))-1 ) =  PACK(InData%F_Lines ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F_Lines)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%U))-1 ) =  PACK(InData%U ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%U)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%U0))-1 ) =  PACK(InData%U0 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%U0)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DU))-1 ) =  PACK(InData%DU ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DU)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DDU))-1 ) =  PACK(InData%DDU ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DDU)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FORC0))-1 ) =  PACK(InData%FORC0 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%FORC0)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%EMAS0))-1 ) =  PACK(InData%EMAS0 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%EMAS0)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%INCR )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%BottomTouch ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%Iteration1 ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%Iteration2 ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%R))-1 ) =  PACK(InData%R ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%R)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RP))-1 ) =  PACK(InData%RP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FP))-1 ) =  PACK(InData%FP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%FP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SLIN))-1 ) =  PACK(InData%SLIN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SLIN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%STIFR))-1 ) =  PACK(InData%STIFR ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%STIFR)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RHSR))-1 ) =  PACK(InData%RHSR ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RHSR)
  IF ( ALLOCATED(InData%Line_Coordinate) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Line_Coordinate))-1 ) =  PACK(InData%Line_Coordinate ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Line_Coordinate)
  ENDIF
  IF ( ALLOCATED(InData%Line_Tangent) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Line_Tangent))-1 ) =  PACK(InData%Line_Tangent ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Line_Tangent)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%LastIndWave )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FEAM_PackOtherState

 SUBROUTINE FEAM_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%GLU0) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLU0,1),SIZE(OutData%GLU0,2)))
  mask2 = .TRUE.
    OutData%GLU0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLU0))-1 ),mask2,OutData%GLU0)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLU0)
  ENDIF
  IF ( ALLOCATED(OutData%GLDDU) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLDDU,1),SIZE(OutData%GLDDU,2)))
  mask2 = .TRUE.
    OutData%GLDDU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLDDU))-1 ),mask2,OutData%GLDDU)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLDDU)
  ENDIF
  IF ( ALLOCATED(OutData%GLF) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLF,1),SIZE(OutData%GLF,2)))
  mask2 = .TRUE.
    OutData%GLF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLF))-1 ),mask2,OutData%GLF)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLF)
  ENDIF
  IF ( ALLOCATED(OutData%GLK) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GLK,1),SIZE(OutData%GLK,2),SIZE(OutData%GLK,3)))
  mask3 = .TRUE.
    OutData%GLK = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLK))-1 ),mask3,OutData%GLK)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLK)
  ENDIF
  IF ( ALLOCATED(OutData%GLUZR) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GLUZR,1),SIZE(OutData%GLUZR,2),SIZE(OutData%GLUZR,3)))
  mask3 = .TRUE.
    OutData%GLUZR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLUZR))-1 ),mask3,OutData%GLUZR)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLUZR)
  ENDIF
  IF ( ALLOCATED(OutData%GTZER) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GTZER,1),SIZE(OutData%GTZER,2)))
  mask2 = .TRUE.
    OutData%GTZER = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GTZER))-1 ),mask2,OutData%GTZER)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GTZER)
  ENDIF
  IF ( ALLOCATED(OutData%GFORC0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GFORC0,1),SIZE(OutData%GFORC0,2),SIZE(OutData%GFORC0,3)))
  mask3 = .TRUE.
    OutData%GFORC0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GFORC0))-1 ),mask3,OutData%GFORC0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GFORC0)
  ENDIF
  IF ( ALLOCATED(OutData%GMASS0) ) THEN
  ALLOCATE(mask4(SIZE(OutData%GMASS0,1),SIZE(OutData%GMASS0,2),SIZE(OutData%GMASS0,3),SIZE(OutData%GMASS0,4)))
  mask4 = .TRUE.
    OutData%GMASS0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GMASS0))-1 ),mask4,OutData%GMASS0)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GMASS0)
  ENDIF
  IF ( ALLOCATED(OutData%FAST_FP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAST_FP,1),SIZE(OutData%FAST_FP,2)))
  mask2 = .TRUE.
    OutData%FAST_FP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAST_FP))-1 ),mask2,OutData%FAST_FP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAST_FP)
  ENDIF
  IF ( ALLOCATED(OutData%FAST_FPA) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAST_FPA,1),SIZE(OutData%FAST_FPA,2)))
  mask2 = .TRUE.
    OutData%FAST_FPA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAST_FPA))-1 ),mask2,OutData%FAST_FPA)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAST_FPA)
  ENDIF
  IF ( ALLOCATED(OutData%FAIR_T) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FAIR_T,1)))
  mask1 = .TRUE.
    OutData%FAIR_T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAIR_T))-1 ),mask1,OutData%FAIR_T)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAIR_T)
  ENDIF
  IF ( ALLOCATED(OutData%FAST_RP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAST_RP,1),SIZE(OutData%FAST_RP,2)))
  mask2 = .TRUE.
    OutData%FAST_RP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAST_RP))-1 ),mask2,OutData%FAST_RP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAST_RP)
  ENDIF
  IF ( ALLOCATED(OutData%ANCH_T) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ANCH_T,1)))
  mask1 = .TRUE.
    OutData%ANCH_T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ANCH_T))-1 ),mask1,OutData%ANCH_T)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ANCH_T)
  ENDIF
  IF ( ALLOCATED(OutData%FAIR_ANG) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAIR_ANG,1),SIZE(OutData%FAIR_ANG,2)))
  mask2 = .TRUE.
    OutData%FAIR_ANG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAIR_ANG))-1 ),mask2,OutData%FAIR_ANG)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAIR_ANG)
  ENDIF
  IF ( ALLOCATED(OutData%ANCH_ANG) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ANCH_ANG,1),SIZE(OutData%ANCH_ANG,2)))
  mask2 = .TRUE.
    OutData%ANCH_ANG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ANCH_ANG))-1 ),mask2,OutData%ANCH_ANG)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ANCH_ANG)
  ENDIF
  ALLOCATE(mask2(SIZE(OutData%ESTIF,1),SIZE(OutData%ESTIF,2)))
  mask2 = .TRUE.
  OutData%ESTIF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ESTIF))-1 ),mask2,OutData%ESTIF)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%ESTIF)
  ALLOCATE(mask2(SIZE(OutData%EMASS,1),SIZE(OutData%EMASS,2)))
  mask2 = .TRUE.
  OutData%EMASS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%EMASS))-1 ),mask2,OutData%EMASS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%EMASS)
  ALLOCATE(mask1(SIZE(OutData%FORCE,1)))
  mask1 = .TRUE.
  OutData%FORCE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FORCE))-1 ),mask1,OutData%FORCE)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%FORCE)
  ALLOCATE(mask1(SIZE(OutData%RSDF,1)))
  mask1 = .TRUE.
  OutData%RSDF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RSDF))-1 ),mask1,OutData%RSDF)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RSDF)
  IF ( ALLOCATED(OutData%F_Lines) ) THEN
  ALLOCATE(mask2(SIZE(OutData%F_Lines,1),SIZE(OutData%F_Lines,2)))
  mask2 = .TRUE.
    OutData%F_Lines = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_Lines))-1 ),mask2,OutData%F_Lines)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F_Lines)
  ENDIF
  ALLOCATE(mask2(SIZE(OutData%U,1),SIZE(OutData%U,2)))
  mask2 = .TRUE.
  OutData%U = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%U))-1 ),mask2,OutData%U)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%U)
  ALLOCATE(mask2(SIZE(OutData%U0,1),SIZE(OutData%U0,2)))
  mask2 = .TRUE.
  OutData%U0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%U0))-1 ),mask2,OutData%U0)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%U0)
  ALLOCATE(mask2(SIZE(OutData%DU,1),SIZE(OutData%DU,2)))
  mask2 = .TRUE.
  OutData%DU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DU))-1 ),mask2,OutData%DU)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DU)
  ALLOCATE(mask2(SIZE(OutData%DDU,1),SIZE(OutData%DDU,2)))
  mask2 = .TRUE.
  OutData%DDU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DDU))-1 ),mask2,OutData%DDU)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DDU)
  ALLOCATE(mask1(SIZE(OutData%FORC0,1)))
  mask1 = .TRUE.
  OutData%FORC0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FORC0))-1 ),mask1,OutData%FORC0)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%FORC0)
  ALLOCATE(mask2(SIZE(OutData%EMAS0,1),SIZE(OutData%EMAS0,2)))
  mask2 = .TRUE.
  OutData%EMAS0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%EMAS0))-1 ),mask2,OutData%EMAS0)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%EMAS0)
  OutData%INCR = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%R,1)))
  mask1 = .TRUE.
  OutData%R = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%R))-1 ),mask1,OutData%R)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%R)
  ALLOCATE(mask1(SIZE(OutData%RP,1)))
  mask1 = .TRUE.
  OutData%RP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RP))-1 ),mask1,OutData%RP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RP)
  ALLOCATE(mask1(SIZE(OutData%FP,1)))
  mask1 = .TRUE.
  OutData%FP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FP))-1 ),mask1,OutData%FP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%FP)
  ALLOCATE(mask1(SIZE(OutData%SLIN,1)))
  mask1 = .TRUE.
  OutData%SLIN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SLIN))-1 ),mask1,OutData%SLIN)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SLIN)
  ALLOCATE(mask2(SIZE(OutData%STIFR,1),SIZE(OutData%STIFR,2)))
  mask2 = .TRUE.
  OutData%STIFR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%STIFR))-1 ),mask2,OutData%STIFR)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%STIFR)
  ALLOCATE(mask1(SIZE(OutData%RHSR,1)))
  mask1 = .TRUE.
  OutData%RHSR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RHSR))-1 ),mask1,OutData%RHSR)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RHSR)
  IF ( ALLOCATED(OutData%Line_Coordinate) ) THEN
  ALLOCATE(mask3(SIZE(OutData%Line_Coordinate,1),SIZE(OutData%Line_Coordinate,2),SIZE(OutData%Line_Coordinate,3)))
  mask3 = .TRUE.
    OutData%Line_Coordinate = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Line_Coordinate))-1 ),mask3,OutData%Line_Coordinate)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Line_Coordinate)
  ENDIF
  IF ( ALLOCATED(OutData%Line_Tangent) ) THEN
  ALLOCATE(mask3(SIZE(OutData%Line_Tangent,1),SIZE(OutData%Line_Tangent,2),SIZE(OutData%Line_Tangent,3)))
  mask3 = .TRUE.
    OutData%Line_Tangent = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Line_Tangent))-1 ),mask3,OutData%Line_Tangent)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Line_Tangent)
  ENDIF
  OutData%LastIndWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackOtherState

 SUBROUTINE FEAM_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(FEAM_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%DT = SrcParamData%DT
   DstParamData%GRAV = SrcParamData%GRAV
   DstParamData%Eps = SrcParamData%Eps
   DstParamData%Gravity = SrcParamData%Gravity
   DstParamData%WtrDens = SrcParamData%WtrDens
   DstParamData%MaxIter = SrcParamData%MaxIter
   DstParamData%NHBD = SrcParamData%NHBD
   DstParamData%NDIM = SrcParamData%NDIM
IF (ALLOCATED(SrcParamData%NEQ)) THEN
   i1_l = LBOUND(SrcParamData%NEQ,1)
   i1_u = UBOUND(SrcParamData%NEQ,1)
   IF (.NOT. ALLOCATED(DstParamData%NEQ)) THEN 
      ALLOCATE(DstParamData%NEQ(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%NEQ.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%NEQ = SrcParamData%NEQ
ENDIF
   DstParamData%NBAND = SrcParamData%NBAND
   DstParamData%NumLines = SrcParamData%NumLines
   DstParamData%NumElems = SrcParamData%NumElems
   DstParamData%NumNodes = SrcParamData%NumNodes
IF (ALLOCATED(SrcParamData%GSL)) THEN
   i1_l = LBOUND(SrcParamData%GSL,1)
   i1_u = UBOUND(SrcParamData%GSL,1)
   i2_l = LBOUND(SrcParamData%GSL,2)
   i2_u = UBOUND(SrcParamData%GSL,2)
   i3_l = LBOUND(SrcParamData%GSL,3)
   i3_u = UBOUND(SrcParamData%GSL,3)
   IF (.NOT. ALLOCATED(DstParamData%GSL)) THEN 
      ALLOCATE(DstParamData%GSL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%GSL.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%GSL = SrcParamData%GSL
ENDIF
IF (ALLOCATED(SrcParamData%GP)) THEN
   i1_l = LBOUND(SrcParamData%GP,1)
   i1_u = UBOUND(SrcParamData%GP,1)
   i2_l = LBOUND(SrcParamData%GP,2)
   i2_u = UBOUND(SrcParamData%GP,2)
   IF (.NOT. ALLOCATED(DstParamData%GP)) THEN 
      ALLOCATE(DstParamData%GP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%GP.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%GP = SrcParamData%GP
ENDIF
IF (ALLOCATED(SrcParamData%Elength)) THEN
   i1_l = LBOUND(SrcParamData%Elength,1)
   i1_u = UBOUND(SrcParamData%Elength,1)
   IF (.NOT. ALLOCATED(DstParamData%Elength)) THEN 
      ALLOCATE(DstParamData%Elength(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Elength.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%Elength = SrcParamData%Elength
ENDIF
IF (ALLOCATED(SrcParamData%BottmElev)) THEN
   i1_l = LBOUND(SrcParamData%BottmElev,1)
   i1_u = UBOUND(SrcParamData%BottmElev,1)
   IF (.NOT. ALLOCATED(DstParamData%BottmElev)) THEN 
      ALLOCATE(DstParamData%BottmElev(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BottmElev.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%BottmElev = SrcParamData%BottmElev
ENDIF
IF (ALLOCATED(SrcParamData%BottmStiff)) THEN
   i1_l = LBOUND(SrcParamData%BottmStiff,1)
   i1_u = UBOUND(SrcParamData%BottmStiff,1)
   IF (.NOT. ALLOCATED(DstParamData%BottmStiff)) THEN 
      ALLOCATE(DstParamData%BottmStiff(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BottmStiff.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%BottmStiff = SrcParamData%BottmStiff
ENDIF
IF (ALLOCATED(SrcParamData%LMassDen)) THEN
   i1_l = LBOUND(SrcParamData%LMassDen,1)
   i1_u = UBOUND(SrcParamData%LMassDen,1)
   IF (.NOT. ALLOCATED(DstParamData%LMassDen)) THEN 
      ALLOCATE(DstParamData%LMassDen(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LMassDen.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%LMassDen = SrcParamData%LMassDen
ENDIF
IF (ALLOCATED(SrcParamData%LDMassDen)) THEN
   i1_l = LBOUND(SrcParamData%LDMassDen,1)
   i1_u = UBOUND(SrcParamData%LDMassDen,1)
   IF (.NOT. ALLOCATED(DstParamData%LDMassDen)) THEN 
      ALLOCATE(DstParamData%LDMassDen(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LDMassDen.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%LDMassDen = SrcParamData%LDMassDen
ENDIF
IF (ALLOCATED(SrcParamData%LEAStiff)) THEN
   i1_l = LBOUND(SrcParamData%LEAStiff,1)
   i1_u = UBOUND(SrcParamData%LEAStiff,1)
   IF (.NOT. ALLOCATED(DstParamData%LEAStiff)) THEN 
      ALLOCATE(DstParamData%LEAStiff(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LEAStiff.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%LEAStiff = SrcParamData%LEAStiff
ENDIF
IF (ALLOCATED(SrcParamData%LineCI)) THEN
   i1_l = LBOUND(SrcParamData%LineCI,1)
   i1_u = UBOUND(SrcParamData%LineCI,1)
   IF (.NOT. ALLOCATED(DstParamData%LineCI)) THEN 
      ALLOCATE(DstParamData%LineCI(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LineCI.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%LineCI = SrcParamData%LineCI
ENDIF
IF (ALLOCATED(SrcParamData%LineCD)) THEN
   i1_l = LBOUND(SrcParamData%LineCD,1)
   i1_u = UBOUND(SrcParamData%LineCD,1)
   IF (.NOT. ALLOCATED(DstParamData%LineCD)) THEN 
      ALLOCATE(DstParamData%LineCD(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LineCD.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%LineCD = SrcParamData%LineCD
ENDIF
IF (ALLOCATED(SrcParamData%Bvp)) THEN
   i1_l = LBOUND(SrcParamData%Bvp,1)
   i1_u = UBOUND(SrcParamData%Bvp,1)
   i2_l = LBOUND(SrcParamData%Bvp,2)
   i2_u = UBOUND(SrcParamData%Bvp,2)
   IF (.NOT. ALLOCATED(DstParamData%Bvp)) THEN 
      ALLOCATE(DstParamData%Bvp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Bvp.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%Bvp = SrcParamData%Bvp
ENDIF
IF (ALLOCATED(SrcParamData%WaveAcc0)) THEN
   i1_l = LBOUND(SrcParamData%WaveAcc0,1)
   i1_u = UBOUND(SrcParamData%WaveAcc0,1)
   i2_l = LBOUND(SrcParamData%WaveAcc0,2)
   i2_u = UBOUND(SrcParamData%WaveAcc0,2)
   i3_l = LBOUND(SrcParamData%WaveAcc0,3)
   i3_u = UBOUND(SrcParamData%WaveAcc0,3)
   IF (.NOT. ALLOCATED(DstParamData%WaveAcc0)) THEN 
      ALLOCATE(DstParamData%WaveAcc0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveAcc0.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%WaveAcc0 = SrcParamData%WaveAcc0
ENDIF
IF (ALLOCATED(SrcParamData%WaveTime)) THEN
   i1_l = LBOUND(SrcParamData%WaveTime,1)
   i1_u = UBOUND(SrcParamData%WaveTime,1)
   IF (.NOT. ALLOCATED(DstParamData%WaveTime)) THEN 
      ALLOCATE(DstParamData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveTime.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%WaveTime = SrcParamData%WaveTime
ENDIF
IF (ALLOCATED(SrcParamData%WaveVel0)) THEN
   i1_l = LBOUND(SrcParamData%WaveVel0,1)
   i1_u = UBOUND(SrcParamData%WaveVel0,1)
   i2_l = LBOUND(SrcParamData%WaveVel0,2)
   i2_u = UBOUND(SrcParamData%WaveVel0,2)
   i3_l = LBOUND(SrcParamData%WaveVel0,3)
   i3_u = UBOUND(SrcParamData%WaveVel0,3)
   IF (.NOT. ALLOCATED(DstParamData%WaveVel0)) THEN 
      ALLOCATE(DstParamData%WaveVel0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveVel0.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%WaveVel0 = SrcParamData%WaveVel0
ENDIF
   DstParamData%NStepWave = SrcParamData%NStepWave
   DstParamData%SHAP = SrcParamData%SHAP
   DstParamData%SHAPS = SrcParamData%SHAPS
   DstParamData%GAUSSW = SrcParamData%GAUSSW
   DstParamData%NGAUSS = SrcParamData%NGAUSS
   DstParamData%SHAPT = SrcParamData%SHAPT
   DstParamData%SHAPTS = SrcParamData%SHAPTS
   DstParamData%NTRAP = SrcParamData%NTRAP
   DstParamData%SBEND = SrcParamData%SBEND
   DstParamData%STEN = SrcParamData%STEN
   DstParamData%RMASS = SrcParamData%RMASS
   DstParamData%RADDM = SrcParamData%RADDM
   DstParamData%PMPN = SrcParamData%PMPN
   DstParamData%AM = SrcParamData%AM
   DstParamData%PM = SrcParamData%PM
   DstParamData%IDOF = SrcParamData%IDOF
   DstParamData%JDOF = SrcParamData%JDOF
   DstParamData%PPA = SrcParamData%PPA
   DstParamData%PtfmRefzt = SrcParamData%PtfmRefzt
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%RootName = SrcParamData%RootName
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,'FEAM_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_CopyParam:OutParam(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstParamData%Delim = SrcParamData%Delim
 END SUBROUTINE FEAM_CopyParam

 SUBROUTINE FEAM_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(FEAM_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%NEQ)) THEN
   DEALLOCATE(ParamData%NEQ)
ENDIF
IF (ALLOCATED(ParamData%GSL)) THEN
   DEALLOCATE(ParamData%GSL)
ENDIF
IF (ALLOCATED(ParamData%GP)) THEN
   DEALLOCATE(ParamData%GP)
ENDIF
IF (ALLOCATED(ParamData%Elength)) THEN
   DEALLOCATE(ParamData%Elength)
ENDIF
IF (ALLOCATED(ParamData%BottmElev)) THEN
   DEALLOCATE(ParamData%BottmElev)
ENDIF
IF (ALLOCATED(ParamData%BottmStiff)) THEN
   DEALLOCATE(ParamData%BottmStiff)
ENDIF
IF (ALLOCATED(ParamData%LMassDen)) THEN
   DEALLOCATE(ParamData%LMassDen)
ENDIF
IF (ALLOCATED(ParamData%LDMassDen)) THEN
   DEALLOCATE(ParamData%LDMassDen)
ENDIF
IF (ALLOCATED(ParamData%LEAStiff)) THEN
   DEALLOCATE(ParamData%LEAStiff)
ENDIF
IF (ALLOCATED(ParamData%LineCI)) THEN
   DEALLOCATE(ParamData%LineCI)
ENDIF
IF (ALLOCATED(ParamData%LineCD)) THEN
   DEALLOCATE(ParamData%LineCD)
ENDIF
IF (ALLOCATED(ParamData%Bvp)) THEN
   DEALLOCATE(ParamData%Bvp)
ENDIF
IF (ALLOCATED(ParamData%WaveAcc0)) THEN
   DEALLOCATE(ParamData%WaveAcc0)
ENDIF
IF (ALLOCATED(ParamData%WaveTime)) THEN
   DEALLOCATE(ParamData%WaveTime)
ENDIF
IF (ALLOCATED(ParamData%WaveVel0)) THEN
   DEALLOCATE(ParamData%WaveVel0)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE FEAM_DestroyParam

 SUBROUTINE FEAM_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz    = Re_BufSz    + SIZE( InData%GRAV )  ! GRAV 
  Re_BufSz   = Re_BufSz   + 1  ! Eps
  Re_BufSz   = Re_BufSz   + 1  ! Gravity
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  Int_BufSz  = Int_BufSz  + 1  ! MaxIter
  Int_BufSz  = Int_BufSz  + 1  ! NHBD
  Int_BufSz  = Int_BufSz  + 1  ! NDIM
  IF ( ALLOCATED(InData%NEQ) )   Int_BufSz   = Int_BufSz   + SIZE( InData%NEQ )  ! NEQ 
  Int_BufSz  = Int_BufSz  + 1  ! NBAND
  Int_BufSz  = Int_BufSz  + 1  ! NumLines
  Int_BufSz  = Int_BufSz  + 1  ! NumElems
  Int_BufSz  = Int_BufSz  + 1  ! NumNodes
  IF ( ALLOCATED(InData%GSL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GSL )  ! GSL 
  IF ( ALLOCATED(InData%GP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GP )  ! GP 
  IF ( ALLOCATED(InData%Elength) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Elength )  ! Elength 
  IF ( ALLOCATED(InData%BottmElev) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BottmElev )  ! BottmElev 
  IF ( ALLOCATED(InData%BottmStiff) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BottmStiff )  ! BottmStiff 
  IF ( ALLOCATED(InData%LMassDen) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LMassDen )  ! LMassDen 
  IF ( ALLOCATED(InData%LDMassDen) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LDMassDen )  ! LDMassDen 
  IF ( ALLOCATED(InData%LEAStiff) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LEAStiff )  ! LEAStiff 
  IF ( ALLOCATED(InData%LineCI) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LineCI )  ! LineCI 
  IF ( ALLOCATED(InData%LineCD) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LineCD )  ! LineCD 
  IF ( ALLOCATED(InData%Bvp) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Bvp )  ! Bvp 
  IF ( ALLOCATED(InData%WaveAcc0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveAcc0 )  ! WaveAcc0 
  IF ( ALLOCATED(InData%WaveTime) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveTime )  ! WaveTime 
  IF ( ALLOCATED(InData%WaveVel0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveVel0 )  ! WaveVel0 
  Int_BufSz  = Int_BufSz  + 1  ! NStepWave
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAP )  ! SHAP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAPS )  ! SHAPS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GAUSSW )  ! GAUSSW 
  Int_BufSz  = Int_BufSz  + 1  ! NGAUSS
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAPT )  ! SHAPT 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAPTS )  ! SHAPTS 
  Int_BufSz  = Int_BufSz  + 1  ! NTRAP
  Re_BufSz    = Re_BufSz    + SIZE( InData%SBEND )  ! SBEND 
  Re_BufSz    = Re_BufSz    + SIZE( InData%STEN )  ! STEN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RMASS )  ! RMASS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RADDM )  ! RADDM 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PMPN )  ! PMPN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%AM )  ! AM 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PM )  ! PM 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDOF )  ! IDOF 
  Int_BufSz   = Int_BufSz   + SIZE( InData%JDOF )  ! JDOF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PPA )  ! PPA 
  Re_BufSz   = Re_BufSz   + 1  ! PtfmRefzt
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
!  missing buffer for RootName
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
!  missing buffer for Delim
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GRAV))-1 ) =  PACK(InData%GRAV ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%GRAV)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Eps )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MaxIter )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NHBD )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NDIM )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NEQ) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NEQ))-1 ) = PACK(InData%NEQ ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NEQ)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NBAND )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumLines )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumElems )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumNodes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%GSL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GSL))-1 ) =  PACK(InData%GSL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GSL)
  ENDIF
  IF ( ALLOCATED(InData%GP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GP))-1 ) =  PACK(InData%GP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GP)
  ENDIF
  IF ( ALLOCATED(InData%Elength) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Elength))-1 ) =  PACK(InData%Elength ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Elength)
  ENDIF
  IF ( ALLOCATED(InData%BottmElev) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmElev))-1 ) =  PACK(InData%BottmElev ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmElev)
  ENDIF
  IF ( ALLOCATED(InData%BottmStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmStiff))-1 ) =  PACK(InData%BottmStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(InData%LMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LMassDen))-1 ) =  PACK(InData%LMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LDMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDMassDen))-1 ) =  PACK(InData%LDMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LEAStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LEAStiff))-1 ) =  PACK(InData%LEAStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(InData%LineCI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LineCI))-1 ) =  PACK(InData%LineCI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LineCI)
  ENDIF
  IF ( ALLOCATED(InData%LineCD) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LineCD))-1 ) =  PACK(InData%LineCD ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LineCD)
  ENDIF
  IF ( ALLOCATED(InData%Bvp) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Bvp))-1 ) =  PACK(InData%Bvp ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Bvp)
  ENDIF
  IF ( ALLOCATED(InData%WaveAcc0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveAcc0))-1 ) =  PACK(InData%WaveAcc0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveAcc0)
  ENDIF
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveTime))-1 ) =  PACK(InData%WaveTime ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveTime)
  ENDIF
  IF ( ALLOCATED(InData%WaveVel0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveVel0))-1 ) =  PACK(InData%WaveVel0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveVel0)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NStepWave )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAP))-1 ) =  PACK(InData%SHAP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAPS))-1 ) =  PACK(InData%SHAPS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAPS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GAUSSW))-1 ) =  PACK(InData%GAUSSW ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%GAUSSW)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NGAUSS )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAPT))-1 ) =  PACK(InData%SHAPT ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAPT)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAPTS))-1 ) =  PACK(InData%SHAPTS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAPTS)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NTRAP )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SBEND))-1 ) =  PACK(InData%SBEND ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SBEND)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%STEN))-1 ) =  PACK(InData%STEN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%STEN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RMASS))-1 ) =  PACK(InData%RMASS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RMASS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RADDM))-1 ) =  PACK(InData%RADDM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RADDM)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PMPN))-1 ) =  PACK(InData%PMPN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PMPN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AM))-1 ) =  PACK(InData%AM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%AM)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PM))-1 ) =  PACK(InData%PM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PM)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDOF))-1 ) = PACK(InData%IDOF ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%IDOF)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%JDOF))-1 ) = PACK(InData%JDOF ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%JDOF)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PPA))-1 ) =  PACK(InData%PPA ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PPA)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtfmRefzt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
 END SUBROUTINE FEAM_PackParam

 SUBROUTINE FEAM_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%GRAV,1)))
  mask1 = .TRUE.
  OutData%GRAV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GRAV))-1 ),mask1,OutData%GRAV)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%GRAV)
  OutData%Eps = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MaxIter = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NHBD = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NDIM = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%NEQ) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NEQ,1)))
  mask1 = .TRUE.
    OutData%NEQ = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NEQ))-1 ),mask1,OutData%NEQ)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NEQ)
  ENDIF
  OutData%NBAND = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumLines = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumElems = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumNodes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%GSL) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GSL,1),SIZE(OutData%GSL,2),SIZE(OutData%GSL,3)))
  mask3 = .TRUE.
    OutData%GSL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GSL))-1 ),mask3,OutData%GSL)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GSL)
  ENDIF
  IF ( ALLOCATED(OutData%GP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GP,1),SIZE(OutData%GP,2)))
  mask2 = .TRUE.
    OutData%GP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GP))-1 ),mask2,OutData%GP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GP)
  ENDIF
  IF ( ALLOCATED(OutData%Elength) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Elength,1)))
  mask1 = .TRUE.
    OutData%Elength = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Elength))-1 ),mask1,OutData%Elength)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Elength)
  ENDIF
  IF ( ALLOCATED(OutData%BottmElev) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmElev,1)))
  mask1 = .TRUE.
    OutData%BottmElev = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmElev))-1 ),mask1,OutData%BottmElev)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmElev)
  ENDIF
  IF ( ALLOCATED(OutData%BottmStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmStiff,1)))
  mask1 = .TRUE.
    OutData%BottmStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmStiff))-1 ),mask1,OutData%BottmStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LMassDen,1)))
  mask1 = .TRUE.
    OutData%LMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LMassDen))-1 ),mask1,OutData%LMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LDMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDMassDen,1)))
  mask1 = .TRUE.
    OutData%LDMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDMassDen))-1 ),mask1,OutData%LDMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LEAStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LEAStiff,1)))
  mask1 = .TRUE.
    OutData%LEAStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LEAStiff))-1 ),mask1,OutData%LEAStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LineCI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineCI,1)))
  mask1 = .TRUE.
    OutData%LineCI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LineCI))-1 ),mask1,OutData%LineCI)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LineCI)
  ENDIF
  IF ( ALLOCATED(OutData%LineCD) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineCD,1)))
  mask1 = .TRUE.
    OutData%LineCD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LineCD))-1 ),mask1,OutData%LineCD)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LineCD)
  ENDIF
  IF ( ALLOCATED(OutData%Bvp) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Bvp,1),SIZE(OutData%Bvp,2)))
  mask2 = .TRUE.
    OutData%Bvp = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Bvp))-1 ),mask2,OutData%Bvp)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Bvp)
  ENDIF
  IF ( ALLOCATED(OutData%WaveAcc0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveAcc0,1),SIZE(OutData%WaveAcc0,2),SIZE(OutData%WaveAcc0,3)))
  mask3 = .TRUE.
    OutData%WaveAcc0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveAcc0))-1 ),mask3,OutData%WaveAcc0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveAcc0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveTime) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveTime,1)))
  mask1 = .TRUE.
    OutData%WaveTime = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveTime))-1 ),mask1,OutData%WaveTime)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveTime)
  ENDIF
  IF ( ALLOCATED(OutData%WaveVel0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveVel0,1),SIZE(OutData%WaveVel0,2),SIZE(OutData%WaveVel0,3)))
  mask3 = .TRUE.
    OutData%WaveVel0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveVel0))-1 ),mask3,OutData%WaveVel0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveVel0)
  ENDIF
  OutData%NStepWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%SHAP,1),SIZE(OutData%SHAP,2)))
  mask2 = .TRUE.
  OutData%SHAP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAP))-1 ),mask2,OutData%SHAP)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAP)
  ALLOCATE(mask2(SIZE(OutData%SHAPS,1),SIZE(OutData%SHAPS,2)))
  mask2 = .TRUE.
  OutData%SHAPS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAPS))-1 ),mask2,OutData%SHAPS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAPS)
  ALLOCATE(mask1(SIZE(OutData%GAUSSW,1)))
  mask1 = .TRUE.
  OutData%GAUSSW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GAUSSW))-1 ),mask1,OutData%GAUSSW)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%GAUSSW)
  OutData%NGAUSS = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%SHAPT,1),SIZE(OutData%SHAPT,2)))
  mask2 = .TRUE.
  OutData%SHAPT = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAPT))-1 ),mask2,OutData%SHAPT)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAPT)
  ALLOCATE(mask2(SIZE(OutData%SHAPTS,1),SIZE(OutData%SHAPTS,2)))
  mask2 = .TRUE.
  OutData%SHAPTS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAPTS))-1 ),mask2,OutData%SHAPTS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAPTS)
  OutData%NTRAP = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%SBEND,1),SIZE(OutData%SBEND,2)))
  mask2 = .TRUE.
  OutData%SBEND = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SBEND))-1 ),mask2,OutData%SBEND)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SBEND)
  ALLOCATE(mask3(SIZE(OutData%STEN,1),SIZE(OutData%STEN,2),SIZE(OutData%STEN,3)))
  mask3 = .TRUE.
  OutData%STEN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%STEN))-1 ),mask3,OutData%STEN)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%STEN)
  ALLOCATE(mask2(SIZE(OutData%RMASS,1),SIZE(OutData%RMASS,2)))
  mask2 = .TRUE.
  OutData%RMASS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RMASS))-1 ),mask2,OutData%RMASS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RMASS)
  ALLOCATE(mask4(SIZE(OutData%RADDM,1),SIZE(OutData%RADDM,2),SIZE(OutData%RADDM,3),SIZE(OutData%RADDM,4)))
  mask4 = .TRUE.
  OutData%RADDM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RADDM))-1 ),mask4,OutData%RADDM)
  DEALLOCATE(mask4)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RADDM)
  ALLOCATE(mask2(SIZE(OutData%PMPN,1),SIZE(OutData%PMPN,2)))
  mask2 = .TRUE.
  OutData%PMPN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PMPN))-1 ),mask2,OutData%PMPN)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PMPN)
  ALLOCATE(mask1(SIZE(OutData%AM,1)))
  mask1 = .TRUE.
  OutData%AM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AM))-1 ),mask1,OutData%AM)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%AM)
  ALLOCATE(mask1(SIZE(OutData%PM,1)))
  mask1 = .TRUE.
  OutData%PM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PM))-1 ),mask1,OutData%PM)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PM)
  ALLOCATE(mask2(SIZE(OutData%IDOF,1),SIZE(OutData%IDOF,2)))
  mask2 = .TRUE.
  OutData%IDOF = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDOF))-1 ),mask2,OutData%IDOF)
  DEALLOCATE(mask2)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%IDOF)
  ALLOCATE(mask1(SIZE(OutData%JDOF,1)))
  mask1 = .TRUE.
  OutData%JDOF = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%JDOF))-1 ),mask1,OutData%JDOF)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%JDOF)
  ALLOCATE(mask3(SIZE(OutData%PPA,1),SIZE(OutData%PPA,2),SIZE(OutData%PPA,3)))
  mask3 = .TRUE.
  OutData%PPA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PPA))-1 ),mask3,OutData%PPA)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PPA)
  OutData%PtfmRefzt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call NWTC_Library_Packoutparmtype to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL NWTC_Library_UnPackoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackParam

 SUBROUTINE FEAM_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(FEAM_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInputData%HydroForceLineMesh, DstInputData%HydroForceLineMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_CopyInput:HydroForceLineMesh')
         IF (ErrStat>=AbortErrLev) RETURN
     CALL MeshCopy( SrcInputData%PtFairleadDisplacement, DstInputData%PtFairleadDisplacement, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_CopyInput:PtFairleadDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FEAM_CopyInput

 SUBROUTINE FEAM_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(FEAM_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%HydroForceLineMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%PtFairleadDisplacement, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_DestroyInput

 SUBROUTINE FEAM_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_HydroForceLineMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_HydroForceLineMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_HydroForceLineMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! HydroForceLineMesh 
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_HydroForceLineMesh_Buf  ) ! HydroForceLineMesh
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_HydroForceLineMesh_Buf  ) ! HydroForceLineMesh
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_HydroForceLineMesh_Buf ) ! HydroForceLineMesh
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf))  DEALLOCATE(Re_HydroForceLineMesh_Buf)
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf))  DEALLOCATE(Db_HydroForceLineMesh_Buf)
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf)) DEALLOCATE(Int_HydroForceLineMesh_Buf)
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadDisplacement_Buf ) ! PtFairleadDisplacement
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf))  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf))  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! HydroForceLineMesh 
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_HydroForceLineMesh_Buf)-1 ) = Re_HydroForceLineMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_HydroForceLineMesh_Buf)-1 ) = Db_HydroForceLineMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_HydroForceLineMesh_Buf)-1 ) = Int_HydroForceLineMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_HydroForceLineMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_HydroForceLineMesh_Buf) )  DEALLOCATE(Re_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Db_HydroForceLineMesh_Buf) )  DEALLOCATE(Db_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Int_HydroForceLineMesh_Buf) ) DEALLOCATE(Int_HydroForceLineMesh_Buf)
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 ) = Re_PtFairleadDisplacement_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 ) = Db_PtFairleadDisplacement_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 ) = Int_PtFairleadDisplacement_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
 END SUBROUTINE FEAM_PackInput

 SUBROUTINE FEAM_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_HydroForceLineMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_HydroForceLineMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_HydroForceLineMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! HydroForceLineMesh 
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf)) THEN
    Re_HydroForceLineMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_HydroForceLineMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf)) THEN
    Db_HydroForceLineMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_HydroForceLineMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf)) THEN
    Int_HydroForceLineMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_HydroForceLineMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_HydroForceLineMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg ) ! HydroForceLineMesh 
  IF( ALLOCATED(Re_HydroForceLineMesh_Buf) )  DEALLOCATE(Re_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Db_HydroForceLineMesh_Buf) )  DEALLOCATE(Db_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Int_HydroForceLineMesh_Buf) ) DEALLOCATE(Int_HydroForceLineMesh_Buf)
  CALL MeshPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    Re_PtFairleadDisplacement_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    Db_PtFairleadDisplacement_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    Int_PtFairleadDisplacement_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg ) ! PtFairleadDisplacement 
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackInput

 SUBROUTINE FEAM_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(FEAM_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'FEAM_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
     CALL MeshCopy( SrcOutputData%PtFairleadLoad, DstOutputData%PtFairleadLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_CopyOutput:PtFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
     CALL MeshCopy( SrcOutputData%LineMeshPosition, DstOutputData%LineMeshPosition, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_CopyOutput:LineMeshPosition')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FEAM_CopyOutput

 SUBROUTINE FEAM_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(FEAM_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
  CALL MeshDestroy( OutputData%PtFairleadLoad, ErrStat, ErrMsg )
  CALL MeshDestroy( OutputData%LineMeshPosition, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_DestroyOutput

 SUBROUTINE FEAM_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LineMeshPosition_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LineMeshPosition_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LineMeshPosition_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Int_PtFairleadLoad_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadLoad_Buf ) ! PtFairleadLoad
  IF(ALLOCATED(Re_PtFairleadLoad_Buf))  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF(ALLOCATED(Db_PtFairleadLoad_Buf))  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) DEALLOCATE(Int_PtFairleadLoad_Buf)
  CALL MeshPack( InData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg, .TRUE. ) ! LineMeshPosition 
  IF(ALLOCATED(Re_LineMeshPosition_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LineMeshPosition_Buf  ) ! LineMeshPosition
  IF(ALLOCATED(Db_LineMeshPosition_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LineMeshPosition_Buf  ) ! LineMeshPosition
  IF(ALLOCATED(Int_LineMeshPosition_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LineMeshPosition_Buf ) ! LineMeshPosition
  IF(ALLOCATED(Re_LineMeshPosition_Buf))  DEALLOCATE(Re_LineMeshPosition_Buf)
  IF(ALLOCATED(Db_LineMeshPosition_Buf))  DEALLOCATE(Db_LineMeshPosition_Buf)
  IF(ALLOCATED(Int_LineMeshPosition_Buf)) DEALLOCATE(Int_LineMeshPosition_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 ) = Re_PtFairleadLoad_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 ) = Db_PtFairleadLoad_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 ) = Int_PtFairleadLoad_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  CALL MeshPack( InData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg, OnlySize ) ! LineMeshPosition 
  IF(ALLOCATED(Re_LineMeshPosition_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineMeshPosition_Buf)-1 ) = Re_LineMeshPosition_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineMeshPosition_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineMeshPosition_Buf)-1 ) = Db_LineMeshPosition_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineMeshPosition_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineMeshPosition_Buf)-1 ) = Int_LineMeshPosition_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LineMeshPosition_Buf)
  ENDIF
  IF( ALLOCATED(Re_LineMeshPosition_Buf) )  DEALLOCATE(Re_LineMeshPosition_Buf)
  IF( ALLOCATED(Db_LineMeshPosition_Buf) )  DEALLOCATE(Db_LineMeshPosition_Buf)
  IF( ALLOCATED(Int_LineMeshPosition_Buf) ) DEALLOCATE(Int_LineMeshPosition_Buf)
 END SUBROUTINE FEAM_PackOutput

 SUBROUTINE FEAM_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LineMeshPosition_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LineMeshPosition_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LineMeshPosition_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    Re_PtFairleadLoad_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    Db_PtFairleadLoad_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    Int_PtFairleadLoad_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg ) ! PtFairleadLoad 
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  CALL MeshPack( OutData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg , .TRUE. ) ! LineMeshPosition 
  IF(ALLOCATED(Re_LineMeshPosition_Buf)) THEN
    Re_LineMeshPosition_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineMeshPosition_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineMeshPosition_Buf)) THEN
    Db_LineMeshPosition_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineMeshPosition_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineMeshPosition_Buf)) THEN
    Int_LineMeshPosition_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineMeshPosition_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LineMeshPosition_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg ) ! LineMeshPosition 
  IF( ALLOCATED(Re_LineMeshPosition_Buf) )  DEALLOCATE(Re_LineMeshPosition_Buf)
  IF( ALLOCATED(Db_LineMeshPosition_Buf) )  DEALLOCATE(Db_LineMeshPosition_Buf)
  IF( ALLOCATED(Int_LineMeshPosition_Buf) ) DEALLOCATE(Int_LineMeshPosition_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnPackOutput


 SUBROUTINE FEAM_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FEAM_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(FEAM_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in FEAM_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%HydroForceLineMesh, u_out%HydroForceLineMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Input_ExtrapInterp:%HydroForceLineMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshCopy(u(1)%PtFairleadDisplacement, u_out%PtFairleadDisplacement, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Input_ExtrapInterp:%PtFairleadDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%HydroForceLineMesh, u(2)%HydroForceLineMesh, tin, u_out%HydroForceLineMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Input_ExtrapInterp:%HydroForceLineMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp1(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Input_ExtrapInterp:%PtFairleadDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%HydroForceLineMesh, u(2)%HydroForceLineMesh, u(3)%HydroForceLineMesh, tin, u_out%HydroForceLineMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Input_ExtrapInterp:%HydroForceLineMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp2(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, u(3)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Input_ExtrapInterp:%PtFairleadDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in FEAM_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE FEAM_Input_ExtrapInterp


 SUBROUTINE FEAM_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FEAM_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(FEAM_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in FEAM_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
  CALL MeshCopy(u(1)%PtFairleadLoad, u_out%PtFairleadLoad, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Output_ExtrapInterp:%PtFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshCopy(u(1)%LineMeshPosition, u_out%LineMeshPosition, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Output_ExtrapInterp:%LineMeshPosition')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp1(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Output_ExtrapInterp:%PtFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp1(u(1)%LineMeshPosition, u(2)%LineMeshPosition, tin, u_out%LineMeshPosition, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Output_ExtrapInterp:%LineMeshPosition')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  CALL MeshExtrapInterp2(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, u(3)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Output_ExtrapInterp:%PtFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp2(u(1)%LineMeshPosition, u(2)%LineMeshPosition, u(3)%LineMeshPosition, tin, u_out%LineMeshPosition, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'FEAM_Output_ExtrapInterp:%LineMeshPosition')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in FEAM_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE FEAM_Output_ExtrapInterp

END MODULE FEAMooring_Types
!ENDOFREGISTRYGENERATEDFILE
