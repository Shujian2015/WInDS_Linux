!STARTOFREGISTRYGENERATEDFILE './WAMIT_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 14-Jan-2015)
!*********************************************************************************************************************************
! WAMIT_Types
!.................................................................................................................................
! This file is part of WAMIT.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE WAMIT_Types
! This module contains all of the user-defined types needed in WAMIT. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE Conv_Radiation_Types
USE SS_Radiation_Types
USE Waves_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MaxWAMITOutputs = 18      !  [-]
! =========  WAMIT_InitInputType  =======
  TYPE, PUBLIC :: WAMIT_InitInputType
    REAL(ReKi)  :: PtfmVol0      !  [-]
    LOGICAL  :: HasWAMIT      ! .TRUE. if using WAMIT model, .FALSE. otherwise [-]
    REAL(ReKi)  :: WAMITULEN      !  [-]
    REAL(ReKi)  :: PtfmCOBxt      !  [-]
    REAL(ReKi)  :: PtfmCOByt      !  [-]
    INTEGER(IntKi)  :: RdtnMod      !  [-]
    REAL(DbKi)  :: RdtnTMax      !  [-]
    CHARACTER(1024)  :: WAMITFile      !  [-]
    TYPE(Conv_Rdtn_InitInputType)  :: Conv_Rdtn      !  [-]
    TYPE(SS_Rad_InitInputType)  :: SS_Rdtn      !  [-]
    REAL(ReKi)  :: Rhoxg      !  [-]
    INTEGER(IntKi)  :: NStepWave      !  [-]
    INTEGER(IntKi)  :: NStepWave2      !  [-]
    REAL(ReKi)  :: WaveDOmega      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveElevC0      ! Discrete Fourier transform of the instantaneous elevation of incident waves at the platform reference point.  First column is real part, second column is imaginary part [(meters)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !  [-]
    INTEGER(IntKi)  :: WaveMod      !  [-]
    REAL(ReKi)  :: WtrDens      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveDirArr      ! Array of wave directions (one per frequency) from the Waves module [-]
    REAL(ReKi)  :: WaveDirMin      ! Minimum wave direction from Waves module [-]
    REAL(ReKi)  :: WaveDirMax      ! Maximum wave direction from Waves module [-]
    CHARACTER(10) , DIMENSION(1:18)  :: OutList      ! This should really be dimensioned with MaxOutPts [-]
    LOGICAL  :: OutAll      !  [-]
    INTEGER(IntKi)  :: NumOuts      !  [-]
  END TYPE WAMIT_InitInputType
! =======================
! =========  WAMIT_InitOutputType  =======
  TYPE, PUBLIC :: WAMIT_InitOutputType
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !  [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !  [-]
  END TYPE WAMIT_InitOutputType
! =======================
! =========  WAMIT_ContinuousStateType  =======
  TYPE, PUBLIC :: WAMIT_ContinuousStateType
    TYPE(SS_Rad_ContinuousStateType)  :: SS_Rdtn      ! continuous states from the State Space radiation module [-]
  END TYPE WAMIT_ContinuousStateType
! =======================
! =========  WAMIT_DiscreteStateType  =======
  TYPE, PUBLIC :: WAMIT_DiscreteStateType
    TYPE(Conv_Rdtn_DiscreteStateType)  :: Conv_Rdtn      ! discrete states from the convolution radiation module [-]
  END TYPE WAMIT_DiscreteStateType
! =======================
! =========  WAMIT_ConstraintStateType  =======
  TYPE, PUBLIC :: WAMIT_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      ! Remove this variable if you have constraint states [-]
  END TYPE WAMIT_ConstraintStateType
! =======================
! =========  WAMIT_OtherStateType  =======
  TYPE, PUBLIC :: WAMIT_OtherStateType
    INTEGER(IntKi)  :: LastIndWave      !  [-]
    TYPE(SS_Rad_OtherStateType)  :: SS_Rdtn      !  [-]
    TYPE(Conv_Rdtn_OtherStateType)  :: Conv_Rdtn      !  [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_HS      !  [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_Waves1      !  [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_Rdtn      !  [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_PtfmAdd      !  [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_PtfmAM      !  [-]
  END TYPE WAMIT_OtherStateType
! =======================
! =========  WAMIT_ParameterType  =======
  TYPE, PUBLIC :: WAMIT_ParameterType
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: HdroAdMsI      !  [(sec)]
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: HdroSttc      !  [-]
    REAL(ReKi)  :: PtfmVol0      !  [-]
    REAL(ReKi)  :: PtfmCOBxt      !  [-]
    REAL(ReKi)  :: PtfmCOByt      !  [-]
    INTEGER(IntKi)  :: RdtnMod      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveExctn      !  [-]
    REAL(ReKi)  :: RhoXg      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !  [-]
    INTEGER(IntKi)  :: NStepWave      !  [-]
    TYPE(Conv_Rdtn_ParameterType)  :: Conv_Rdtn      !  [-]
    TYPE(SS_Rad_ParameterType)  :: SS_Rdtn      !  [-]
    REAL(DbKi)  :: DT      !  [-]
    LOGICAL  :: PtfmSgF      !  [-]
    LOGICAL  :: PtfmSwF      !  [-]
    LOGICAL  :: PtfmHvF      !  [-]
    LOGICAL  :: PtfmRF      !  [-]
    LOGICAL  :: PtfmPF      !  [-]
    LOGICAL  :: PtfmYF      !  [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !  [-]
    INTEGER(IntKi)  :: NumOuts      !  [-]
    INTEGER(IntKi)  :: NumOutAll      !  [-]
    CHARACTER(20)  :: OutFmt      !  [-]
    CHARACTER(20)  :: OutSFmt      !  [-]
    CHARACTER(10)  :: Delim      !  [-]
    INTEGER(IntKi)  :: UnOutFile      !  [-]
  END TYPE WAMIT_ParameterType
! =======================
! =========  WAMIT_InputType  =======
  TYPE, PUBLIC :: WAMIT_InputType
    TYPE(MeshType)  :: Mesh      ! Displacements at the WAMIT reference point in the inertial frame [-]
  END TYPE WAMIT_InputType
! =======================
! =========  WAMIT_OutputType  =======
  TYPE, PUBLIC :: WAMIT_OutputType
    TYPE(MeshType)  :: Mesh      ! Loads at the WAMIT reference point in the inertial frame [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !  [-]
  END TYPE WAMIT_OutputType
! =======================
CONTAINS
 SUBROUTINE WAMIT_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(WAMIT_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%PtfmVol0 = SrcInitInputData%PtfmVol0
   DstInitInputData%HasWAMIT = SrcInitInputData%HasWAMIT
   DstInitInputData%WAMITULEN = SrcInitInputData%WAMITULEN
   DstInitInputData%PtfmCOBxt = SrcInitInputData%PtfmCOBxt
   DstInitInputData%PtfmCOByt = SrcInitInputData%PtfmCOByt
   DstInitInputData%RdtnMod = SrcInitInputData%RdtnMod
   DstInitInputData%RdtnTMax = SrcInitInputData%RdtnTMax
   DstInitInputData%WAMITFile = SrcInitInputData%WAMITFile
      CALL Conv_Rdtn_CopyInitInput( SrcInitInputData%Conv_Rdtn, DstInitInputData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyInitInput:Conv_Rdtn')
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Rad_CopyInitInput( SrcInitInputData%SS_Rdtn, DstInitInputData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyInitInput:SS_Rdtn')
         IF (ErrStat>=AbortErrLev) RETURN
   DstInitInputData%Rhoxg = SrcInitInputData%Rhoxg
   DstInitInputData%NStepWave = SrcInitInputData%NStepWave
   DstInitInputData%NStepWave2 = SrcInitInputData%NStepWave2
   DstInitInputData%WaveDOmega = SrcInitInputData%WaveDOmega
IF (ALLOCATED(SrcInitInputData%WaveElevC0)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveElevC0,1)
   i1_u = UBOUND(SrcInitInputData%WaveElevC0,1)
   i2_l = LBOUND(SrcInitInputData%WaveElevC0,2)
   i2_u = UBOUND(SrcInitInputData%WaveElevC0,2)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveElevC0)) THEN 
      ALLOCATE(DstInitInputData%WaveElevC0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveElevC0.', ErrStat, ErrMsg,'WAMIT_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveElevC0 = SrcInitInputData%WaveElevC0
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveTime)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveTime,1)
   i1_u = UBOUND(SrcInitInputData%WaveTime,1)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveTime)) THEN 
      ALLOCATE(DstInitInputData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveTime.', ErrStat, ErrMsg,'WAMIT_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveTime = SrcInitInputData%WaveTime
ENDIF
   DstInitInputData%WaveMod = SrcInitInputData%WaveMod
   DstInitInputData%WtrDens = SrcInitInputData%WtrDens
IF (ALLOCATED(SrcInitInputData%WaveDirArr)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveDirArr,1)
   i1_u = UBOUND(SrcInitInputData%WaveDirArr,1)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveDirArr)) THEN 
      ALLOCATE(DstInitInputData%WaveDirArr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveDirArr.', ErrStat, ErrMsg,'WAMIT_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveDirArr = SrcInitInputData%WaveDirArr
ENDIF
   DstInitInputData%WaveDirMin = SrcInitInputData%WaveDirMin
   DstInitInputData%WaveDirMax = SrcInitInputData%WaveDirMax
   DstInitInputData%OutList = SrcInitInputData%OutList
   DstInitInputData%OutAll = SrcInitInputData%OutAll
   DstInitInputData%NumOuts = SrcInitInputData%NumOuts
 END SUBROUTINE WAMIT_CopyInitInput

 SUBROUTINE WAMIT_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(WAMIT_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL Conv_Rdtn_DestroyInitInput( InitInputData%Conv_Rdtn, ErrStat, ErrMsg )
  CALL SS_Rad_DestroyInitInput( InitInputData%SS_Rdtn, ErrStat, ErrMsg )
IF (ALLOCATED(InitInputData%WaveElevC0)) THEN
   DEALLOCATE(InitInputData%WaveElevC0)
ENDIF
IF (ALLOCATED(InitInputData%WaveTime)) THEN
   DEALLOCATE(InitInputData%WaveTime)
ENDIF
IF (ALLOCATED(InitInputData%WaveDirArr)) THEN
   DEALLOCATE(InitInputData%WaveDirArr)
ENDIF
 END SUBROUTINE WAMIT_DestroyInitInput

 SUBROUTINE WAMIT_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WAMIT_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Conv_Rdtn_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Conv_Rdtn_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Conv_Rdtn_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_SS_Rdtn_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_SS_Rdtn_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_SS_Rdtn_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! PtfmVol0
  Int_BufSz  = Int_BufSz  + 1  ! HasWAMIT
  Re_BufSz   = Re_BufSz   + 1  ! WAMITULEN
  Re_BufSz   = Re_BufSz   + 1  ! PtfmCOBxt
  Re_BufSz   = Re_BufSz   + 1  ! PtfmCOByt
  Int_BufSz  = Int_BufSz  + 1  ! RdtnMod
  Db_BufSz   = Db_BufSz   + 1  ! RdtnTMax
!  missing buffer for WAMITFile
  CALL Conv_Rdtn_PackInitInput( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, InData%Conv_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Conv_Rdtn_Buf  ) ! Conv_Rdtn
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Conv_Rdtn_Buf  ) ! Conv_Rdtn
  IF(ALLOCATED(Int_Conv_Rdtn_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Conv_Rdtn_Buf ) ! Conv_Rdtn
  IF(ALLOCATED(Re_Conv_Rdtn_Buf))  DEALLOCATE(Re_Conv_Rdtn_Buf)
  IF(ALLOCATED(Db_Conv_Rdtn_Buf))  DEALLOCATE(Db_Conv_Rdtn_Buf)
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) DEALLOCATE(Int_Conv_Rdtn_Buf)
  CALL SS_Rad_PackInitInput( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, InData%SS_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_SS_Rdtn_Buf  ) ! SS_Rdtn
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_SS_Rdtn_Buf  ) ! SS_Rdtn
  IF(ALLOCATED(Int_SS_Rdtn_Buf))Int_BufSz = Int_BufSz + SIZE( Int_SS_Rdtn_Buf ) ! SS_Rdtn
  IF(ALLOCATED(Re_SS_Rdtn_Buf))  DEALLOCATE(Re_SS_Rdtn_Buf)
  IF(ALLOCATED(Db_SS_Rdtn_Buf))  DEALLOCATE(Db_SS_Rdtn_Buf)
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) DEALLOCATE(Int_SS_Rdtn_Buf)
  Re_BufSz   = Re_BufSz   + 1  ! Rhoxg
  Int_BufSz  = Int_BufSz  + 1  ! NStepWave
  Int_BufSz  = Int_BufSz  + 1  ! NStepWave2
  Re_BufSz   = Re_BufSz   + 1  ! WaveDOmega
  IF ( ALLOCATED(InData%WaveElevC0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveElevC0 )  ! WaveElevC0 
  IF ( ALLOCATED(InData%WaveTime) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveTime )  ! WaveTime 
  Int_BufSz  = Int_BufSz  + 1  ! WaveMod
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  IF ( ALLOCATED(InData%WaveDirArr) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveDirArr )  ! WaveDirArr 
  Re_BufSz   = Re_BufSz   + 1  ! WaveDirMin
  Re_BufSz   = Re_BufSz   + 1  ! WaveDirMax
!  missing buffer for OutList
  Int_BufSz  = Int_BufSz  + 1  ! OutAll
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtfmVol0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%HasWAMIT ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WAMITULEN )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtfmCOBxt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtfmCOByt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%RdtnMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%RdtnTMax )
  Db_Xferred   = Db_Xferred   + 1
  CALL Conv_Rdtn_PackInitInput( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, InData%Conv_Rdtn, ErrStat, ErrMsg, OnlySize ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Conv_Rdtn_Buf)-1 ) = Re_Conv_Rdtn_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Conv_Rdtn_Buf)-1 ) = Db_Conv_Rdtn_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Conv_Rdtn_Buf)-1 ) = Int_Conv_Rdtn_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Conv_Rdtn_Buf)
  ENDIF
  IF( ALLOCATED(Re_Conv_Rdtn_Buf) )  DEALLOCATE(Re_Conv_Rdtn_Buf)
  IF( ALLOCATED(Db_Conv_Rdtn_Buf) )  DEALLOCATE(Db_Conv_Rdtn_Buf)
  IF( ALLOCATED(Int_Conv_Rdtn_Buf) ) DEALLOCATE(Int_Conv_Rdtn_Buf)
  CALL SS_Rad_PackInitInput( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, InData%SS_Rdtn, ErrStat, ErrMsg, OnlySize ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_SS_Rdtn_Buf)-1 ) = Re_SS_Rdtn_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_SS_Rdtn_Buf)-1 ) = Db_SS_Rdtn_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_SS_Rdtn_Buf)-1 ) = Int_SS_Rdtn_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_SS_Rdtn_Buf)
  ENDIF
  IF( ALLOCATED(Re_SS_Rdtn_Buf) )  DEALLOCATE(Re_SS_Rdtn_Buf)
  IF( ALLOCATED(Db_SS_Rdtn_Buf) )  DEALLOCATE(Db_SS_Rdtn_Buf)
  IF( ALLOCATED(Int_SS_Rdtn_Buf) ) DEALLOCATE(Int_SS_Rdtn_Buf)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Rhoxg )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NStepWave )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NStepWave2 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WaveDOmega )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%WaveElevC0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveElevC0))-1 ) =  PACK(InData%WaveElevC0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveElevC0)
  ENDIF
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveTime))-1 ) =  PACK(InData%WaveTime ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveTime)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%WaveMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%WaveDirArr) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveDirArr))-1 ) =  PACK(InData%WaveDirArr ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveDirArr)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WaveDirMin )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WaveDirMax )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%OutAll ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE WAMIT_PackInitInput

 SUBROUTINE WAMIT_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WAMIT_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Conv_Rdtn_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Conv_Rdtn_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Conv_Rdtn_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_SS_Rdtn_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_SS_Rdtn_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_SS_Rdtn_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%PtfmVol0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WAMITULEN = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PtfmCOBxt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PtfmCOByt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%RdtnMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%RdtnTMax = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
 ! first call Conv_Rdtn_PackInitInput to get correctly sized buffers for unpacking
  CALL Conv_Rdtn_PackInitInput( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, OutData%Conv_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) THEN
    Re_Conv_Rdtn_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Conv_Rdtn_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) THEN
    Db_Conv_Rdtn_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Conv_Rdtn_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) THEN
    Int_Conv_Rdtn_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Conv_Rdtn_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Conv_Rdtn_Buf)
  ENDIF
  CALL Conv_Rdtn_UnPackInitInput( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, OutData%Conv_Rdtn, ErrStat, ErrMsg ) ! Conv_Rdtn 
 ! first call SS_Rad_PackInitInput to get correctly sized buffers for unpacking
  CALL SS_Rad_PackInitInput( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, OutData%SS_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) THEN
    Re_SS_Rdtn_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_SS_Rdtn_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) THEN
    Db_SS_Rdtn_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_SS_Rdtn_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) THEN
    Int_SS_Rdtn_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_SS_Rdtn_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_SS_Rdtn_Buf)
  ENDIF
  CALL SS_Rad_UnPackInitInput( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, OutData%SS_Rdtn, ErrStat, ErrMsg ) ! SS_Rdtn 
  OutData%Rhoxg = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NStepWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NStepWave2 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%WaveDOmega = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%WaveElevC0) ) THEN
  ALLOCATE(mask2(SIZE(OutData%WaveElevC0,1),SIZE(OutData%WaveElevC0,2)))
  mask2 = .TRUE.
    OutData%WaveElevC0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveElevC0))-1 ),mask2,OutData%WaveElevC0)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveElevC0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveTime) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveTime,1)))
  mask1 = .TRUE.
    OutData%WaveTime = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveTime))-1 ),mask1,OutData%WaveTime)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveTime)
  ENDIF
  OutData%WaveMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%WaveDirArr) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveDirArr,1)))
  mask1 = .TRUE.
    OutData%WaveDirArr = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveDirArr))-1 ),mask1,OutData%WaveDirArr)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveDirArr)
  ENDIF
  OutData%WaveDirMin = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WaveDirMax = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE WAMIT_UnPackInitInput

 SUBROUTINE WAMIT_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(WAMIT_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'WAMIT_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'WAMIT_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
 END SUBROUTINE WAMIT_CopyInitOutput

 SUBROUTINE WAMIT_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(WAMIT_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
 END SUBROUTINE WAMIT_DestroyInitOutput

 SUBROUTINE WAMIT_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WAMIT_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
 END SUBROUTINE WAMIT_PackInitOutput

 SUBROUTINE WAMIT_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WAMIT_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE WAMIT_UnPackInitOutput

 SUBROUTINE WAMIT_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(WAMIT_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SS_Rad_CopyContState( SrcContStateData%SS_Rdtn, DstContStateData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyContState:SS_Rdtn')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyContState

 SUBROUTINE WAMIT_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(WAMIT_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SS_Rad_DestroyContState( ContStateData%SS_Rdtn, ErrStat, ErrMsg )
 END SUBROUTINE WAMIT_DestroyContState

 SUBROUTINE WAMIT_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WAMIT_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_SS_Rdtn_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_SS_Rdtn_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_SS_Rdtn_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SS_Rad_PackContState( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, InData%SS_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_SS_Rdtn_Buf  ) ! SS_Rdtn
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_SS_Rdtn_Buf  ) ! SS_Rdtn
  IF(ALLOCATED(Int_SS_Rdtn_Buf))Int_BufSz = Int_BufSz + SIZE( Int_SS_Rdtn_Buf ) ! SS_Rdtn
  IF(ALLOCATED(Re_SS_Rdtn_Buf))  DEALLOCATE(Re_SS_Rdtn_Buf)
  IF(ALLOCATED(Db_SS_Rdtn_Buf))  DEALLOCATE(Db_SS_Rdtn_Buf)
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) DEALLOCATE(Int_SS_Rdtn_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SS_Rad_PackContState( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, InData%SS_Rdtn, ErrStat, ErrMsg, OnlySize ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_SS_Rdtn_Buf)-1 ) = Re_SS_Rdtn_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_SS_Rdtn_Buf)-1 ) = Db_SS_Rdtn_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_SS_Rdtn_Buf)-1 ) = Int_SS_Rdtn_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_SS_Rdtn_Buf)
  ENDIF
  IF( ALLOCATED(Re_SS_Rdtn_Buf) )  DEALLOCATE(Re_SS_Rdtn_Buf)
  IF( ALLOCATED(Db_SS_Rdtn_Buf) )  DEALLOCATE(Db_SS_Rdtn_Buf)
  IF( ALLOCATED(Int_SS_Rdtn_Buf) ) DEALLOCATE(Int_SS_Rdtn_Buf)
 END SUBROUTINE WAMIT_PackContState

 SUBROUTINE WAMIT_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WAMIT_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_SS_Rdtn_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_SS_Rdtn_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_SS_Rdtn_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SS_Rad_PackContState to get correctly sized buffers for unpacking
  CALL SS_Rad_PackContState( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, OutData%SS_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) THEN
    Re_SS_Rdtn_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_SS_Rdtn_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) THEN
    Db_SS_Rdtn_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_SS_Rdtn_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) THEN
    Int_SS_Rdtn_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_SS_Rdtn_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_SS_Rdtn_Buf)
  ENDIF
  CALL SS_Rad_UnPackContState( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, OutData%SS_Rdtn, ErrStat, ErrMsg ) ! SS_Rdtn 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE WAMIT_UnPackContState

 SUBROUTINE WAMIT_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(WAMIT_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL Conv_Rdtn_CopyDiscState( SrcDiscStateData%Conv_Rdtn, DstDiscStateData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyDiscState:Conv_Rdtn')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyDiscState

 SUBROUTINE WAMIT_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(WAMIT_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL Conv_Rdtn_DestroyDiscState( DiscStateData%Conv_Rdtn, ErrStat, ErrMsg )
 END SUBROUTINE WAMIT_DestroyDiscState

 SUBROUTINE WAMIT_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WAMIT_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Conv_Rdtn_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Conv_Rdtn_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Conv_Rdtn_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL Conv_Rdtn_PackDiscState( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, InData%Conv_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Conv_Rdtn_Buf  ) ! Conv_Rdtn
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Conv_Rdtn_Buf  ) ! Conv_Rdtn
  IF(ALLOCATED(Int_Conv_Rdtn_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Conv_Rdtn_Buf ) ! Conv_Rdtn
  IF(ALLOCATED(Re_Conv_Rdtn_Buf))  DEALLOCATE(Re_Conv_Rdtn_Buf)
  IF(ALLOCATED(Db_Conv_Rdtn_Buf))  DEALLOCATE(Db_Conv_Rdtn_Buf)
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) DEALLOCATE(Int_Conv_Rdtn_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL Conv_Rdtn_PackDiscState( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, InData%Conv_Rdtn, ErrStat, ErrMsg, OnlySize ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Conv_Rdtn_Buf)-1 ) = Re_Conv_Rdtn_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Conv_Rdtn_Buf)-1 ) = Db_Conv_Rdtn_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Conv_Rdtn_Buf)-1 ) = Int_Conv_Rdtn_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Conv_Rdtn_Buf)
  ENDIF
  IF( ALLOCATED(Re_Conv_Rdtn_Buf) )  DEALLOCATE(Re_Conv_Rdtn_Buf)
  IF( ALLOCATED(Db_Conv_Rdtn_Buf) )  DEALLOCATE(Db_Conv_Rdtn_Buf)
  IF( ALLOCATED(Int_Conv_Rdtn_Buf) ) DEALLOCATE(Int_Conv_Rdtn_Buf)
 END SUBROUTINE WAMIT_PackDiscState

 SUBROUTINE WAMIT_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WAMIT_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Conv_Rdtn_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Conv_Rdtn_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Conv_Rdtn_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call Conv_Rdtn_PackDiscState to get correctly sized buffers for unpacking
  CALL Conv_Rdtn_PackDiscState( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, OutData%Conv_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) THEN
    Re_Conv_Rdtn_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Conv_Rdtn_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) THEN
    Db_Conv_Rdtn_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Conv_Rdtn_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) THEN
    Int_Conv_Rdtn_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Conv_Rdtn_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Conv_Rdtn_Buf)
  ENDIF
  CALL Conv_Rdtn_UnPackDiscState( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, OutData%Conv_Rdtn, ErrStat, ErrMsg ) ! Conv_Rdtn 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE WAMIT_UnPackDiscState

 SUBROUTINE WAMIT_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(WAMIT_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE WAMIT_CopyConstrState

 SUBROUTINE WAMIT_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(WAMIT_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE WAMIT_DestroyConstrState

 SUBROUTINE WAMIT_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WAMIT_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE WAMIT_PackConstrState

 SUBROUTINE WAMIT_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WAMIT_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE WAMIT_UnPackConstrState

 SUBROUTINE WAMIT_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(WAMIT_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOtherStateData%LastIndWave = SrcOtherStateData%LastIndWave
      CALL SS_Rad_CopyOtherState( SrcOtherStateData%SS_Rdtn, DstOtherStateData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyOtherState:SS_Rdtn')
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Conv_Rdtn_CopyOtherState( SrcOtherStateData%Conv_Rdtn, DstOtherStateData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyOtherState:Conv_Rdtn')
         IF (ErrStat>=AbortErrLev) RETURN
   DstOtherStateData%F_HS = SrcOtherStateData%F_HS
   DstOtherStateData%F_Waves1 = SrcOtherStateData%F_Waves1
   DstOtherStateData%F_Rdtn = SrcOtherStateData%F_Rdtn
   DstOtherStateData%F_PtfmAdd = SrcOtherStateData%F_PtfmAdd
   DstOtherStateData%F_PtfmAM = SrcOtherStateData%F_PtfmAM
 END SUBROUTINE WAMIT_CopyOtherState

 SUBROUTINE WAMIT_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(WAMIT_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SS_Rad_DestroyOtherState( OtherStateData%SS_Rdtn, ErrStat, ErrMsg )
  CALL Conv_Rdtn_DestroyOtherState( OtherStateData%Conv_Rdtn, ErrStat, ErrMsg )
 END SUBROUTINE WAMIT_DestroyOtherState

 SUBROUTINE WAMIT_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WAMIT_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_SS_Rdtn_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_SS_Rdtn_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_SS_Rdtn_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_Conv_Rdtn_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Conv_Rdtn_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Conv_Rdtn_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! LastIndWave
  CALL SS_Rad_PackOtherState( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, InData%SS_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_SS_Rdtn_Buf  ) ! SS_Rdtn
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_SS_Rdtn_Buf  ) ! SS_Rdtn
  IF(ALLOCATED(Int_SS_Rdtn_Buf))Int_BufSz = Int_BufSz + SIZE( Int_SS_Rdtn_Buf ) ! SS_Rdtn
  IF(ALLOCATED(Re_SS_Rdtn_Buf))  DEALLOCATE(Re_SS_Rdtn_Buf)
  IF(ALLOCATED(Db_SS_Rdtn_Buf))  DEALLOCATE(Db_SS_Rdtn_Buf)
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) DEALLOCATE(Int_SS_Rdtn_Buf)
  CALL Conv_Rdtn_PackOtherState( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, InData%Conv_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Conv_Rdtn_Buf  ) ! Conv_Rdtn
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Conv_Rdtn_Buf  ) ! Conv_Rdtn
  IF(ALLOCATED(Int_Conv_Rdtn_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Conv_Rdtn_Buf ) ! Conv_Rdtn
  IF(ALLOCATED(Re_Conv_Rdtn_Buf))  DEALLOCATE(Re_Conv_Rdtn_Buf)
  IF(ALLOCATED(Db_Conv_Rdtn_Buf))  DEALLOCATE(Db_Conv_Rdtn_Buf)
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) DEALLOCATE(Int_Conv_Rdtn_Buf)
  Re_BufSz    = Re_BufSz    + SIZE( InData%F_HS )  ! F_HS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F_Waves1 )  ! F_Waves1 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F_Rdtn )  ! F_Rdtn 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F_PtfmAdd )  ! F_PtfmAdd 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F_PtfmAM )  ! F_PtfmAM 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%LastIndWave )
  Int_Xferred   = Int_Xferred   + 1
  CALL SS_Rad_PackOtherState( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, InData%SS_Rdtn, ErrStat, ErrMsg, OnlySize ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_SS_Rdtn_Buf)-1 ) = Re_SS_Rdtn_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_SS_Rdtn_Buf)-1 ) = Db_SS_Rdtn_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_SS_Rdtn_Buf)-1 ) = Int_SS_Rdtn_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_SS_Rdtn_Buf)
  ENDIF
  IF( ALLOCATED(Re_SS_Rdtn_Buf) )  DEALLOCATE(Re_SS_Rdtn_Buf)
  IF( ALLOCATED(Db_SS_Rdtn_Buf) )  DEALLOCATE(Db_SS_Rdtn_Buf)
  IF( ALLOCATED(Int_SS_Rdtn_Buf) ) DEALLOCATE(Int_SS_Rdtn_Buf)
  CALL Conv_Rdtn_PackOtherState( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, InData%Conv_Rdtn, ErrStat, ErrMsg, OnlySize ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Conv_Rdtn_Buf)-1 ) = Re_Conv_Rdtn_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Conv_Rdtn_Buf)-1 ) = Db_Conv_Rdtn_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Conv_Rdtn_Buf)-1 ) = Int_Conv_Rdtn_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Conv_Rdtn_Buf)
  ENDIF
  IF( ALLOCATED(Re_Conv_Rdtn_Buf) )  DEALLOCATE(Re_Conv_Rdtn_Buf)
  IF( ALLOCATED(Db_Conv_Rdtn_Buf) )  DEALLOCATE(Db_Conv_Rdtn_Buf)
  IF( ALLOCATED(Int_Conv_Rdtn_Buf) ) DEALLOCATE(Int_Conv_Rdtn_Buf)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_HS))-1 ) =  PACK(InData%F_HS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%F_HS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_Waves1))-1 ) =  PACK(InData%F_Waves1 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%F_Waves1)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_Rdtn))-1 ) =  PACK(InData%F_Rdtn ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%F_Rdtn)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_PtfmAdd))-1 ) =  PACK(InData%F_PtfmAdd ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%F_PtfmAdd)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_PtfmAM))-1 ) =  PACK(InData%F_PtfmAM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%F_PtfmAM)
 END SUBROUTINE WAMIT_PackOtherState

 SUBROUTINE WAMIT_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WAMIT_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_SS_Rdtn_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_SS_Rdtn_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_SS_Rdtn_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_Conv_Rdtn_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Conv_Rdtn_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Conv_Rdtn_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%LastIndWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
 ! first call SS_Rad_PackOtherState to get correctly sized buffers for unpacking
  CALL SS_Rad_PackOtherState( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, OutData%SS_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) THEN
    Re_SS_Rdtn_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_SS_Rdtn_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) THEN
    Db_SS_Rdtn_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_SS_Rdtn_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) THEN
    Int_SS_Rdtn_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_SS_Rdtn_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_SS_Rdtn_Buf)
  ENDIF
  CALL SS_Rad_UnPackOtherState( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, OutData%SS_Rdtn, ErrStat, ErrMsg ) ! SS_Rdtn 
 ! first call Conv_Rdtn_PackOtherState to get correctly sized buffers for unpacking
  CALL Conv_Rdtn_PackOtherState( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, OutData%Conv_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) THEN
    Re_Conv_Rdtn_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Conv_Rdtn_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) THEN
    Db_Conv_Rdtn_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Conv_Rdtn_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) THEN
    Int_Conv_Rdtn_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Conv_Rdtn_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Conv_Rdtn_Buf)
  ENDIF
  CALL Conv_Rdtn_UnPackOtherState( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, OutData%Conv_Rdtn, ErrStat, ErrMsg ) ! Conv_Rdtn 
  ALLOCATE(mask1(SIZE(OutData%F_HS,1)))
  mask1 = .TRUE.
  OutData%F_HS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_HS))-1 ),mask1,OutData%F_HS)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%F_HS)
  ALLOCATE(mask1(SIZE(OutData%F_Waves1,1)))
  mask1 = .TRUE.
  OutData%F_Waves1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_Waves1))-1 ),mask1,OutData%F_Waves1)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%F_Waves1)
  ALLOCATE(mask1(SIZE(OutData%F_Rdtn,1)))
  mask1 = .TRUE.
  OutData%F_Rdtn = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_Rdtn))-1 ),mask1,OutData%F_Rdtn)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%F_Rdtn)
  ALLOCATE(mask1(SIZE(OutData%F_PtfmAdd,1)))
  mask1 = .TRUE.
  OutData%F_PtfmAdd = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_PtfmAdd))-1 ),mask1,OutData%F_PtfmAdd)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%F_PtfmAdd)
  ALLOCATE(mask1(SIZE(OutData%F_PtfmAM,1)))
  mask1 = .TRUE.
  OutData%F_PtfmAM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_PtfmAM))-1 ),mask1,OutData%F_PtfmAM)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%F_PtfmAM)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE WAMIT_UnPackOtherState

 SUBROUTINE WAMIT_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(WAMIT_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%HdroAdMsI = SrcParamData%HdroAdMsI
   DstParamData%HdroSttc = SrcParamData%HdroSttc
   DstParamData%PtfmVol0 = SrcParamData%PtfmVol0
   DstParamData%PtfmCOBxt = SrcParamData%PtfmCOBxt
   DstParamData%PtfmCOByt = SrcParamData%PtfmCOByt
   DstParamData%RdtnMod = SrcParamData%RdtnMod
IF (ALLOCATED(SrcParamData%WaveExctn)) THEN
   i1_l = LBOUND(SrcParamData%WaveExctn,1)
   i1_u = UBOUND(SrcParamData%WaveExctn,1)
   i2_l = LBOUND(SrcParamData%WaveExctn,2)
   i2_u = UBOUND(SrcParamData%WaveExctn,2)
   IF (.NOT. ALLOCATED(DstParamData%WaveExctn)) THEN 
      ALLOCATE(DstParamData%WaveExctn(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveExctn.', ErrStat, ErrMsg,'WAMIT_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%WaveExctn = SrcParamData%WaveExctn
ENDIF
   DstParamData%RhoXg = SrcParamData%RhoXg
IF (ALLOCATED(SrcParamData%WaveTime)) THEN
   i1_l = LBOUND(SrcParamData%WaveTime,1)
   i1_u = UBOUND(SrcParamData%WaveTime,1)
   IF (.NOT. ALLOCATED(DstParamData%WaveTime)) THEN 
      ALLOCATE(DstParamData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveTime.', ErrStat, ErrMsg,'WAMIT_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%WaveTime = SrcParamData%WaveTime
ENDIF
   DstParamData%NStepWave = SrcParamData%NStepWave
      CALL Conv_Rdtn_CopyParam( SrcParamData%Conv_Rdtn, DstParamData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyParam:Conv_Rdtn')
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Rad_CopyParam( SrcParamData%SS_Rdtn, DstParamData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyParam:SS_Rdtn')
         IF (ErrStat>=AbortErrLev) RETURN
   DstParamData%DT = SrcParamData%DT
   DstParamData%PtfmSgF = SrcParamData%PtfmSgF
   DstParamData%PtfmSwF = SrcParamData%PtfmSwF
   DstParamData%PtfmHvF = SrcParamData%PtfmHvF
   DstParamData%PtfmRF = SrcParamData%PtfmRF
   DstParamData%PtfmPF = SrcParamData%PtfmPF
   DstParamData%PtfmYF = SrcParamData%PtfmYF
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,'WAMIT_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyParam:OutParam(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%NumOutAll = SrcParamData%NumOutAll
   DstParamData%OutFmt = SrcParamData%OutFmt
   DstParamData%OutSFmt = SrcParamData%OutSFmt
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%UnOutFile = SrcParamData%UnOutFile
 END SUBROUTINE WAMIT_CopyParam

 SUBROUTINE WAMIT_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(WAMIT_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%WaveExctn)) THEN
   DEALLOCATE(ParamData%WaveExctn)
ENDIF
IF (ALLOCATED(ParamData%WaveTime)) THEN
   DEALLOCATE(ParamData%WaveTime)
ENDIF
  CALL Conv_Rdtn_DestroyParam( ParamData%Conv_Rdtn, ErrStat, ErrMsg )
  CALL SS_Rad_DestroyParam( ParamData%SS_Rdtn, ErrStat, ErrMsg )
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE WAMIT_DestroyParam

 SUBROUTINE WAMIT_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WAMIT_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Conv_Rdtn_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Conv_Rdtn_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Conv_Rdtn_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_SS_Rdtn_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_SS_Rdtn_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_SS_Rdtn_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%HdroAdMsI )  ! HdroAdMsI 
  Re_BufSz    = Re_BufSz    + SIZE( InData%HdroSttc )  ! HdroSttc 
  Re_BufSz   = Re_BufSz   + 1  ! PtfmVol0
  Re_BufSz   = Re_BufSz   + 1  ! PtfmCOBxt
  Re_BufSz   = Re_BufSz   + 1  ! PtfmCOByt
  Int_BufSz  = Int_BufSz  + 1  ! RdtnMod
  IF ( ALLOCATED(InData%WaveExctn) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveExctn )  ! WaveExctn 
  Re_BufSz   = Re_BufSz   + 1  ! RhoXg
  IF ( ALLOCATED(InData%WaveTime) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveTime )  ! WaveTime 
  Int_BufSz  = Int_BufSz  + 1  ! NStepWave
  CALL Conv_Rdtn_PackParam( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, InData%Conv_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Conv_Rdtn_Buf  ) ! Conv_Rdtn
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Conv_Rdtn_Buf  ) ! Conv_Rdtn
  IF(ALLOCATED(Int_Conv_Rdtn_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Conv_Rdtn_Buf ) ! Conv_Rdtn
  IF(ALLOCATED(Re_Conv_Rdtn_Buf))  DEALLOCATE(Re_Conv_Rdtn_Buf)
  IF(ALLOCATED(Db_Conv_Rdtn_Buf))  DEALLOCATE(Db_Conv_Rdtn_Buf)
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) DEALLOCATE(Int_Conv_Rdtn_Buf)
  CALL SS_Rad_PackParam( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, InData%SS_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_SS_Rdtn_Buf  ) ! SS_Rdtn
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_SS_Rdtn_Buf  ) ! SS_Rdtn
  IF(ALLOCATED(Int_SS_Rdtn_Buf))Int_BufSz = Int_BufSz + SIZE( Int_SS_Rdtn_Buf ) ! SS_Rdtn
  IF(ALLOCATED(Re_SS_Rdtn_Buf))  DEALLOCATE(Re_SS_Rdtn_Buf)
  IF(ALLOCATED(Db_SS_Rdtn_Buf))  DEALLOCATE(Db_SS_Rdtn_Buf)
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) DEALLOCATE(Int_SS_Rdtn_Buf)
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Int_BufSz  = Int_BufSz  + 1  ! PtfmSgF
  Int_BufSz  = Int_BufSz  + 1  ! PtfmSwF
  Int_BufSz  = Int_BufSz  + 1  ! PtfmHvF
  Int_BufSz  = Int_BufSz  + 1  ! PtfmRF
  Int_BufSz  = Int_BufSz  + 1  ! PtfmPF
  Int_BufSz  = Int_BufSz  + 1  ! PtfmYF
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz  = Int_BufSz  + 1  ! NumOutAll
!  missing buffer for OutFmt
!  missing buffer for OutSFmt
!  missing buffer for Delim
  Int_BufSz  = Int_BufSz  + 1  ! UnOutFile
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%HdroAdMsI))-1 ) =  PACK(InData%HdroAdMsI ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%HdroAdMsI)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%HdroSttc))-1 ) =  PACK(InData%HdroSttc ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%HdroSttc)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtfmVol0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtfmCOBxt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtfmCOByt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%RdtnMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%WaveExctn) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveExctn))-1 ) =  PACK(InData%WaveExctn ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveExctn)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%RhoXg )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveTime))-1 ) =  PACK(InData%WaveTime ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveTime)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NStepWave )
  Int_Xferred   = Int_Xferred   + 1
  CALL Conv_Rdtn_PackParam( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, InData%Conv_Rdtn, ErrStat, ErrMsg, OnlySize ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Conv_Rdtn_Buf)-1 ) = Re_Conv_Rdtn_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Conv_Rdtn_Buf)-1 ) = Db_Conv_Rdtn_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Conv_Rdtn_Buf)-1 ) = Int_Conv_Rdtn_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Conv_Rdtn_Buf)
  ENDIF
  IF( ALLOCATED(Re_Conv_Rdtn_Buf) )  DEALLOCATE(Re_Conv_Rdtn_Buf)
  IF( ALLOCATED(Db_Conv_Rdtn_Buf) )  DEALLOCATE(Db_Conv_Rdtn_Buf)
  IF( ALLOCATED(Int_Conv_Rdtn_Buf) ) DEALLOCATE(Int_Conv_Rdtn_Buf)
  CALL SS_Rad_PackParam( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, InData%SS_Rdtn, ErrStat, ErrMsg, OnlySize ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_SS_Rdtn_Buf)-1 ) = Re_SS_Rdtn_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_SS_Rdtn_Buf)-1 ) = Db_SS_Rdtn_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_SS_Rdtn_Buf)-1 ) = Int_SS_Rdtn_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_SS_Rdtn_Buf)
  ENDIF
  IF( ALLOCATED(Re_SS_Rdtn_Buf) )  DEALLOCATE(Re_SS_Rdtn_Buf)
  IF( ALLOCATED(Db_SS_Rdtn_Buf) )  DEALLOCATE(Db_SS_Rdtn_Buf)
  IF( ALLOCATED(Int_SS_Rdtn_Buf) ) DEALLOCATE(Int_SS_Rdtn_Buf)
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%PtfmSgF ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%PtfmSwF ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%PtfmHvF ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%PtfmRF ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%PtfmPF ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%PtfmYF ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOutAll )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnOutFile )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE WAMIT_PackParam

 SUBROUTINE WAMIT_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WAMIT_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Conv_Rdtn_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Conv_Rdtn_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Conv_Rdtn_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_SS_Rdtn_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_SS_Rdtn_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_SS_Rdtn_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  ALLOCATE(mask2(SIZE(OutData%HdroAdMsI,1),SIZE(OutData%HdroAdMsI,2)))
  mask2 = .TRUE.
  OutData%HdroAdMsI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%HdroAdMsI))-1 ),mask2,OutData%HdroAdMsI)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%HdroAdMsI)
  ALLOCATE(mask2(SIZE(OutData%HdroSttc,1),SIZE(OutData%HdroSttc,2)))
  mask2 = .TRUE.
  OutData%HdroSttc = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%HdroSttc))-1 ),mask2,OutData%HdroSttc)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%HdroSttc)
  OutData%PtfmVol0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PtfmCOBxt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PtfmCOByt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%RdtnMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%WaveExctn) ) THEN
  ALLOCATE(mask2(SIZE(OutData%WaveExctn,1),SIZE(OutData%WaveExctn,2)))
  mask2 = .TRUE.
    OutData%WaveExctn = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveExctn))-1 ),mask2,OutData%WaveExctn)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveExctn)
  ENDIF
  OutData%RhoXg = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%WaveTime) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveTime,1)))
  mask1 = .TRUE.
    OutData%WaveTime = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveTime))-1 ),mask1,OutData%WaveTime)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveTime)
  ENDIF
  OutData%NStepWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
 ! first call Conv_Rdtn_PackParam to get correctly sized buffers for unpacking
  CALL Conv_Rdtn_PackParam( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, OutData%Conv_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! Conv_Rdtn 
  IF(ALLOCATED(Re_Conv_Rdtn_Buf)) THEN
    Re_Conv_Rdtn_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Conv_Rdtn_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_Conv_Rdtn_Buf)) THEN
    Db_Conv_Rdtn_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Conv_Rdtn_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Conv_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_Conv_Rdtn_Buf)) THEN
    Int_Conv_Rdtn_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Conv_Rdtn_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Conv_Rdtn_Buf)
  ENDIF
  CALL Conv_Rdtn_UnPackParam( Re_Conv_Rdtn_Buf, Db_Conv_Rdtn_Buf, Int_Conv_Rdtn_Buf, OutData%Conv_Rdtn, ErrStat, ErrMsg ) ! Conv_Rdtn 
 ! first call SS_Rad_PackParam to get correctly sized buffers for unpacking
  CALL SS_Rad_PackParam( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, OutData%SS_Rdtn, ErrStat, ErrMsg, .TRUE. ) ! SS_Rdtn 
  IF(ALLOCATED(Re_SS_Rdtn_Buf)) THEN
    Re_SS_Rdtn_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_SS_Rdtn_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Db_SS_Rdtn_Buf)) THEN
    Db_SS_Rdtn_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_SS_Rdtn_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_SS_Rdtn_Buf)
  ENDIF
  IF(ALLOCATED(Int_SS_Rdtn_Buf)) THEN
    Int_SS_Rdtn_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_SS_Rdtn_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_SS_Rdtn_Buf)
  ENDIF
  CALL SS_Rad_UnPackParam( Re_SS_Rdtn_Buf, Db_SS_Rdtn_Buf, Int_SS_Rdtn_Buf, OutData%SS_Rdtn, ErrStat, ErrMsg ) ! SS_Rdtn 
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call NWTC_Library_Packoutparmtype to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL NWTC_Library_UnPackoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumOutAll = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnOutFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE WAMIT_UnPackParam

 SUBROUTINE WAMIT_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(WAMIT_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInputData%Mesh, DstInputData%Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyInput:Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyInput

 SUBROUTINE WAMIT_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(WAMIT_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%Mesh, ErrStat, ErrMsg )
 END SUBROUTINE WAMIT_DestroyInput

 SUBROUTINE WAMIT_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WAMIT_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Mesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%Mesh, Re_Mesh_Buf, Db_Mesh_Buf, Int_Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Mesh 
  IF(ALLOCATED(Re_Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Mesh_Buf  ) ! Mesh
  IF(ALLOCATED(Db_Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Mesh_Buf  ) ! Mesh
  IF(ALLOCATED(Int_Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Mesh_Buf ) ! Mesh
  IF(ALLOCATED(Re_Mesh_Buf))  DEALLOCATE(Re_Mesh_Buf)
  IF(ALLOCATED(Db_Mesh_Buf))  DEALLOCATE(Db_Mesh_Buf)
  IF(ALLOCATED(Int_Mesh_Buf)) DEALLOCATE(Int_Mesh_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%Mesh, Re_Mesh_Buf, Db_Mesh_Buf, Int_Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Mesh 
  IF(ALLOCATED(Re_Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Mesh_Buf)-1 ) = Re_Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Mesh_Buf)-1 ) = Db_Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Mesh_Buf)-1 ) = Int_Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Mesh_Buf) )  DEALLOCATE(Re_Mesh_Buf)
  IF( ALLOCATED(Db_Mesh_Buf) )  DEALLOCATE(Db_Mesh_Buf)
  IF( ALLOCATED(Int_Mesh_Buf) ) DEALLOCATE(Int_Mesh_Buf)
 END SUBROUTINE WAMIT_PackInput

 SUBROUTINE WAMIT_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WAMIT_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Mesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%Mesh, Re_Mesh_Buf, Db_Mesh_Buf, Int_Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Mesh 
  IF(ALLOCATED(Re_Mesh_Buf)) THEN
    Re_Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Mesh_Buf)) THEN
    Db_Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Mesh_Buf)) THEN
    Int_Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Mesh, Re_Mesh_Buf, Db_Mesh_Buf, Int_Mesh_Buf, ErrStat, ErrMsg ) ! Mesh 
  IF( ALLOCATED(Re_Mesh_Buf) )  DEALLOCATE(Re_Mesh_Buf)
  IF( ALLOCATED(Db_Mesh_Buf) )  DEALLOCATE(Db_Mesh_Buf)
  IF( ALLOCATED(Int_Mesh_Buf) ) DEALLOCATE(Int_Mesh_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE WAMIT_UnPackInput

 SUBROUTINE WAMIT_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(WAMIT_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcOutputData%Mesh, DstOutputData%Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_CopyOutput:Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'WAMIT_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE WAMIT_CopyOutput

 SUBROUTINE WAMIT_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(WAMIT_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%Mesh, ErrStat, ErrMsg )
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE WAMIT_DestroyOutput

 SUBROUTINE WAMIT_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(WAMIT_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Mesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%Mesh, Re_Mesh_Buf, Db_Mesh_Buf, Int_Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Mesh 
  IF(ALLOCATED(Re_Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Mesh_Buf  ) ! Mesh
  IF(ALLOCATED(Db_Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Mesh_Buf  ) ! Mesh
  IF(ALLOCATED(Int_Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Mesh_Buf ) ! Mesh
  IF(ALLOCATED(Re_Mesh_Buf))  DEALLOCATE(Re_Mesh_Buf)
  IF(ALLOCATED(Db_Mesh_Buf))  DEALLOCATE(Db_Mesh_Buf)
  IF(ALLOCATED(Int_Mesh_Buf)) DEALLOCATE(Int_Mesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%Mesh, Re_Mesh_Buf, Db_Mesh_Buf, Int_Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Mesh 
  IF(ALLOCATED(Re_Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Mesh_Buf)-1 ) = Re_Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Mesh_Buf)-1 ) = Db_Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Mesh_Buf)-1 ) = Int_Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Mesh_Buf) )  DEALLOCATE(Re_Mesh_Buf)
  IF( ALLOCATED(Db_Mesh_Buf) )  DEALLOCATE(Db_Mesh_Buf)
  IF( ALLOCATED(Int_Mesh_Buf) ) DEALLOCATE(Int_Mesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE WAMIT_PackOutput

 SUBROUTINE WAMIT_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(WAMIT_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Mesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%Mesh, Re_Mesh_Buf, Db_Mesh_Buf, Int_Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Mesh 
  IF(ALLOCATED(Re_Mesh_Buf)) THEN
    Re_Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Mesh_Buf)) THEN
    Db_Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Mesh_Buf)) THEN
    Int_Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Mesh, Re_Mesh_Buf, Db_Mesh_Buf, Int_Mesh_Buf, ErrStat, ErrMsg ) ! Mesh 
  IF( ALLOCATED(Re_Mesh_Buf) )  DEALLOCATE(Re_Mesh_Buf)
  IF( ALLOCATED(Db_Mesh_Buf) )  DEALLOCATE(Db_Mesh_Buf)
  IF( ALLOCATED(Int_Mesh_Buf) ) DEALLOCATE(Int_Mesh_Buf)
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE WAMIT_UnPackOutput


 SUBROUTINE WAMIT_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(WAMIT_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(WAMIT_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in WAMIT_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%Mesh, u_out%Mesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_Input_ExtrapInterp:%Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%Mesh, u(2)%Mesh, tin, u_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_Input_ExtrapInterp:%Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%Mesh, u(2)%Mesh, u(3)%Mesh, tin, u_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_Input_ExtrapInterp:%Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in WAMIT_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE WAMIT_Input_ExtrapInterp


 SUBROUTINE WAMIT_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(WAMIT_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(WAMIT_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in WAMIT_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%Mesh, u_out%Mesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_Output_ExtrapInterp:%Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%Mesh, u(2)%Mesh, tin, u_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_Output_ExtrapInterp:%Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in WAMIT_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%Mesh, u(2)%Mesh, u(3)%Mesh, tin, u_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'WAMIT_Output_ExtrapInterp:%Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in WAMIT_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE WAMIT_Output_ExtrapInterp

END MODULE WAMIT_Types
!ENDOFREGISTRYGENERATEDFILE
