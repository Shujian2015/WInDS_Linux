!STARTOFREGISTRYGENERATEDFILE './IceDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 14-Jan-2015)
!*********************************************************************************************************************************
! IceDyn_Types
!.................................................................................................................................
! This file is part of IceDyn.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE IceDyn_Types
! This module contains all of the user-defined types needed in IceDyn. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  IceD_InputFile  =======
  TYPE, PUBLIC :: IceD_InputFile
    INTEGER(IntKi)  :: IceModel      ! The current ice model number [-]
    INTEGER(IntKi)  :: IceSubModel      ! The current ice sub-model number [-]
    REAL(ReKi)  :: h      ! Ice thickness [m]
    REAL(ReKi)  :: v      ! Ice velocity [m/s]
    REAL(ReKi)  :: InitLoc      ! Ice sheet initial location [m]
    REAL(ReKi)  :: t0      ! Ice load starting time [s]
    REAL(ReKi)  :: rhow      ! Water mass density [kg/m^3]
    REAL(ReKi)  :: rhoi      ! Ice mass density [kg/m^3]
    INTEGER(IntKi)  :: Seed1      ! Random seed 1 [-]
    INTEGER(IntKi)  :: Seed2      ! Random seed 2 [-]
    INTEGER(IntKi)  :: NumLegs      ! Number of support structure legs in ice [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LegPosX      ! global X position of legs 1-NumLegs  [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LegPosY      ! global Y position of legs 1-NumLegs  [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: StrWd      ! The width of the leg (structure) [m]
    REAL(ReKi)  :: Ikm      ! Indentation factor [-]
    REAL(ReKi)  :: Ag      ! Ice crystal type factor [MPa^-3s^-1]
    REAL(ReKi)  :: Qg      ! Activation energy [kJ]
    REAL(ReKi)  :: Rg      ! Universal gas constant [J]
    REAL(ReKi)  :: Tice      ! Ice temperature [K]
    REAL(ReKi)  :: nu      ! Poison ratio of ice [-]
    REAL(ReKi)  :: phi      ! Ice wedge angle [degree]
    REAL(ReKi)  :: SigNm      ! Nominal ice strength [MPa]
    REAL(ReKi)  :: Eice      ! Elastic modulus of ice [GPa]
    REAL(ReKi)  :: IceStr2      ! Ice tooth brittle strength [MPa]
    REAL(ReKi)  :: Delmax2      ! Ice tooth maximum elastic deformation for model 2 [m]
    REAL(ReKi)  :: Pitch      ! Distance between sequential ice teeth for model 2 [m]
    REAL(ReKi)  :: miuh      ! Mean value of random ice thickness [m]
    REAL(ReKi)  :: varh      ! Variance of random ice thicknesss [m^2]
    REAL(ReKi)  :: miuv      ! Mean value of random ice velocity [m/s]
    REAL(ReKi)  :: varv      ! Variance of random ice velocity [m^2/s^2]
    REAL(ReKi)  :: miut      ! Mean value of ice loading event duration time [s]
    REAL(ReKi)  :: miubr      ! Mean value of random ice brittle strength [MPa]
    REAL(ReKi)  :: varbr      ! Variance of random ice brittle strength [MPa^2]
    REAL(ReKi)  :: miuDelm      ! Mean value of random random maximum ice tooth tip displacement [MPa]
    REAL(ReKi)  :: varDelm      ! Variance of random random maximum ice tooth tip displacement [MPa^2]
    REAL(ReKi)  :: miuP      ! Mean value of random distance between sequential ice teeth [m]
    REAL(ReKi)  :: varP      ! Variance of random distance between sequential ice teeth [m^2]
    INTEGER(IntKi)  :: Zn1      ! Number of failure zones along contact width [-]
    INTEGER(IntKi)  :: Zn2      ! Number of failure zones along contact height/thickness [-]
    REAL(ReKi)  :: ZonePitch      ! Distance between sequential ice teeth [m]
    REAL(ReKi)  :: PrflMean      ! Ice structure contact profile mean value [m]
    REAL(ReKi)  :: PrflSig      ! Ice structure contact profile standard deviation [m]
    REAL(ReKi)  :: IceStr      ! Ice failure strength [MPa]
    REAL(ReKi)  :: Delmax      ! Ice teeth maximum elastic deformation [m]
    REAL(ReKi)  :: alpha      ! slope angle of the cone [degree]
    REAL(ReKi)  :: Dwl      ! cone waterline diameter [m]
    REAL(ReKi)  :: Dtp      ! cone top diameter [m]
    REAL(ReKi)  :: hr      ! ride-up ice thickness [m]
    REAL(ReKi)  :: mu      ! friction coefficient between structure and ice [-]
    REAL(ReKi)  :: sigf      ! flexural strength of ice [MPa]
    REAL(ReKi)  :: StrLim      ! limit strain [-]
    REAL(ReKi)  :: StrRtLim      ! limit strain rate [s^-1]
    INTEGER(IntKi)  :: UorD      ! flag that indicates upward or downward breaking cone: 0,upward, 1,downward. [-]
    REAL(ReKi)  :: Ll      ! Ice floe length [m]
    REAL(ReKi)  :: Lw      ! Ice floe width [m]
    REAL(ReKi)  :: Cpa      ! ice crushing strength pressure-area relation constant [-]
    REAL(ReKi)  :: dpa      ! ice crushing strength pressure-area relation order [-]
    REAL(ReKi)  :: Fdr      ! Constant external driving force [MN]
    REAL(ReKi)  :: Kic      ! Fracture toughness of ice [kNm^(-3/2)]
    REAL(ReKi)  :: FspN      ! Non-dimensional splitting load [-]
  END TYPE IceD_InputFile
! =======================
! =========  IceD_InitInputType  =======
  TYPE, PUBLIC :: IceD_InitInputType
    CHARACTER(1024)  :: InputFile      ! Name of the input file; remove if there is no file [-]
    CHARACTER(1024)  :: RootName      ! Root name of the output file [-]
    REAL(ReKi)  :: MSL2SWL      ! Offset between still-water level and mean sea level [m]
    REAL(ReKi)  :: WtrDens      ! Density of water [kg/m^3]
    REAL(ReKi)  :: gravity      ! Gravitational acceleration [m/s^2]
    INTEGER(IntKi)  :: LegNum      ! Which number of legs on the turbine this is being initialized for [m]
    REAL(DbKi)  :: TMax      ! Total simulation time [s]
  END TYPE IceD_InitInputType
! =======================
! =========  IceD_InitOutputType  =======
  TYPE, PUBLIC :: IceD_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      ! Names of the output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      ! Units of the output-to-file channels [-]
    INTEGER(IntKi)  :: numLegs      ! Number of legs on the structure [-]
    TYPE(ProgDesc)  :: Ver      ! This module's name, version, and date [-]
  END TYPE IceD_InitOutputType
! =======================
! =========  IceD_ContinuousStateType  =======
  TYPE, PUBLIC :: IceD_ContinuousStateType
    REAL(ReKi)  :: q      ! q - displacement of ice mass [m]
    REAL(ReKi)  :: dqdt      ! dqdt - velocity of ice mass [m/s]
  END TYPE IceD_ContinuousStateType
! =======================
! =========  IceD_DiscreteStateType  =======
  TYPE, PUBLIC :: IceD_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      ! A variable, Replace if you have discrete states [-]
  END TYPE IceD_DiscreteStateType
! =======================
! =========  IceD_ConstraintStateType  =======
  TYPE, PUBLIC :: IceD_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      ! A variable, Replace if you have constraint states [-]
  END TYPE IceD_ConstraintStateType
! =======================
! =========  IceD_OtherStateType  =======
  TYPE, PUBLIC :: IceD_OtherStateType
    TYPE(IceD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: xdot      ! previous state deriv for multi-step [m]
    INTEGER(IntKi)  :: n      ! tracks time step for which OtherState was updated [-]
    INTEGER(IntKi)  :: IceTthNo2      ! Ice tooth number of the current ice tooth, for model 2 [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: Nc      ! Number of the current ice tooths number (time series) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Psum      ! The sum of pitches of all broken ice teeth (time series) [m]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IceTthNo      ! IceTthNo - the current numbers of ice teeth of each zone [-]
    REAL(ReKi)  :: Beta      ! angel between broken ice sheet and level waterline [rad]
    REAL(DbKi)  :: Tinit      ! Initial time of the current load cycle [s]
    INTEGER(IntKi)  :: Splitf      ! flag to indicate if the ice floe has splitted (0 not splitted, 1 splitted) [-]
    REAL(ReKi)  :: dxc      ! crushed depth of ice [m]
  END TYPE IceD_OtherStateType
! =======================
! =========  IceD_ParameterType  =======
  TYPE, PUBLIC :: IceD_ParameterType
    REAL(ReKi)  :: h      ! Ice thickness [m]
    REAL(ReKi)  :: v      ! Ice velocity [m/s]
    REAL(ReKi)  :: t0      ! Ice load starting time [s]
    REAL(ReKi)  :: StrWd      ! The width of the structure [m]
    REAL(ReKi)  :: dt      ! Time interval for integration within the module [s]
    REAL(ReKi)  :: InitLoc      ! Ice sheet initial location [m]
    REAL(ReKi)  :: tolerance      ! Tolerance when calculating ice breaking force, etc. [-]
    REAL(ReKi)  :: Tmax      ! Total simulation time [s]
    INTEGER(IntKi)  :: verif      ! flag to indicate if verification is being peformed [-]
    INTEGER(IntKi)  :: ModNo      ! The current ice model number [-]
    INTEGER(IntKi)  :: SubModNo      ! The current ice sub-model number [-]
    INTEGER(IntKi)  :: NumOuts      ! The number of output channels [-]
    INTEGER(IntKi)  :: method      ! integration method: 1-RK4, 2-AB4, 3-ABM4 [-]
    INTEGER(IntKi)  :: TmStep      ! Total time step [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: OutName      ! Names of all requested output parameters [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: OutUnit      ! Units of all requested output parameters [-]
    CHARACTER(1024)  :: RootName      ! Rootname [-]
    REAL(ReKi)  :: tm1a      ! Time for the maximum force to be reached for model 1a [s]
    REAL(ReKi)  :: tm1b      ! Time for the maximum force to be reached for model 1b [s]
    REAL(ReKi)  :: tm1c      ! Time for the maximum force to be reached for model 1c [s]
    REAL(ReKi)  :: Fmax1a      ! Maximum ice force of model 1a [N]
    REAL(ReKi)  :: Fmax1b      ! Maximum ice force of model 1b [N]
    REAL(ReKi)  :: Fmax1c      ! Maximum ice force of model 1c [N]
    REAL(ReKi)  :: Ikm      ! Indentation factor [-]
    REAL(ReKi)  :: Cstr      ! Constant when calculating creeping stresss [Pa*s^(-1/3)]
    REAL(ReKi)  :: EiPa      ! Elastic modulus of ice [Pa]
    REAL(ReKi)  :: Delmax2      ! Ice tooth maximum elastic deformation for model 2 [m]
    REAL(ReKi)  :: Pitch      ! Distance between sequential ice teeth [m]
    REAL(ReKi)  :: Kice2      ! Stiffness of ice teeth for model 2 [N/m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: rdmFm      ! Random maximum ice force time series [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: rdmt0      ! Random ice loading event starting time [s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: rdmtm      ! Random time when the maximum force is reached [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: rdmDm      ! Random maximum ice tooth tip displacement time series [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: rdmP      ! Random distance between sequential ice teeth [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: rdmKi      ! Random ice teeth stiffness [N/m]
    REAL(ReKi)  :: ZonePitch      ! Distance between sequential ice teeth [m]
    REAL(ReKi)  :: Kice      ! Stiffness of ice teeth [N/m]
    REAL(ReKi)  :: Delmax      ! Ice teeth maximum elastic deformation [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y0      ! Ice structure contact profile initial location [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ContPrfl      ! Ice structure contact profile [m]
    INTEGER(IntKi)  :: Zn      ! Number of failure zones [-]
    REAL(ReKi)  :: rhoi      ! Ice mass density  [kg/m^3]
    REAL(ReKi)  :: rhow      ! Water mass density [kg/m^3]
    REAL(ReKi)  :: alphaR      ! Slope angle of the cone [rad]
    REAL(ReKi)  :: Dwl      ! Cone waterline diameter  [m]
    REAL(ReKi)  :: Zr      ! Ice ride-up height [m]
    REAL(ReKi)  :: RHbr      ! Horizontal breaking force [N]
    REAL(ReKi)  :: RVbr      ! Vertical breaking force [N]
    REAL(ReKi)  :: Lbr      ! Ice sheet breaking length [m]
    REAL(ReKi)  :: LovR      ! Ratio of ice breaking length over cone radius [-]
    REAL(ReKi)  :: mu      ! Friction coefficient between structure and ice [-]
    REAL(ReKi)  :: Wri      ! Initial ride-up ice weight  [kg]
    REAL(ReKi)  :: WL      ! Broken ice piece weight [kg]
    REAL(ReKi)  :: Cpa      ! ice crushing strength pressure-area relation constant [-]
    REAL(ReKi)  :: dpa      ! ice crushing strength pressure-area relation order [-]
    REAL(ReKi)  :: FdrN      ! Constant external driving force [N]
    REAL(ReKi)  :: Mice      ! Ice floe mass [kg]
    REAL(ReKi)  :: Fsp      ! Ice floe splitting force [N]
  END TYPE IceD_ParameterType
! =======================
! =========  IceD_InputType  =======
  TYPE, PUBLIC :: IceD_InputType
    TYPE(MeshType)  :: PointMesh      ! contains displacement and velocity of structure [-]
  END TYPE IceD_InputType
! =======================
! =========  IceD_OutputType  =======
  TYPE, PUBLIC :: IceD_OutputType
    TYPE(MeshType)  :: PointMesh      ! contains Ice force [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! Data to be written to an output file: see WriteOutputHdr for names of each variable [see WriteOutputUnt]
  END TYPE IceD_OutputType
! =======================
CONTAINS
 SUBROUTINE IceD_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(IceD_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInputFileData%IceModel = SrcInputFileData%IceModel
   DstInputFileData%IceSubModel = SrcInputFileData%IceSubModel
   DstInputFileData%h = SrcInputFileData%h
   DstInputFileData%v = SrcInputFileData%v
   DstInputFileData%InitLoc = SrcInputFileData%InitLoc
   DstInputFileData%t0 = SrcInputFileData%t0
   DstInputFileData%rhow = SrcInputFileData%rhow
   DstInputFileData%rhoi = SrcInputFileData%rhoi
   DstInputFileData%Seed1 = SrcInputFileData%Seed1
   DstInputFileData%Seed2 = SrcInputFileData%Seed2
   DstInputFileData%NumLegs = SrcInputFileData%NumLegs
IF (ALLOCATED(SrcInputFileData%LegPosX)) THEN
   i1_l = LBOUND(SrcInputFileData%LegPosX,1)
   i1_u = UBOUND(SrcInputFileData%LegPosX,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LegPosX)) THEN 
      ALLOCATE(DstInputFileData%LegPosX(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LegPosX.', ErrStat, ErrMsg,'IceD_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LegPosX = SrcInputFileData%LegPosX
ENDIF
IF (ALLOCATED(SrcInputFileData%LegPosY)) THEN
   i1_l = LBOUND(SrcInputFileData%LegPosY,1)
   i1_u = UBOUND(SrcInputFileData%LegPosY,1)
   IF (.NOT. ALLOCATED(DstInputFileData%LegPosY)) THEN 
      ALLOCATE(DstInputFileData%LegPosY(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LegPosY.', ErrStat, ErrMsg,'IceD_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%LegPosY = SrcInputFileData%LegPosY
ENDIF
IF (ALLOCATED(SrcInputFileData%StrWd)) THEN
   i1_l = LBOUND(SrcInputFileData%StrWd,1)
   i1_u = UBOUND(SrcInputFileData%StrWd,1)
   IF (.NOT. ALLOCATED(DstInputFileData%StrWd)) THEN 
      ALLOCATE(DstInputFileData%StrWd(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%StrWd.', ErrStat, ErrMsg,'IceD_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%StrWd = SrcInputFileData%StrWd
ENDIF
   DstInputFileData%Ikm = SrcInputFileData%Ikm
   DstInputFileData%Ag = SrcInputFileData%Ag
   DstInputFileData%Qg = SrcInputFileData%Qg
   DstInputFileData%Rg = SrcInputFileData%Rg
   DstInputFileData%Tice = SrcInputFileData%Tice
   DstInputFileData%nu = SrcInputFileData%nu
   DstInputFileData%phi = SrcInputFileData%phi
   DstInputFileData%SigNm = SrcInputFileData%SigNm
   DstInputFileData%Eice = SrcInputFileData%Eice
   DstInputFileData%IceStr2 = SrcInputFileData%IceStr2
   DstInputFileData%Delmax2 = SrcInputFileData%Delmax2
   DstInputFileData%Pitch = SrcInputFileData%Pitch
   DstInputFileData%miuh = SrcInputFileData%miuh
   DstInputFileData%varh = SrcInputFileData%varh
   DstInputFileData%miuv = SrcInputFileData%miuv
   DstInputFileData%varv = SrcInputFileData%varv
   DstInputFileData%miut = SrcInputFileData%miut
   DstInputFileData%miubr = SrcInputFileData%miubr
   DstInputFileData%varbr = SrcInputFileData%varbr
   DstInputFileData%miuDelm = SrcInputFileData%miuDelm
   DstInputFileData%varDelm = SrcInputFileData%varDelm
   DstInputFileData%miuP = SrcInputFileData%miuP
   DstInputFileData%varP = SrcInputFileData%varP
   DstInputFileData%Zn1 = SrcInputFileData%Zn1
   DstInputFileData%Zn2 = SrcInputFileData%Zn2
   DstInputFileData%ZonePitch = SrcInputFileData%ZonePitch
   DstInputFileData%PrflMean = SrcInputFileData%PrflMean
   DstInputFileData%PrflSig = SrcInputFileData%PrflSig
   DstInputFileData%IceStr = SrcInputFileData%IceStr
   DstInputFileData%Delmax = SrcInputFileData%Delmax
   DstInputFileData%alpha = SrcInputFileData%alpha
   DstInputFileData%Dwl = SrcInputFileData%Dwl
   DstInputFileData%Dtp = SrcInputFileData%Dtp
   DstInputFileData%hr = SrcInputFileData%hr
   DstInputFileData%mu = SrcInputFileData%mu
   DstInputFileData%sigf = SrcInputFileData%sigf
   DstInputFileData%StrLim = SrcInputFileData%StrLim
   DstInputFileData%StrRtLim = SrcInputFileData%StrRtLim
   DstInputFileData%UorD = SrcInputFileData%UorD
   DstInputFileData%Ll = SrcInputFileData%Ll
   DstInputFileData%Lw = SrcInputFileData%Lw
   DstInputFileData%Cpa = SrcInputFileData%Cpa
   DstInputFileData%dpa = SrcInputFileData%dpa
   DstInputFileData%Fdr = SrcInputFileData%Fdr
   DstInputFileData%Kic = SrcInputFileData%Kic
   DstInputFileData%FspN = SrcInputFileData%FspN
 END SUBROUTINE IceD_CopyInputFile

 SUBROUTINE IceD_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(IceD_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputFileData%LegPosX)) THEN
   DEALLOCATE(InputFileData%LegPosX)
ENDIF
IF (ALLOCATED(InputFileData%LegPosY)) THEN
   DEALLOCATE(InputFileData%LegPosY)
ENDIF
IF (ALLOCATED(InputFileData%StrWd)) THEN
   DEALLOCATE(InputFileData%StrWd)
ENDIF
 END SUBROUTINE IceD_DestroyInputFile

 SUBROUTINE IceD_PackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_InputFile),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! IceModel
  Int_BufSz  = Int_BufSz  + 1  ! IceSubModel
  Re_BufSz   = Re_BufSz   + 1  ! h
  Re_BufSz   = Re_BufSz   + 1  ! v
  Re_BufSz   = Re_BufSz   + 1  ! InitLoc
  Re_BufSz   = Re_BufSz   + 1  ! t0
  Re_BufSz   = Re_BufSz   + 1  ! rhow
  Re_BufSz   = Re_BufSz   + 1  ! rhoi
  Int_BufSz  = Int_BufSz  + 1  ! Seed1
  Int_BufSz  = Int_BufSz  + 1  ! Seed2
  Int_BufSz  = Int_BufSz  + 1  ! NumLegs
  IF ( ALLOCATED(InData%LegPosX) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LegPosX )  ! LegPosX 
  IF ( ALLOCATED(InData%LegPosY) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LegPosY )  ! LegPosY 
  IF ( ALLOCATED(InData%StrWd) )   Re_BufSz    = Re_BufSz    + SIZE( InData%StrWd )  ! StrWd 
  Re_BufSz   = Re_BufSz   + 1  ! Ikm
  Re_BufSz   = Re_BufSz   + 1  ! Ag
  Re_BufSz   = Re_BufSz   + 1  ! Qg
  Re_BufSz   = Re_BufSz   + 1  ! Rg
  Re_BufSz   = Re_BufSz   + 1  ! Tice
  Re_BufSz   = Re_BufSz   + 1  ! nu
  Re_BufSz   = Re_BufSz   + 1  ! phi
  Re_BufSz   = Re_BufSz   + 1  ! SigNm
  Re_BufSz   = Re_BufSz   + 1  ! Eice
  Re_BufSz   = Re_BufSz   + 1  ! IceStr2
  Re_BufSz   = Re_BufSz   + 1  ! Delmax2
  Re_BufSz   = Re_BufSz   + 1  ! Pitch
  Re_BufSz   = Re_BufSz   + 1  ! miuh
  Re_BufSz   = Re_BufSz   + 1  ! varh
  Re_BufSz   = Re_BufSz   + 1  ! miuv
  Re_BufSz   = Re_BufSz   + 1  ! varv
  Re_BufSz   = Re_BufSz   + 1  ! miut
  Re_BufSz   = Re_BufSz   + 1  ! miubr
  Re_BufSz   = Re_BufSz   + 1  ! varbr
  Re_BufSz   = Re_BufSz   + 1  ! miuDelm
  Re_BufSz   = Re_BufSz   + 1  ! varDelm
  Re_BufSz   = Re_BufSz   + 1  ! miuP
  Re_BufSz   = Re_BufSz   + 1  ! varP
  Int_BufSz  = Int_BufSz  + 1  ! Zn1
  Int_BufSz  = Int_BufSz  + 1  ! Zn2
  Re_BufSz   = Re_BufSz   + 1  ! ZonePitch
  Re_BufSz   = Re_BufSz   + 1  ! PrflMean
  Re_BufSz   = Re_BufSz   + 1  ! PrflSig
  Re_BufSz   = Re_BufSz   + 1  ! IceStr
  Re_BufSz   = Re_BufSz   + 1  ! Delmax
  Re_BufSz   = Re_BufSz   + 1  ! alpha
  Re_BufSz   = Re_BufSz   + 1  ! Dwl
  Re_BufSz   = Re_BufSz   + 1  ! Dtp
  Re_BufSz   = Re_BufSz   + 1  ! hr
  Re_BufSz   = Re_BufSz   + 1  ! mu
  Re_BufSz   = Re_BufSz   + 1  ! sigf
  Re_BufSz   = Re_BufSz   + 1  ! StrLim
  Re_BufSz   = Re_BufSz   + 1  ! StrRtLim
  Int_BufSz  = Int_BufSz  + 1  ! UorD
  Re_BufSz   = Re_BufSz   + 1  ! Ll
  Re_BufSz   = Re_BufSz   + 1  ! Lw
  Re_BufSz   = Re_BufSz   + 1  ! Cpa
  Re_BufSz   = Re_BufSz   + 1  ! dpa
  Re_BufSz   = Re_BufSz   + 1  ! Fdr
  Re_BufSz   = Re_BufSz   + 1  ! Kic
  Re_BufSz   = Re_BufSz   + 1  ! FspN
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IceModel )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IceSubModel )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%h )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%v )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%InitLoc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%t0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%rhow )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%rhoi )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Seed1 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Seed2 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumLegs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%LegPosX) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LegPosX))-1 ) =  PACK(InData%LegPosX ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LegPosX)
  ENDIF
  IF ( ALLOCATED(InData%LegPosY) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LegPosY))-1 ) =  PACK(InData%LegPosY ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LegPosY)
  ENDIF
  IF ( ALLOCATED(InData%StrWd) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%StrWd))-1 ) =  PACK(InData%StrWd ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%StrWd)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ikm )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ag )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Qg )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Rg )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Tice )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%nu )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%phi )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SigNm )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Eice )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%IceStr2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Delmax2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Pitch )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%miuh )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%varh )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%miuv )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%varv )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%miut )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%miubr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%varbr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%miuDelm )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%varDelm )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%miuP )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%varP )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Zn1 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Zn2 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ZonePitch )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PrflMean )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PrflSig )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%IceStr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Delmax )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%alpha )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Dwl )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Dtp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%hr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%mu )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%sigf )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%StrLim )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%StrRtLim )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UorD )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ll )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Lw )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cpa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dpa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Fdr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Kic )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%FspN )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE IceD_PackInputFile

 SUBROUTINE IceD_UnPackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_InputFile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%IceModel = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%IceSubModel = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%h = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%v = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%InitLoc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%t0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%rhow = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%rhoi = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Seed1 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Seed2 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumLegs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%LegPosX) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LegPosX,1)))
  mask1 = .TRUE.
    OutData%LegPosX = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LegPosX))-1 ),mask1,OutData%LegPosX)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LegPosX)
  ENDIF
  IF ( ALLOCATED(OutData%LegPosY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LegPosY,1)))
  mask1 = .TRUE.
    OutData%LegPosY = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LegPosY))-1 ),mask1,OutData%LegPosY)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LegPosY)
  ENDIF
  IF ( ALLOCATED(OutData%StrWd) ) THEN
  ALLOCATE(mask1(SIZE(OutData%StrWd,1)))
  mask1 = .TRUE.
    OutData%StrWd = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%StrWd))-1 ),mask1,OutData%StrWd)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%StrWd)
  ENDIF
  OutData%Ikm = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ag = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Qg = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Rg = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Tice = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%nu = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%phi = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SigNm = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Eice = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%IceStr2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Delmax2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Pitch = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%miuh = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%varh = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%miuv = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%varv = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%miut = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%miubr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%varbr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%miuDelm = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%varDelm = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%miuP = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%varP = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Zn1 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Zn2 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ZonePitch = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PrflMean = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PrflSig = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%IceStr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Delmax = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%alpha = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Dwl = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Dtp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%hr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%mu = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%sigf = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%StrLim = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%StrRtLim = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%UorD = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Ll = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Lw = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cpa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%dpa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Fdr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Kic = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%FspN = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackInputFile

 SUBROUTINE IceD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(IceD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%InputFile = SrcInitInputData%InputFile
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%MSL2SWL = SrcInitInputData%MSL2SWL
   DstInitInputData%WtrDens = SrcInitInputData%WtrDens
   DstInitInputData%gravity = SrcInitInputData%gravity
   DstInitInputData%LegNum = SrcInitInputData%LegNum
   DstInitInputData%TMax = SrcInitInputData%TMax
 END SUBROUTINE IceD_CopyInitInput

 SUBROUTINE IceD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(IceD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE IceD_DestroyInitInput

 SUBROUTINE IceD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for InputFile
!  missing buffer for RootName
  Re_BufSz   = Re_BufSz   + 1  ! MSL2SWL
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  Re_BufSz   = Re_BufSz   + 1  ! gravity
  Int_BufSz  = Int_BufSz  + 1  ! LegNum
  Db_BufSz   = Db_BufSz   + 1  ! TMax
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MSL2SWL )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%LegNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TMax )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE IceD_PackInitInput

 SUBROUTINE IceD_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MSL2SWL = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%LegNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TMax = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackInitInput

 SUBROUTINE IceD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(IceD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'IceD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'IceD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
   DstInitOutputData%numLegs = SrcInitOutputData%numLegs
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_CopyInitOutput:Ver')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE IceD_CopyInitOutput

 SUBROUTINE IceD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(IceD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
 END SUBROUTINE IceD_DestroyInitOutput

 SUBROUTINE IceD_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  Int_BufSz  = Int_BufSz  + 1  ! numLegs
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numLegs )
  Int_Xferred   = Int_Xferred   + 1
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
 END SUBROUTINE IceD_PackInitOutput

 SUBROUTINE IceD_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%numLegs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackInitOutput

 SUBROUTINE IceD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(IceD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%q = SrcContStateData%q
   DstContStateData%dqdt = SrcContStateData%dqdt
 END SUBROUTINE IceD_CopyContState

 SUBROUTINE IceD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(IceD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE IceD_DestroyContState

 SUBROUTINE IceD_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! q
  Re_BufSz   = Re_BufSz   + 1  ! dqdt
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%q )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dqdt )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE IceD_PackContState

 SUBROUTINE IceD_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%q = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%dqdt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackContState

 SUBROUTINE IceD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(IceD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE IceD_CopyDiscState

 SUBROUTINE IceD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(IceD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE IceD_DestroyDiscState

 SUBROUTINE IceD_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE IceD_PackDiscState

 SUBROUTINE IceD_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackDiscState

 SUBROUTINE IceD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(IceD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE IceD_CopyConstrState

 SUBROUTINE IceD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(IceD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE IceD_DestroyConstrState

 SUBROUTINE IceD_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE IceD_PackConstrState

 SUBROUTINE IceD_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackConstrState

 SUBROUTINE IceD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(IceD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%xdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%xdot,1)
   i1_u = UBOUND(SrcOtherStateData%xdot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%xdot)) THEN 
      ALLOCATE(DstOtherStateData%xdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%xdot.', ErrStat, ErrMsg,'IceD_CopyOtherState')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%xdot,1), UBOUND(SrcOtherStateData%xdot,1)
      CALL IceD_CopyContState( SrcOtherStateData%xdot(i1), DstOtherStateData%xdot(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_CopyOtherState:xdot(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstOtherStateData%n = SrcOtherStateData%n
   DstOtherStateData%IceTthNo2 = SrcOtherStateData%IceTthNo2
IF (ALLOCATED(SrcOtherStateData%Nc)) THEN
   i1_l = LBOUND(SrcOtherStateData%Nc,1)
   i1_u = UBOUND(SrcOtherStateData%Nc,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%Nc)) THEN 
      ALLOCATE(DstOtherStateData%Nc(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Nc.', ErrStat, ErrMsg,'IceD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%Nc = SrcOtherStateData%Nc
ENDIF
IF (ALLOCATED(SrcOtherStateData%Psum)) THEN
   i1_l = LBOUND(SrcOtherStateData%Psum,1)
   i1_u = UBOUND(SrcOtherStateData%Psum,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%Psum)) THEN 
      ALLOCATE(DstOtherStateData%Psum(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%Psum.', ErrStat, ErrMsg,'IceD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%Psum = SrcOtherStateData%Psum
ENDIF
IF (ALLOCATED(SrcOtherStateData%IceTthNo)) THEN
   i1_l = LBOUND(SrcOtherStateData%IceTthNo,1)
   i1_u = UBOUND(SrcOtherStateData%IceTthNo,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%IceTthNo)) THEN 
      ALLOCATE(DstOtherStateData%IceTthNo(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%IceTthNo.', ErrStat, ErrMsg,'IceD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%IceTthNo = SrcOtherStateData%IceTthNo
ENDIF
   DstOtherStateData%Beta = SrcOtherStateData%Beta
   DstOtherStateData%Tinit = SrcOtherStateData%Tinit
   DstOtherStateData%Splitf = SrcOtherStateData%Splitf
   DstOtherStateData%dxc = SrcOtherStateData%dxc
 END SUBROUTINE IceD_CopyOtherState

 SUBROUTINE IceD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(IceD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%xdot)) THEN
DO i1 = LBOUND(OtherStateData%xdot,1), UBOUND(OtherStateData%xdot,1)
  CALL IceD_DestroyContState( OtherStateData%xdot(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%xdot)
ENDIF
IF (ALLOCATED(OtherStateData%Nc)) THEN
   DEALLOCATE(OtherStateData%Nc)
ENDIF
IF (ALLOCATED(OtherStateData%Psum)) THEN
   DEALLOCATE(OtherStateData%Psum)
ENDIF
IF (ALLOCATED(OtherStateData%IceTthNo)) THEN
   DEALLOCATE(OtherStateData%IceTthNo)
ENDIF
 END SUBROUTINE IceD_DestroyOtherState

 SUBROUTINE IceD_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_xdot_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(InData%xdot,1), UBOUND(InData%xdot,1)
  CALL IceD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Db_xdot_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Int_xdot_Buf))Int_BufSz = Int_BufSz + SIZE( Int_xdot_Buf ) ! xdot
  IF(ALLOCATED(Re_xdot_Buf))  DEALLOCATE(Re_xdot_Buf)
  IF(ALLOCATED(Db_xdot_Buf))  DEALLOCATE(Db_xdot_Buf)
  IF(ALLOCATED(Int_xdot_Buf)) DEALLOCATE(Int_xdot_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! n
  Int_BufSz  = Int_BufSz  + 1  ! IceTthNo2
  IF ( ALLOCATED(InData%Nc) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Nc )  ! Nc 
  IF ( ALLOCATED(InData%Psum) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Psum )  ! Psum 
  IF ( ALLOCATED(InData%IceTthNo) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IceTthNo )  ! IceTthNo 
  Re_BufSz   = Re_BufSz   + 1  ! Beta
  Db_BufSz   = Db_BufSz   + 1  ! Tinit
  Int_BufSz  = Int_BufSz  + 1  ! Splitf
  Re_BufSz   = Re_BufSz   + 1  ! dxc
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
DO i1 = LBOUND(InData%xdot,1), UBOUND(InData%xdot,1)
  CALL IceD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, OnlySize ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 ) = Re_xdot_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 ) = Db_xdot_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 ) = Int_xdot_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  IF( ALLOCATED(Re_xdot_Buf) )  DEALLOCATE(Re_xdot_Buf)
  IF( ALLOCATED(Db_xdot_Buf) )  DEALLOCATE(Db_xdot_Buf)
  IF( ALLOCATED(Int_xdot_Buf) ) DEALLOCATE(Int_xdot_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%n )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IceTthNo2 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Nc) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Nc))-1 ) = PACK(InData%Nc ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Nc)
  ENDIF
  IF ( ALLOCATED(InData%Psum) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Psum))-1 ) =  PACK(InData%Psum ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Psum)
  ENDIF
  IF ( ALLOCATED(InData%IceTthNo) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IceTthNo))-1 ) = PACK(InData%IceTthNo ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IceTthNo)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Beta )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%Tinit )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Splitf )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dxc )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE IceD_PackOtherState

 SUBROUTINE IceD_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_xdot_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(OutData%xdot,1), UBOUND(OutData%xdot,1)
 ! first call IceD_PackContState to get correctly sized buffers for unpacking
  CALL IceD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    Re_xdot_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    Db_xdot_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    Int_xdot_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  CALL IceD_UnPackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg ) ! xdot 
ENDDO
  OutData%n = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%IceTthNo2 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Nc) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Nc,1)))
  mask1 = .TRUE.
    OutData%Nc = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Nc))-1 ),mask1,OutData%Nc)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Nc)
  ENDIF
  IF ( ALLOCATED(OutData%Psum) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Psum,1)))
  mask1 = .TRUE.
    OutData%Psum = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Psum))-1 ),mask1,OutData%Psum)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Psum)
  ENDIF
  IF ( ALLOCATED(OutData%IceTthNo) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IceTthNo,1)))
  mask1 = .TRUE.
    OutData%IceTthNo = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IceTthNo))-1 ),mask1,OutData%IceTthNo)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IceTthNo)
  ENDIF
  OutData%Beta = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Tinit = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%Splitf = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%dxc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackOtherState

 SUBROUTINE IceD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(IceD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%h = SrcParamData%h
   DstParamData%v = SrcParamData%v
   DstParamData%t0 = SrcParamData%t0
   DstParamData%StrWd = SrcParamData%StrWd
   DstParamData%dt = SrcParamData%dt
   DstParamData%InitLoc = SrcParamData%InitLoc
   DstParamData%tolerance = SrcParamData%tolerance
   DstParamData%Tmax = SrcParamData%Tmax
   DstParamData%verif = SrcParamData%verif
   DstParamData%ModNo = SrcParamData%ModNo
   DstParamData%SubModNo = SrcParamData%SubModNo
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%method = SrcParamData%method
   DstParamData%TmStep = SrcParamData%TmStep
IF (ALLOCATED(SrcParamData%OutName)) THEN
   i1_l = LBOUND(SrcParamData%OutName,1)
   i1_u = UBOUND(SrcParamData%OutName,1)
   IF (.NOT. ALLOCATED(DstParamData%OutName)) THEN 
      ALLOCATE(DstParamData%OutName(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutName.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%OutName = SrcParamData%OutName
ENDIF
IF (ALLOCATED(SrcParamData%OutUnit)) THEN
   i1_l = LBOUND(SrcParamData%OutUnit,1)
   i1_u = UBOUND(SrcParamData%OutUnit,1)
   IF (.NOT. ALLOCATED(DstParamData%OutUnit)) THEN 
      ALLOCATE(DstParamData%OutUnit(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutUnit.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%OutUnit = SrcParamData%OutUnit
ENDIF
   DstParamData%RootName = SrcParamData%RootName
   DstParamData%tm1a = SrcParamData%tm1a
   DstParamData%tm1b = SrcParamData%tm1b
   DstParamData%tm1c = SrcParamData%tm1c
   DstParamData%Fmax1a = SrcParamData%Fmax1a
   DstParamData%Fmax1b = SrcParamData%Fmax1b
   DstParamData%Fmax1c = SrcParamData%Fmax1c
   DstParamData%Ikm = SrcParamData%Ikm
   DstParamData%Cstr = SrcParamData%Cstr
   DstParamData%EiPa = SrcParamData%EiPa
   DstParamData%Delmax2 = SrcParamData%Delmax2
   DstParamData%Pitch = SrcParamData%Pitch
   DstParamData%Kice2 = SrcParamData%Kice2
IF (ALLOCATED(SrcParamData%rdmFm)) THEN
   i1_l = LBOUND(SrcParamData%rdmFm,1)
   i1_u = UBOUND(SrcParamData%rdmFm,1)
   IF (.NOT. ALLOCATED(DstParamData%rdmFm)) THEN 
      ALLOCATE(DstParamData%rdmFm(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%rdmFm.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%rdmFm = SrcParamData%rdmFm
ENDIF
IF (ALLOCATED(SrcParamData%rdmt0)) THEN
   i1_l = LBOUND(SrcParamData%rdmt0,1)
   i1_u = UBOUND(SrcParamData%rdmt0,1)
   IF (.NOT. ALLOCATED(DstParamData%rdmt0)) THEN 
      ALLOCATE(DstParamData%rdmt0(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%rdmt0.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%rdmt0 = SrcParamData%rdmt0
ENDIF
IF (ALLOCATED(SrcParamData%rdmtm)) THEN
   i1_l = LBOUND(SrcParamData%rdmtm,1)
   i1_u = UBOUND(SrcParamData%rdmtm,1)
   IF (.NOT. ALLOCATED(DstParamData%rdmtm)) THEN 
      ALLOCATE(DstParamData%rdmtm(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%rdmtm.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%rdmtm = SrcParamData%rdmtm
ENDIF
IF (ALLOCATED(SrcParamData%rdmDm)) THEN
   i1_l = LBOUND(SrcParamData%rdmDm,1)
   i1_u = UBOUND(SrcParamData%rdmDm,1)
   IF (.NOT. ALLOCATED(DstParamData%rdmDm)) THEN 
      ALLOCATE(DstParamData%rdmDm(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%rdmDm.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%rdmDm = SrcParamData%rdmDm
ENDIF
IF (ALLOCATED(SrcParamData%rdmP)) THEN
   i1_l = LBOUND(SrcParamData%rdmP,1)
   i1_u = UBOUND(SrcParamData%rdmP,1)
   IF (.NOT. ALLOCATED(DstParamData%rdmP)) THEN 
      ALLOCATE(DstParamData%rdmP(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%rdmP.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%rdmP = SrcParamData%rdmP
ENDIF
IF (ALLOCATED(SrcParamData%rdmKi)) THEN
   i1_l = LBOUND(SrcParamData%rdmKi,1)
   i1_u = UBOUND(SrcParamData%rdmKi,1)
   IF (.NOT. ALLOCATED(DstParamData%rdmKi)) THEN 
      ALLOCATE(DstParamData%rdmKi(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%rdmKi.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%rdmKi = SrcParamData%rdmKi
ENDIF
   DstParamData%ZonePitch = SrcParamData%ZonePitch
   DstParamData%Kice = SrcParamData%Kice
   DstParamData%Delmax = SrcParamData%Delmax
IF (ALLOCATED(SrcParamData%Y0)) THEN
   i1_l = LBOUND(SrcParamData%Y0,1)
   i1_u = UBOUND(SrcParamData%Y0,1)
   IF (.NOT. ALLOCATED(DstParamData%Y0)) THEN 
      ALLOCATE(DstParamData%Y0(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Y0.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%Y0 = SrcParamData%Y0
ENDIF
IF (ALLOCATED(SrcParamData%ContPrfl)) THEN
   i1_l = LBOUND(SrcParamData%ContPrfl,1)
   i1_u = UBOUND(SrcParamData%ContPrfl,1)
   IF (.NOT. ALLOCATED(DstParamData%ContPrfl)) THEN 
      ALLOCATE(DstParamData%ContPrfl(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ContPrfl.', ErrStat, ErrMsg,'IceD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%ContPrfl = SrcParamData%ContPrfl
ENDIF
   DstParamData%Zn = SrcParamData%Zn
   DstParamData%rhoi = SrcParamData%rhoi
   DstParamData%rhow = SrcParamData%rhow
   DstParamData%alphaR = SrcParamData%alphaR
   DstParamData%Dwl = SrcParamData%Dwl
   DstParamData%Zr = SrcParamData%Zr
   DstParamData%RHbr = SrcParamData%RHbr
   DstParamData%RVbr = SrcParamData%RVbr
   DstParamData%Lbr = SrcParamData%Lbr
   DstParamData%LovR = SrcParamData%LovR
   DstParamData%mu = SrcParamData%mu
   DstParamData%Wri = SrcParamData%Wri
   DstParamData%WL = SrcParamData%WL
   DstParamData%Cpa = SrcParamData%Cpa
   DstParamData%dpa = SrcParamData%dpa
   DstParamData%FdrN = SrcParamData%FdrN
   DstParamData%Mice = SrcParamData%Mice
   DstParamData%Fsp = SrcParamData%Fsp
 END SUBROUTINE IceD_CopyParam

 SUBROUTINE IceD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(IceD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%OutName)) THEN
   DEALLOCATE(ParamData%OutName)
ENDIF
IF (ALLOCATED(ParamData%OutUnit)) THEN
   DEALLOCATE(ParamData%OutUnit)
ENDIF
IF (ALLOCATED(ParamData%rdmFm)) THEN
   DEALLOCATE(ParamData%rdmFm)
ENDIF
IF (ALLOCATED(ParamData%rdmt0)) THEN
   DEALLOCATE(ParamData%rdmt0)
ENDIF
IF (ALLOCATED(ParamData%rdmtm)) THEN
   DEALLOCATE(ParamData%rdmtm)
ENDIF
IF (ALLOCATED(ParamData%rdmDm)) THEN
   DEALLOCATE(ParamData%rdmDm)
ENDIF
IF (ALLOCATED(ParamData%rdmP)) THEN
   DEALLOCATE(ParamData%rdmP)
ENDIF
IF (ALLOCATED(ParamData%rdmKi)) THEN
   DEALLOCATE(ParamData%rdmKi)
ENDIF
IF (ALLOCATED(ParamData%Y0)) THEN
   DEALLOCATE(ParamData%Y0)
ENDIF
IF (ALLOCATED(ParamData%ContPrfl)) THEN
   DEALLOCATE(ParamData%ContPrfl)
ENDIF
 END SUBROUTINE IceD_DestroyParam

 SUBROUTINE IceD_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! h
  Re_BufSz   = Re_BufSz   + 1  ! v
  Re_BufSz   = Re_BufSz   + 1  ! t0
  Re_BufSz   = Re_BufSz   + 1  ! StrWd
  Re_BufSz   = Re_BufSz   + 1  ! dt
  Re_BufSz   = Re_BufSz   + 1  ! InitLoc
  Re_BufSz   = Re_BufSz   + 1  ! tolerance
  Re_BufSz   = Re_BufSz   + 1  ! Tmax
  Int_BufSz  = Int_BufSz  + 1  ! verif
  Int_BufSz  = Int_BufSz  + 1  ! ModNo
  Int_BufSz  = Int_BufSz  + 1  ! SubModNo
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz  = Int_BufSz  + 1  ! method
  Int_BufSz  = Int_BufSz  + 1  ! TmStep
!  missing buffer for OutName
!  missing buffer for OutUnit
!  missing buffer for RootName
  Re_BufSz   = Re_BufSz   + 1  ! tm1a
  Re_BufSz   = Re_BufSz   + 1  ! tm1b
  Re_BufSz   = Re_BufSz   + 1  ! tm1c
  Re_BufSz   = Re_BufSz   + 1  ! Fmax1a
  Re_BufSz   = Re_BufSz   + 1  ! Fmax1b
  Re_BufSz   = Re_BufSz   + 1  ! Fmax1c
  Re_BufSz   = Re_BufSz   + 1  ! Ikm
  Re_BufSz   = Re_BufSz   + 1  ! Cstr
  Re_BufSz   = Re_BufSz   + 1  ! EiPa
  Re_BufSz   = Re_BufSz   + 1  ! Delmax2
  Re_BufSz   = Re_BufSz   + 1  ! Pitch
  Re_BufSz   = Re_BufSz   + 1  ! Kice2
  IF ( ALLOCATED(InData%rdmFm) )   Re_BufSz    = Re_BufSz    + SIZE( InData%rdmFm )  ! rdmFm 
  IF ( ALLOCATED(InData%rdmt0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%rdmt0 )  ! rdmt0 
  IF ( ALLOCATED(InData%rdmtm) )   Re_BufSz    = Re_BufSz    + SIZE( InData%rdmtm )  ! rdmtm 
  IF ( ALLOCATED(InData%rdmDm) )   Re_BufSz    = Re_BufSz    + SIZE( InData%rdmDm )  ! rdmDm 
  IF ( ALLOCATED(InData%rdmP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%rdmP )  ! rdmP 
  IF ( ALLOCATED(InData%rdmKi) )   Re_BufSz    = Re_BufSz    + SIZE( InData%rdmKi )  ! rdmKi 
  Re_BufSz   = Re_BufSz   + 1  ! ZonePitch
  Re_BufSz   = Re_BufSz   + 1  ! Kice
  Re_BufSz   = Re_BufSz   + 1  ! Delmax
  IF ( ALLOCATED(InData%Y0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Y0 )  ! Y0 
  IF ( ALLOCATED(InData%ContPrfl) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ContPrfl )  ! ContPrfl 
  Int_BufSz  = Int_BufSz  + 1  ! Zn
  Re_BufSz   = Re_BufSz   + 1  ! rhoi
  Re_BufSz   = Re_BufSz   + 1  ! rhow
  Re_BufSz   = Re_BufSz   + 1  ! alphaR
  Re_BufSz   = Re_BufSz   + 1  ! Dwl
  Re_BufSz   = Re_BufSz   + 1  ! Zr
  Re_BufSz   = Re_BufSz   + 1  ! RHbr
  Re_BufSz   = Re_BufSz   + 1  ! RVbr
  Re_BufSz   = Re_BufSz   + 1  ! Lbr
  Re_BufSz   = Re_BufSz   + 1  ! LovR
  Re_BufSz   = Re_BufSz   + 1  ! mu
  Re_BufSz   = Re_BufSz   + 1  ! Wri
  Re_BufSz   = Re_BufSz   + 1  ! WL
  Re_BufSz   = Re_BufSz   + 1  ! Cpa
  Re_BufSz   = Re_BufSz   + 1  ! dpa
  Re_BufSz   = Re_BufSz   + 1  ! FdrN
  Re_BufSz   = Re_BufSz   + 1  ! Mice
  Re_BufSz   = Re_BufSz   + 1  ! Fsp
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%h )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%v )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%t0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%StrWd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%InitLoc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%tolerance )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Tmax )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%verif )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ModNo )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%SubModNo )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%method )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TmStep )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%tm1a )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%tm1b )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%tm1c )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Fmax1a )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Fmax1b )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Fmax1c )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ikm )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cstr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%EiPa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Delmax2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Pitch )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Kice2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%rdmFm) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rdmFm))-1 ) =  PACK(InData%rdmFm ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rdmFm)
  ENDIF
  IF ( ALLOCATED(InData%rdmt0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rdmt0))-1 ) =  PACK(InData%rdmt0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rdmt0)
  ENDIF
  IF ( ALLOCATED(InData%rdmtm) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rdmtm))-1 ) =  PACK(InData%rdmtm ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rdmtm)
  ENDIF
  IF ( ALLOCATED(InData%rdmDm) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rdmDm))-1 ) =  PACK(InData%rdmDm ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rdmDm)
  ENDIF
  IF ( ALLOCATED(InData%rdmP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rdmP))-1 ) =  PACK(InData%rdmP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rdmP)
  ENDIF
  IF ( ALLOCATED(InData%rdmKi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rdmKi))-1 ) =  PACK(InData%rdmKi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rdmKi)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ZonePitch )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Kice )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Delmax )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%Y0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Y0))-1 ) =  PACK(InData%Y0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Y0)
  ENDIF
  IF ( ALLOCATED(InData%ContPrfl) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ContPrfl))-1 ) =  PACK(InData%ContPrfl ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ContPrfl)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Zn )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%rhoi )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%rhow )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%alphaR )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Dwl )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Zr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%RHbr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%RVbr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Lbr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%LovR )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%mu )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Wri )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WL )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cpa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dpa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%FdrN )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Mice )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Fsp )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE IceD_PackParam

 SUBROUTINE IceD_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%h = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%v = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%t0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%StrWd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%dt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%InitLoc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%tolerance = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Tmax = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%verif = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ModNo = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%SubModNo = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%method = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TmStep = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%tm1a = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%tm1b = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%tm1c = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Fmax1a = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Fmax1b = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Fmax1c = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ikm = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cstr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%EiPa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Delmax2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Pitch = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Kice2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%rdmFm) ) THEN
  ALLOCATE(mask1(SIZE(OutData%rdmFm,1)))
  mask1 = .TRUE.
    OutData%rdmFm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rdmFm))-1 ),mask1,OutData%rdmFm)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rdmFm)
  ENDIF
  IF ( ALLOCATED(OutData%rdmt0) ) THEN
  ALLOCATE(mask1(SIZE(OutData%rdmt0,1)))
  mask1 = .TRUE.
    OutData%rdmt0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rdmt0))-1 ),mask1,OutData%rdmt0)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rdmt0)
  ENDIF
  IF ( ALLOCATED(OutData%rdmtm) ) THEN
  ALLOCATE(mask1(SIZE(OutData%rdmtm,1)))
  mask1 = .TRUE.
    OutData%rdmtm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rdmtm))-1 ),mask1,OutData%rdmtm)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rdmtm)
  ENDIF
  IF ( ALLOCATED(OutData%rdmDm) ) THEN
  ALLOCATE(mask1(SIZE(OutData%rdmDm,1)))
  mask1 = .TRUE.
    OutData%rdmDm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rdmDm))-1 ),mask1,OutData%rdmDm)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rdmDm)
  ENDIF
  IF ( ALLOCATED(OutData%rdmP) ) THEN
  ALLOCATE(mask1(SIZE(OutData%rdmP,1)))
  mask1 = .TRUE.
    OutData%rdmP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rdmP))-1 ),mask1,OutData%rdmP)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rdmP)
  ENDIF
  IF ( ALLOCATED(OutData%rdmKi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%rdmKi,1)))
  mask1 = .TRUE.
    OutData%rdmKi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rdmKi))-1 ),mask1,OutData%rdmKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rdmKi)
  ENDIF
  OutData%ZonePitch = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Kice = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Delmax = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%Y0) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Y0,1)))
  mask1 = .TRUE.
    OutData%Y0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Y0))-1 ),mask1,OutData%Y0)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Y0)
  ENDIF
  IF ( ALLOCATED(OutData%ContPrfl) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ContPrfl,1)))
  mask1 = .TRUE.
    OutData%ContPrfl = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ContPrfl))-1 ),mask1,OutData%ContPrfl)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ContPrfl)
  ENDIF
  OutData%Zn = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%rhoi = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%rhow = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%alphaR = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Dwl = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Zr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%RHbr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%RVbr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Lbr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%LovR = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%mu = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Wri = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WL = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cpa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%dpa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%FdrN = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Mice = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Fsp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackParam

 SUBROUTINE IceD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(IceD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInputData%PointMesh, DstInputData%PointMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_CopyInput:PointMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE IceD_CopyInput

 SUBROUTINE IceD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(IceD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%PointMesh, ErrStat, ErrMsg )
 END SUBROUTINE IceD_DestroyInput

 SUBROUTINE IceD_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PointMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PointMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PointMesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PointMesh, Re_PointMesh_Buf, Db_PointMesh_Buf, Int_PointMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! PointMesh 
  IF(ALLOCATED(Re_PointMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PointMesh_Buf  ) ! PointMesh
  IF(ALLOCATED(Db_PointMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PointMesh_Buf  ) ! PointMesh
  IF(ALLOCATED(Int_PointMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PointMesh_Buf ) ! PointMesh
  IF(ALLOCATED(Re_PointMesh_Buf))  DEALLOCATE(Re_PointMesh_Buf)
  IF(ALLOCATED(Db_PointMesh_Buf))  DEALLOCATE(Db_PointMesh_Buf)
  IF(ALLOCATED(Int_PointMesh_Buf)) DEALLOCATE(Int_PointMesh_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%PointMesh, Re_PointMesh_Buf, Db_PointMesh_Buf, Int_PointMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! PointMesh 
  IF(ALLOCATED(Re_PointMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PointMesh_Buf)-1 ) = Re_PointMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PointMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_PointMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PointMesh_Buf)-1 ) = Db_PointMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PointMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_PointMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PointMesh_Buf)-1 ) = Int_PointMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PointMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_PointMesh_Buf) )  DEALLOCATE(Re_PointMesh_Buf)
  IF( ALLOCATED(Db_PointMesh_Buf) )  DEALLOCATE(Db_PointMesh_Buf)
  IF( ALLOCATED(Int_PointMesh_Buf) ) DEALLOCATE(Int_PointMesh_Buf)
 END SUBROUTINE IceD_PackInput

 SUBROUTINE IceD_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PointMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PointMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PointMesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PointMesh, Re_PointMesh_Buf, Db_PointMesh_Buf, Int_PointMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! PointMesh 
  IF(ALLOCATED(Re_PointMesh_Buf)) THEN
    Re_PointMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PointMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PointMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_PointMesh_Buf)) THEN
    Db_PointMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PointMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PointMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_PointMesh_Buf)) THEN
    Int_PointMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PointMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PointMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PointMesh, Re_PointMesh_Buf, Db_PointMesh_Buf, Int_PointMesh_Buf, ErrStat, ErrMsg ) ! PointMesh 
  IF( ALLOCATED(Re_PointMesh_Buf) )  DEALLOCATE(Re_PointMesh_Buf)
  IF( ALLOCATED(Db_PointMesh_Buf) )  DEALLOCATE(Db_PointMesh_Buf)
  IF( ALLOCATED(Int_PointMesh_Buf) ) DEALLOCATE(Int_PointMesh_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackInput

 SUBROUTINE IceD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceD_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(IceD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcOutputData%PointMesh, DstOutputData%PointMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_CopyOutput:PointMesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'IceD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE IceD_CopyOutput

 SUBROUTINE IceD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(IceD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%PointMesh, ErrStat, ErrMsg )
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE IceD_DestroyOutput

 SUBROUTINE IceD_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IceD_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PointMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PointMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PointMesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PointMesh, Re_PointMesh_Buf, Db_PointMesh_Buf, Int_PointMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! PointMesh 
  IF(ALLOCATED(Re_PointMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PointMesh_Buf  ) ! PointMesh
  IF(ALLOCATED(Db_PointMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PointMesh_Buf  ) ! PointMesh
  IF(ALLOCATED(Int_PointMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PointMesh_Buf ) ! PointMesh
  IF(ALLOCATED(Re_PointMesh_Buf))  DEALLOCATE(Re_PointMesh_Buf)
  IF(ALLOCATED(Db_PointMesh_Buf))  DEALLOCATE(Db_PointMesh_Buf)
  IF(ALLOCATED(Int_PointMesh_Buf)) DEALLOCATE(Int_PointMesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%PointMesh, Re_PointMesh_Buf, Db_PointMesh_Buf, Int_PointMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! PointMesh 
  IF(ALLOCATED(Re_PointMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PointMesh_Buf)-1 ) = Re_PointMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PointMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_PointMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PointMesh_Buf)-1 ) = Db_PointMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PointMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_PointMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PointMesh_Buf)-1 ) = Int_PointMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PointMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_PointMesh_Buf) )  DEALLOCATE(Re_PointMesh_Buf)
  IF( ALLOCATED(Db_PointMesh_Buf) )  DEALLOCATE(Db_PointMesh_Buf)
  IF( ALLOCATED(Int_PointMesh_Buf) ) DEALLOCATE(Int_PointMesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE IceD_PackOutput

 SUBROUTINE IceD_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IceD_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PointMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PointMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PointMesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PointMesh, Re_PointMesh_Buf, Db_PointMesh_Buf, Int_PointMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! PointMesh 
  IF(ALLOCATED(Re_PointMesh_Buf)) THEN
    Re_PointMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PointMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PointMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_PointMesh_Buf)) THEN
    Db_PointMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PointMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PointMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_PointMesh_Buf)) THEN
    Int_PointMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PointMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PointMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PointMesh, Re_PointMesh_Buf, Db_PointMesh_Buf, Int_PointMesh_Buf, ErrStat, ErrMsg ) ! PointMesh 
  IF( ALLOCATED(Re_PointMesh_Buf) )  DEALLOCATE(Re_PointMesh_Buf)
  IF( ALLOCATED(Db_PointMesh_Buf) )  DEALLOCATE(Db_PointMesh_Buf)
  IF( ALLOCATED(Int_PointMesh_Buf) ) DEALLOCATE(Int_PointMesh_Buf)
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE IceD_UnPackOutput


 SUBROUTINE IceD_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(IceD_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(IceD_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in IceD_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%PointMesh, u_out%PointMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_Input_ExtrapInterp:%PointMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%PointMesh, u(2)%PointMesh, tin, u_out%PointMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_Input_ExtrapInterp:%PointMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%PointMesh, u(2)%PointMesh, u(3)%PointMesh, tin, u_out%PointMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_Input_ExtrapInterp:%PointMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in IceD_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE IceD_Input_ExtrapInterp


 SUBROUTINE IceD_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(IceD_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(IceD_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in IceD_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%PointMesh, u_out%PointMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_Output_ExtrapInterp:%PointMesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%PointMesh, u(2)%PointMesh, tin, u_out%PointMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_Output_ExtrapInterp:%PointMesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in IceD_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%PointMesh, u(2)%PointMesh, u(3)%PointMesh, tin, u_out%PointMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'IceD_Output_ExtrapInterp:%PointMesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in IceD_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE IceD_Output_ExtrapInterp

END MODULE IceDyn_Types
!ENDOFREGISTRYGENERATEDFILE
