char *template_data[] = {
"!..................................................................................................................................",
"! LICENSING",
"! Copyright (C) 2012 - 2015 National Renewable Energy Laboratory",
"!",
"!    This file is part of ModuleName.",
"!",
"! Licensed under the Apache License, Version 2.0 (the \"License\");",
"! you may not use this file except in compliance with the License.",
"! You may obtain a copy of the License at",
"!",
"! http://www.apache.org/licenses/LICENSE-2.0",
"!",
"! Unless required by applicable law or agreed to in writing, software",
"! distributed under the License is distributed on an \"AS IS\" BASIS,",
"! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
"! See the License for the specific language governing permissions and",
"! limitations under the License.",
"!",
"!**********************************************************************************************************************************",
"MODULE ModuleName",
"",
"   USE ModuleName_Types",
"   USE NWTC_Library",
"",
"   IMPLICIT NONE",
"",
"   PRIVATE",
"",
"!   INTEGER(IntKi), PARAMETER            :: DataFormatID = 1   ! Update this value if the data types change (used in ModName_Pack)",
"   TYPE(ProgDesc), PARAMETER            :: ModName_Ver = ProgDesc( 'ModuleName', 'v1.00.03', '07-December-2012' )",
"",
"",
"      ! ..... Public Subroutines ...................................................................................................",
"",
"   PUBLIC :: ModName_Init                           ! Initialization routine",
"   PUBLIC :: ModName_End                            ! Ending routine (includes clean up)",
"",
"   PUBLIC :: ModName_UpdateStates                   ! Loose coupling routine for solving for constraint states, integrating",
"                                                    !   continuous states, and updating discrete states",
"   PUBLIC :: ModName_CalcOutput                     ! Routine for computing outputs",
"",
"   PUBLIC :: ModName_CalcConstrStateResidual        ! Tight coupling routine for returning the constraint state residual",
"   PUBLIC :: ModName_CalcContStateDeriv             ! Tight coupling routine for computing derivatives of continuous states",
"   PUBLIC :: ModName_UpdateDiscState                ! Tight coupling routine for updating discrete states",
"",
#ifdef JACOBIANS
"   PUBLIC :: ModName_JacobianPInput                 ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-",
"                                                    !   (Xd), and constraint-state (Z) equations all with respect to the inputs (u)",
"   PUBLIC :: ModName_JacobianPContState             ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-",
"                                                    !   (Xd), and constraint-state (Z) equations all with respect to the continuous",
"                                                    !   states (x)",
"   PUBLIC :: ModName_JacobianPDiscState             ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-",
"                                                    !   (Xd), and constraint-state (Z) equations all with respect to the discrete",
"                                                    !   states (xd)",
"   PUBLIC :: ModName_JacobianPConstrState           ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-",
"                                                    !   (Xd), and constraint-state (Z) equations all with respect to the constraint",
"                                                    !   states (z)",
#endif
"",
"! Note that the following routines will be updated with new definitions of arrays returned (no longer one-byte arrays)",
"!   PUBLIC :: ModName_Pack                           ! Routine to pack (save) data into one array of bytes",
"!   PUBLIC :: ModName_Unpack                         ! Routine to unpack an array of bytes into data structures usable by the module",
"",
"CONTAINS",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_Init( InitInp, u, p, x, xd, z, OtherState, y, Interval, InitOut, ErrStat, ErrMsg )",
"! This routine is called at the start of the simulation to perform initialization steps.",
"! The parameters are set here and not changed during the simulation.",
"! The initial states and initial guess for the input are defined.",
"!..................................................................................................................................",
"",
"      TYPE(ModName_InitInputType),       INTENT(IN   )  :: InitInp     ! Input data for initialization routine",
"      TYPE(ModName_InputType),           INTENT(  OUT)  :: u           ! An initial guess for the input; input mesh must be defined",
"      TYPE(ModName_ParameterType),       INTENT(  OUT)  :: p           ! Parameters",
"      TYPE(ModName_ContinuousStateType), INTENT(  OUT)  :: x           ! Initial continuous states",
"      TYPE(ModName_DiscreteStateType),   INTENT(  OUT)  :: xd          ! Initial discrete states",
"      TYPE(ModName_ConstraintStateType), INTENT(  OUT)  :: z           ! Initial guess of the constraint states",
"      TYPE(ModName_OtherStateType),      INTENT(  OUT)  :: OtherState  ! Initial other/optimization states",
"      TYPE(ModName_OutputType),          INTENT(  OUT)  :: y           ! Initial system outputs (outputs are not calculated;",
"                                                                       !   only the output mesh is initialized)",
"      REAL(DbKi),                        INTENT(INOUT)  :: Interval    ! Coupling interval in seconds: the rate that",
"                                                                       !   (1) ModName_UpdateStates() is called in loose coupling &",
"                                                                       !   (2) ModName_UpdateDiscState() is called in tight coupling.",
"                                                                       !   Input is the suggested time from the glue code;",
"                                                                       !   Output is the actual coupling interval that will be used",
"                                                                       !   by the glue code.",
"      TYPE(ModName_InitOutputType),      INTENT(  OUT)  :: InitOut     ! Output for initialization routine",
"      INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     ! Error status of the operation",
"      CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"         ! Initialize the NWTC Subroutine Library",
"",
"      CALL NWTC_Init( )",
"",
"         ! Display the module information",
"",
"      CALL DispNVD( ModName_Ver )",
"",
"",
"         ! Define parameters here:",
"",
"      p%DT  = Interval",
"",
"",
"         ! Define initial system states here:",
"",
"!     x%DummyContState           = 0",
"!     xd%DummyDiscState          = 0",
"!     z%DummyConstrState         = 0",
"!     OtherState%DummyOtherState = 0",
"",
"",
"         ! Define initial guess for the system inputs here:",
"",
"!     u%DummyInput = 0",
"",
"",
"         ! Define system output initializations (set up mesh) here:",
"",
"!     y%DummyOutput = 0",
"!     y%WriteOutput = 0",
"",
"",
"         ! Define initialization-routine output here:",
"",
"!     InitOut%WriteOutputHdr = (/ 'Time', 'Column2' /)",
"!     InitOut%WriteOutputUnt = (/ '(s)',  '(-)'     /)",
"",
"",
"         ! If you want to choose your own rate instead of using what the glue code suggests, tell the glue code the rate at which",
"         !   this module must be called here:",
"",
"       !Interval = p%DT",
"",
"",
"END SUBROUTINE ModName_Init",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_End( u, p, x, xd, z, OtherState, y, ErrStat, ErrMsg )",
"! This routine is called at the end of the simulation.",
"!..................................................................................................................................",
"",
"      TYPE(ModName_InputType),           INTENT(INOUT)  :: u           ! System inputs",
"      TYPE(ModName_ParameterType),       INTENT(INOUT)  :: p           ! Parameters",
"      TYPE(ModName_ContinuousStateType), INTENT(INOUT)  :: x           ! Continuous states",
"      TYPE(ModName_DiscreteStateType),   INTENT(INOUT)  :: xd          ! Discrete states",
"      TYPE(ModName_ConstraintStateType), INTENT(INOUT)  :: z           ! Constraint states",
"      TYPE(ModName_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states",
"      TYPE(ModName_OutputType),          INTENT(INOUT)  :: y           ! System outputs",
"      INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     ! Error status of the operation",
"      CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None",
"",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"         ! Place any last minute operations or calculations here:",
"",
"",
"         ! Close files here:",
"",
"",
"",
"         ! Destroy the input data:",
"",
"      CALL ModName_DestroyInput( u, ErrStat, ErrMsg )",
"",
"",
"         ! Destroy the parameter data:",
"",
"      CALL ModName_DestroyParam( p, ErrStat, ErrMsg )",
"",
"",
"         ! Destroy the state data:",
"",
"      CALL ModName_DestroyContState(   x,           ErrStat, ErrMsg )",
"      CALL ModName_DestroyDiscState(   xd,          ErrStat, ErrMsg )",
"      CALL ModName_DestroyConstrState( z,           ErrStat, ErrMsg )",
"      CALL ModName_DestroyOtherState(  OtherState,  ErrStat, ErrMsg )",
"",
"",
"         ! Destroy the output data:",
"",
"      CALL ModName_DestroyOutput( y, ErrStat, ErrMsg )",
"",
"",
"",
"",
"END SUBROUTINE ModName_End",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_UpdateStates( Time, u, p, x, xd, z, OtherState, ErrStat, ErrMsg )",
"! Loose coupling routine for solving for constraint states, integrating continuous states, and updating discrete states",
"! Constraint states are solved for input Time; Continuous and discrete states are updated for Time + Interval",
"!..................................................................................................................................",
"",
"      REAL(DbKi),                         INTENT(IN   ) :: Time        ! Current simulation time in seconds",
"      TYPE(ModName_InputType),            INTENT(IN   ) :: u           ! Inputs at Time",
"      TYPE(ModName_ParameterType),        INTENT(IN   ) :: p           ! Parameters",
"      TYPE(ModName_ContinuousStateType),  INTENT(INOUT) :: x           ! Input: Continuous states at Time;",
"                                                                       !   Output: Continuous states at Time + Interval",
"      TYPE(ModName_DiscreteStateType),    INTENT(INOUT) :: xd          ! Input: Discrete states at Time;",
"                                                                       !   Output: Discrete states at Time  + Interval",
"      TYPE(ModName_ConstraintStateType),  INTENT(INOUT) :: z           ! Input: Initial guess of constraint states at Time;",
"                                                                       !   Output: Constraint states at Time",
"      TYPE(ModName_OtherStateType),       INTENT(INOUT) :: OtherState  ! Other/optimization states",
"      INTEGER(IntKi),                     INTENT(  OUT) :: ErrStat     ! Error status of the operation",
"      CHARACTER(*),                       INTENT(  OUT) :: ErrMsg      ! Error message if ErrStat /= ErrID_None",
"",
"         ! Local variables",
"",
"      TYPE(ModName_ContinuousStateType)                 :: dxdt        ! Continuous state derivatives at Time",
"      TYPE(ModName_ConstraintStateType)                 :: z_Residual  ! Residual of the constraint state equations (Z)",
"",
"      INTEGER(IntKi)                                    :: ErrStat2    ! Error status of the operation (occurs after initial error)",
"      CHARACTER(LEN(ErrMsg))                            :: ErrMsg2     ! Error message if ErrStat2 /= ErrID_None",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"",
"         ! Solve for the constraint states (z) here:",
"",
"         ! Check if the z guess is correct and update z with a new guess.",
"         ! Iterate until the value is within a given tolerance.",
"",
"      CALL ModName_CalcConstrStateResidual( Time, u, p, x, xd, z, OtherState, z_Residual, ErrStat, ErrMsg )",
"      IF ( ErrStat >= AbortErrLev ) THEN",
"         CALL ModName_DestroyConstrState( z_Residual, ErrStat2, ErrMsg2)",
"         ErrMsg = TRIM(ErrMsg)//' '//TRIM(ErrMsg2)",
"         RETURN",
"      END IF",
"",
"      ! DO WHILE ( z_Residual% > tolerance )",
"      !",
"      !  z =",
"      !",
"      !  CALL ModName_CalcConstrStateResidual( Time, u, p, x, xd, z, OtherState, z_Residual, ErrStat, ErrMsg )",
"      !  IF ( ErrStat >= AbortErrLev ) THEN",
"      !     CALL ModName_DestroyConstrState( z_Residual, ErrStat2, ErrMsg2)",
"      !     ErrMsg = TRIM(ErrMsg)//' '//TRIM(ErrMsg2)",
"      !     RETURN",
"      !  END IF",
"      !",
"      ! END DO",
"",
"",
"         ! Destroy z_Residual because it is not necessary for the rest of the subroutine:",
"",
"      CALL ModName_DestroyConstrState( z_Residual, ErrStat, ErrMsg)",
"      IF ( ErrStat >= AbortErrLev ) RETURN",
"",
"",
"",
"         ! Get first time derivatives of continuous states (dxdt):",
"",
"      CALL ModName_CalcContStateDeriv( Time, u, p, x, xd, z, OtherState, dxdt, ErrStat, ErrMsg )",
"      IF ( ErrStat >= AbortErrLev ) THEN",
"         CALL ModName_DestroyContState( dxdt, ErrStat2, ErrMsg2)",
"         ErrMsg = TRIM(ErrMsg)//' '//TRIM(ErrMsg2)",
"         RETURN",
"      END IF",
"",
"",
"         ! Update discrete states:",
"         !   Note that xd [discrete state] is changed in ModName_UpdateDiscState(), so ModName_CalcOutput(),",
"         !   ModName_CalcContStateDeriv(), and ModName_CalcConstrStates() must be called first (see above).",
"",
"      CALL ModName_UpdateDiscState(Time, u, p, x, xd, z, OtherState, ErrStat, ErrMsg )",
"      IF ( ErrStat >= AbortErrLev ) THEN",
"         CALL ModName_DestroyContState( dxdt, ErrStat2, ErrMsg2)",
"         ErrMsg = TRIM(ErrMsg)//' '//TRIM(ErrMsg2)",
"         RETURN",
"      END IF",
"",
"",
"         ! Integrate (update) continuous states (x) here:",
"",
"      !x = function of dxdt and x",
"",
"",
"         ! Destroy dxdt because it is not necessary for the rest of the subroutine",
"",
"      CALL ModName_DestroyContState( dxdt, ErrStat, ErrMsg)",
"      IF ( ErrStat >= AbortErrLev ) RETURN",
"",
"",
"",
"END SUBROUTINE ModName_UpdateStates",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_CalcOutput( Time, u, p, x, xd, z, OtherState, y, ErrStat, ErrMsg )",
"! Routine for computing outputs, used in both loose and tight coupling.",
"!..................................................................................................................................",
"",
"      REAL(DbKi),                        INTENT(IN   )  :: Time        ! Current simulation time in seconds",
"      TYPE(ModName_InputType),           INTENT(IN   )  :: u           ! Inputs at Time",
"      TYPE(ModName_ParameterType),       INTENT(IN   )  :: p           ! Parameters",
"      TYPE(ModName_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at Time",
"      TYPE(ModName_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at Time",
"      TYPE(ModName_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at Time",
"      TYPE(ModName_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states",
"      TYPE(ModName_OutputType),          INTENT(INOUT)  :: y           ! Outputs computed at Time (Input only so that mesh con-",
"                                                                       !   nectivity information does not have to be recalculated)",
"      INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     ! Error status of the operation",
"      CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"         ! Compute outputs here:",
"!     y%DummyOutput    = 2.0_ReKi",
"",
"!     y%WriteOutput(1) = REAL(Time,ReKi)",
"!     y%WriteOutput(2) = 1.0_ReKi",
"",
"",
"END SUBROUTINE ModName_CalcOutput",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_CalcContStateDeriv( Time, u, p, x, xd, z, OtherState, dxdt, ErrStat, ErrMsg )",
"! Tight coupling routine for computing derivatives of continuous states",
"!..................................................................................................................................",
"",
"      REAL(DbKi),                        INTENT(IN   )  :: Time        ! Current simulation time in seconds",
"      TYPE(ModName_InputType),           INTENT(IN   )  :: u           ! Inputs at Time",
"      TYPE(ModName_ParameterType),       INTENT(IN   )  :: p           ! Parameters",
"      TYPE(ModName_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at Time",
"      TYPE(ModName_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at Time",
"      TYPE(ModName_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at Time",
"      TYPE(ModName_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states",
"      TYPE(ModName_ContinuousStateType), INTENT(  OUT)  :: dxdt        ! Continuous state derivatives at Time",
"      INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     ! Error status of the operation",
"      CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"         ! Compute the first time derivatives of the continuous states here:",
"",
"!     dxdt%DummyContState = 0",
"",
"",
"END SUBROUTINE ModName_CalcContStateDeriv",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_UpdateDiscState( Time, u, p, x, xd, z, OtherState, ErrStat, ErrMsg )",
"! Tight coupling routine for updating discrete states",
"!..................................................................................................................................",
"",
"      REAL(DbKi),                        INTENT(IN   )  :: Time        ! Current simulation time in seconds",
"      TYPE(ModName_InputType),           INTENT(IN   )  :: u           ! Inputs at Time",
"      TYPE(ModName_ParameterType),       INTENT(IN   )  :: p           ! Parameters",
"      TYPE(ModName_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at Time",
"      TYPE(ModName_DiscreteStateType),   INTENT(INOUT)  :: xd          ! Input: Discrete states at Time;",
"                                                                       !   Output: Discrete states at Time + Interval",
"      TYPE(ModName_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at Time",
"      TYPE(ModName_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states",
"      INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     ! Error status of the operation",
"      CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"         ! Update discrete states here:",
"",
"      ! StateData%DiscState =",
"",
"END SUBROUTINE ModName_UpdateDiscState",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_CalcConstrStateResidual( Time, u, p, x, xd, z, OtherState, z_residual, ErrStat, ErrMsg )",
"! Tight coupling routine for solving for the residual of the constraint state equations",
"!..................................................................................................................................",
"",
"      REAL(DbKi),                        INTENT(IN   )  :: Time        ! Current simulation time in seconds",
"      TYPE(ModName_InputType),           INTENT(IN   )  :: u           ! Inputs at Time",
"      TYPE(ModName_ParameterType),       INTENT(IN   )  :: p           ! Parameters",
"      TYPE(ModName_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at Time",
"      TYPE(ModName_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at Time",
"      TYPE(ModName_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at Time (possibly a guess)",
"      TYPE(ModName_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states",
"      TYPE(ModName_ConstraintStateType), INTENT(  OUT)  :: z_residual  ! Residual of the constraint state equations using",
"                                                                       !     the input values described above",
"      INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     ! Error status of the operation",
"      CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"         ! Solve for the constraint states here:",
"",
"      z_residual%DummyConstrState = 0",
"",
"END SUBROUTINE ModName_CalcConstrStateResidual",
#ifndef JACOBIANS
"!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
"! WE ARE NOT YET IMPLEMENTING THE JACOBIANS...",
"!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
"!----------------------------------------------------------------------------------------------------------------------------------",
#else
"SUBROUTINE ModName_JacobianPInput( Time, u, p, x, xd, z, OtherState, dYdu, dXdu, dXddu, dZdu, ErrStat, ErrMsg )",
"! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) equations",
"! with respect to the inputs (u). The partial derivatives dY/du, dX/du, dXd/du, and DZ/du are returned.",
"!..................................................................................................................................",
"",
"      REAL(DbKi),                                INTENT(IN   )           :: Time       ! Current simulation time in seconds",
"      TYPE(ModName_InputType),                   INTENT(IN   )           :: u          ! Inputs at Time",
"      TYPE(ModName_ParameterType),               INTENT(IN   )           :: p          ! Parameters",
"      TYPE(ModName_ContinuousStateType),         INTENT(IN   )           :: x          ! Continuous states at Time",
"      TYPE(ModName_DiscreteStateType),           INTENT(IN   )           :: xd         ! Discrete states at Time",
"      TYPE(ModName_ConstraintStateType),         INTENT(IN   )           :: z          ! Constraint states at Time",
"      TYPE(ModName_OtherStateType),              INTENT(INOUT)           :: OtherState ! Other/optimization states",
"      TYPE(ModName_PartialOutputPInputType),     INTENT(  OUT), OPTIONAL :: dYdu       ! Partial derivatives of output equations",
"                                                                                       !   (Y) with respect to the inputs (u)",
"      TYPE(ModName_PartialContStatePInputType),  INTENT(  OUT), OPTIONAL :: dXdu       ! Partial derivatives of continuous state",
"                                                                                       !   equations (X) with respect to inputs (u)",
"      TYPE(ModName_PartialDiscStatePInputType),  INTENT(  OUT), OPTIONAL :: dXddu      ! Partial derivatives of discrete state",
"                                                                                       !   equations (Xd) with respect to inputs (u)",
"      TYPE(ModName_PartialConstrStatePInputType),INTENT(  OUT), OPTIONAL :: dZdu       ! Partial derivatives of constraint state",
"                                                                                       !   equations (Z) with respect to inputs (u)",
"      INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    ! Error status of the operation",
"      CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     ! Error message if ErrStat /= ErrID_None",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"      IF ( PRESENT( dYdu ) ) THEN",
"",
"         ! Calculate the partial derivative of the output equations (Y) with respect to the inputs (u) here:",
"",
"         dYdu%DummyOutput%DummyInput = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dXdu ) ) THEN",
"",
"         ! Calculate the partial derivative of the continuous state equations (X) with respect to the inputs (u) here:",
"",
"         dXdu%DummyContState%DummyInput = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dXddu ) ) THEN",
"",
"         ! Calculate the partial derivative of the discrete state equations (Xd) with respect to the inputs (u) here:",
"",
"         dXddu%DummyDiscState%DummyInput = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dZdu ) ) THEN",
"",
"         ! Calculate the partial derivative of the constraint state equations (Z) with respect to the inputs (u) here:",
"",
"         dZdu%DummyConstrState%DummyInput = 0",
"",
"      END IF",
"",
"",
"END SUBROUTINE ModName_JacobianPInput",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_JacobianPContState( Time, u, p, x, xd, z, OtherState, dYdx, dXdx, dXddx, dZdx, ErrStat, ErrMsg )",
"! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) equations",
"! with respect to the continuous states (x). The partial derivatives dY/dx, dX/dx, dXd/dx, and DZ/dx are returned.",
"!..................................................................................................................................",
"",
"      REAL(DbKi),                                    INTENT(IN   )           :: Time       ! Current simulation time in seconds",
"      TYPE(ModName_InputType),                       INTENT(IN   )           :: u          ! Inputs at Time",
"      TYPE(ModName_ParameterType),                   INTENT(IN   )           :: p          ! Parameters",
"      TYPE(ModName_ContinuousStateType),             INTENT(IN   )           :: x          ! Continuous states at Time",
"      TYPE(ModName_DiscreteStateType),               INTENT(IN   )           :: xd         ! Discrete states at Time",
"      TYPE(ModName_ConstraintStateType),             INTENT(IN   )           :: z          ! Constraint states at Time",
"      TYPE(ModName_OtherStateType),                  INTENT(INOUT)           :: OtherState ! Other/optimization states",
"      TYPE(ModName_PartialOutputPContStateType),     INTENT(  OUT), OPTIONAL :: dYdx       ! Partial derivatives of output equations",
"                                                                                           !   (Y) with respect to the continuous",
"                                                                                           !   states (x)",
"      TYPE(ModName_PartialContStatePContStateType),  INTENT(  OUT), OPTIONAL :: dXdx       ! Partial derivatives of continuous state",
"                                                                                           !   equations (X) with respect to",
"                                                                                           !   the continuous states (x)",
"      TYPE(ModName_PartialDiscStatePContStateType),  INTENT(  OUT), OPTIONAL :: dXddx      ! Partial derivatives of discrete state",
"                                                                                           !   equations (Xd) with respect to",
"                                                                                           !   the continuous states (x)",
"      TYPE(ModName_PartialConstrStatePContStateType),INTENT(  OUT), OPTIONAL :: dZdx       ! Partial derivatives of constraint state",
"                                                                                           !   equations (Z) with respect to",
"                                                                                           !   the continuous states (x)",
"      INTEGER(IntKi),                                INTENT(  OUT)           :: ErrStat    ! Error status of the operation",
"      CHARACTER(*),                                  INTENT(  OUT)           :: ErrMsg     ! Error message if ErrStat /= ErrID_None",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"",
"      IF ( PRESENT( dYdx ) ) THEN",
"",
"         ! Calculate the partial derivative of the output equations (Y) with respect to the continuous states (x) here:",
"",
"         dYdx%DummyOutput%DummyContState = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dXdx ) ) THEN",
"",
"         ! Calculate the partial derivative of the continuous state equations (X) with respect to the continuous states (x) here:",
"",
"         dXdx%DummyContState%DummyContState = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dXddx ) ) THEN",
"",
"         ! Calculate the partial derivative of the discrete state equations (Xd) with respect to the continuous states (x) here:",
"",
"         dXddx%DummyDiscState%DummyContState = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dZdx ) ) THEN",
"",
"",
"         ! Calculate the partial derivative of the constraint state equations (Z) with respect to the continuous states (x) here:",
"",
"         dZdx%DummyConstrState%DummyContState = 0",
"",
"      END IF",
"",
"",
"   END SUBROUTINE ModName_JacobianPContState",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_JacobianPDiscState( Time, u, p, x, xd, z, OtherState, dYdxd, dXdxd, dXddxd, dZdxd, ErrStat, ErrMsg )",
"! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) equations",
"! with respect to the discrete states (xd). The partial derivatives dY/dxd, dX/dxd, dXd/dxd, and DZ/dxd are returned.",
"!..................................................................................................................................",
"",
"      REAL(DbKi),                                    INTENT(IN   )           :: Time       ! Current simulation time in seconds",
"      TYPE(ModName_InputType),                       INTENT(IN   )           :: u          ! Inputs at Time",
"      TYPE(ModName_ParameterType),                   INTENT(IN   )           :: p          ! Parameters",
"      TYPE(ModName_ContinuousStateType),             INTENT(IN   )           :: x          ! Continuous states at Time",
"      TYPE(ModName_DiscreteStateType),               INTENT(IN   )           :: xd         ! Discrete states at Time",
"      TYPE(ModName_ConstraintStateType),             INTENT(IN   )           :: z          ! Constraint states at Time",
"      TYPE(ModName_OtherStateType),                  INTENT(INOUT)           :: OtherState ! Other/optimization states",
"      TYPE(ModName_PartialOutputPDiscStateType),     INTENT(  OUT), OPTIONAL :: dYdxd      ! Partial derivatives of output equations",
"                                                                                           !  (Y) with respect to the discrete",
"                                                                                           !  states (xd)",
"      TYPE(ModName_PartialContStatePDiscStateType),  INTENT(  OUT), OPTIONAL :: dXdxd      ! Partial derivatives of continuous state",
"                                                                                           !   equations (X) with respect to the",
"                                                                                           !   discrete states (xd)",
"      TYPE(ModName_PartialDiscStatePDiscStateType),  INTENT(  OUT), OPTIONAL :: dXddxd     ! Partial derivatives of discrete state",
"                                                                                           !   equations (Xd) with respect to the",
"                                                                                           !   discrete states (xd)",
"      TYPE(ModName_PartialConstrStatePDiscStateType),INTENT(  OUT), OPTIONAL :: dZdxd      ! Partial derivatives of constraint state",
"                                                                                           !   equations (Z) with respect to the",
"                                                                                           !   discrete states (xd)",
"      INTEGER(IntKi),                                INTENT(  OUT)           :: ErrStat    ! Error status of the operation",
"      CHARACTER(*),                                  INTENT(  OUT)           :: ErrMsg     ! Error message if ErrStat /= ErrID_None",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"",
"      IF ( PRESENT( dYdxd ) ) THEN",
"",
"         ! Calculate the partial derivative of the output equations (Y) with respect to the discrete states (xd) here:",
"",
"         dYdxd%DummyOutput%DummyDiscState = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dXdxd ) ) THEN",
"",
"         ! Calculate the partial derivative of the continuous state equations (X) with respect to the discrete states (xd) here:",
"",
"         dXdxd%DummyContState%DummyDiscState = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dXddxd ) ) THEN",
"",
"         ! Calculate the partial derivative of the discrete state equations (Xd) with respect to the discrete states (xd) here:",
"",
"         dXddxd%DummyDiscState%DummyDiscState = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dZdxd ) ) THEN",
"",
"         ! Calculate the partial derivative of the constraint state equations (Z) with respect to the discrete states (xd) here:",
"",
"         dZdxd%DummyConstrState%DummyDiscState = 0",
"",
"      END IF",
"",
"",
"",
"END SUBROUTINE ModName_JacobianPDiscState",
"!----------------------------------------------------------------------------------------------------------------------------------",
"SUBROUTINE ModName_JacobianPConstrState( Time, u, p, x, xd, z, OtherState, dYdz, dXdz, dXddz, dZdz, ErrStat, ErrMsg )",
"! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) equations",
"! with respect to the constraint states (z). The partial derivatives dY/dz, dX/dz, dXd/dz, and DZ/dz are returned.",
"!..................................................................................................................................",
"",
"      REAL(DbKi),                                      INTENT(IN   )           :: Time       ! Current simulation time in seconds",
"      TYPE(ModName_InputType),                         INTENT(IN   )           :: u          ! Inputs at Time",
"      TYPE(ModName_ParameterType),                     INTENT(IN   )           :: p          ! Parameters",
"      TYPE(ModName_ContinuousStateType),               INTENT(IN   )           :: x          ! Continuous states at Time",
"      TYPE(ModName_DiscreteStateType),                 INTENT(IN   )           :: xd         ! Discrete states at Time",
"      TYPE(ModName_ConstraintStateType),               INTENT(IN   )           :: z          ! Constraint states at Time",
"      TYPE(ModName_OtherStateType),                    INTENT(INOUT)           :: OtherState ! Other/optimization states",
"      TYPE(ModName_PartialOutputPConstrStateType),     INTENT(  OUT), OPTIONAL :: dYdz       ! Partial derivatives of output",
"                                                                                             !  equations (Y) with respect to the",
"                                                                                             !  constraint states (z)",
"      TYPE(ModName_PartialContStatePConstrStateType),  INTENT(  OUT), OPTIONAL :: dXdz       ! Partial derivatives of continuous",
"                                                                                             !  state equations (X) with respect to",
"                                                                                             !  the constraint states (z)",
"      TYPE(ModName_PartialDiscStatePConstrStateType),  INTENT(  OUT), OPTIONAL :: dXddz      ! Partial derivatives of discrete state",
"                                                                                             !  equations (Xd) with respect to the",
"                                                                                             !  constraint states (z)",
"      TYPE(ModName_PartialConstrStatePConstrStateType),INTENT(  OUT), OPTIONAL :: dZdz       ! Partial derivatives of constraint",
"                                                                                             ! state equations (Z) with respect to",
"                                                                                             !  the constraint states (z)",
"      INTEGER(IntKi),                                  INTENT(  OUT)           :: ErrStat    ! Error status of the operation",
"      CHARACTER(*),                                    INTENT(  OUT)           :: ErrMsg     ! Error message if ErrStat /= ErrID_None",
"",
"",
"         ! Initialize ErrStat",
"",
"      ErrStat = ErrID_None",
"      ErrMsg  = \"\"",
"",
"      IF ( PRESENT( dYdz ) ) THEN",
"",
"            ! Calculate the partial derivative of the output equations (Y) with respect to the constraint states (z) here:",
"",
"         dYdz%DummyOutput%DummyConstrState = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dXdz ) ) THEN",
"",
"            ! Calculate the partial derivative of the continuous state equations (X) with respect to the constraint states (z) here:",
"",
"         dXdz%DummyContState%DummyConstrState = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dXddz ) ) THEN",
"",
"            ! Calculate the partial derivative of the discrete state equations (Xd) with respect to the constraint states (z) here:",
"",
"         dXddz%DummyDiscState%DummyConstrState = 0",
"",
"      END IF",
"",
"      IF ( PRESENT( dZdz ) ) THEN",
"",
"            ! Calculate the partial derivative of the constraint state equations (Z) with respect to the constraint states (z) here:",
"",
"         dZdz%DummyConstrState%DummyConstrState = 0",
"",
"      END IF",
"",
"",
"END SUBROUTINE ModName_JacobianPConstrState",
#endif
"",
"END MODULE ModuleName",
"!**********************************************************************************************************************************",
0L } ;
