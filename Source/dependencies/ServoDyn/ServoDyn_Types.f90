!STARTOFREGISTRYGENERATEDFILE './ServoDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 14-Jan-2015)
!*********************************************************************************************************************************
! ServoDyn_Types
!.................................................................................................................................
! This file is part of ServoDyn.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE ServoDyn_Types
! This module contains all of the user-defined types needed in ServoDyn. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE TMD_Types
USE NWTC_Library
IMPLICIT NONE
! =========  SrvD_InputFile  =======
  TYPE, PUBLIC :: SrvD_InputFile
    REAL(DbKi)  :: DT      ! Communication interval for controllers [s]
    INTEGER(IntKi)  :: PCMode      ! Pitch control mode [-]
    REAL(DbKi)  :: TPCOn      ! Time to enable active pitch control [unused when PCMode=0] [s]
    REAL(DbKi) , DIMENSION(1:3)  :: TPitManS      ! Time to start override pitch maneuver for blade (K) and end standard pitch control [s]
    REAL(ReKi) , DIMENSION(1:3)  :: PitManRat      ! Pitch rates at which override pitch maneuvers head toward final pitch angles [rad/s]
    REAL(ReKi) , DIMENSION(1:3)  :: BlPitchF      ! Blade (K) final pitch for pitch maneuvers [radians]
    INTEGER(IntKi)  :: VSContrl      ! Variable-speed control mode [-]
    INTEGER(IntKi)  :: GenModel      ! Generator model [used only when VSContrl=0] [-]
    REAL(ReKi)  :: GenEff      ! Generator efficiency [ignored by the Thevenin and user-defined generator models] [-]
    LOGICAL  :: GenTiStr      ! Method to start the generator {T: timed using TimGenOn, F: generator speed using SpdGenOn} [-]
    LOGICAL  :: GenTiStp      ! Method to stop the generator {T: timed using TimGenOf, F: when generator power = 0} [-]
    REAL(ReKi)  :: SpdGenOn      ! Generator speed to turn on the generator for a startup (HSS speed) [used only when GenTiStr=False] [rad/s]
    REAL(DbKi)  :: TimGenOn      ! Time to turn on the generator for a startup [used only when GenTiStr=True] [s]
    REAL(DbKi)  :: TimGenOf      ! Time to turn off the generator [used only when GenTiStp=True] [s]
    REAL(ReKi)  :: VS_RtGnSp      ! Rated generator speed for simple variable-speed generator control (HSS side) [used only when VSContrl=1] [rad/s]
    REAL(ReKi)  :: VS_RtTq      ! Rated generator torque/constant generator torque in Region 3 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] [N-m]
    REAL(ReKi)  :: VS_Rgn2K      ! Generator torque constant in Region 2 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] [N-m/(rad/s)^2]
    REAL(ReKi)  :: VS_SlPc      ! Rated generator slip percentage in Region 2 1/2 for simple variable-speed generator control [used only when VSContrl=1] [-]
    REAL(ReKi)  :: SIG_SlPc      ! Rated generator slip percentage [used only when VSContrl=0 and GenModel=1] [-]
    REAL(ReKi)  :: SIG_SySp      ! Synchronous (zero-torque) generator speed [used only when VSContrl=0 and GenModel=1] [rad/s]
    REAL(ReKi)  :: SIG_RtTq      ! Rated torque [used only when VSContrl=0 and GenModel=1] [N-m]
    REAL(ReKi)  :: SIG_PORt      ! Pull-out ratio (Tpullout/Trated) [used only when VSContrl=0 and GenModel=1] [-]
    REAL(ReKi)  :: TEC_Freq      ! Line frequency [50 or 60] [used only when VSContrl=0 and GenModel=2] [Hz]
    INTEGER(IntKi)  :: TEC_NPol      ! Number of poles [even integer > 0] [used only when VSContrl=0 and GenModel=2] [-]
    REAL(ReKi)  :: TEC_SRes      ! Stator resistance [used only when VSContrl=0 and GenModel=2] [ohms]
    REAL(ReKi)  :: TEC_RRes      ! Rotor resistance [used only when VSContrl=0 and GenModel=2] [ohms]
    REAL(ReKi)  :: TEC_VLL      ! Line-to-line RMS voltage [used only when VSContrl=0 and GenModel=2] [volts]
    REAL(ReKi)  :: TEC_SLR      ! Stator leakage reactance [used only when VSContrl=0 and GenModel=2] [ohms]
    REAL(ReKi)  :: TEC_RLR      ! Rotor leakage reactance [used only when VSContrl=0 and GenModel=2] [ohms]
    REAL(ReKi)  :: TEC_MR      ! Magnetizing reactance [used only when VSContrl=0 and GenModel=2] [ohms]
    INTEGER(IntKi)  :: HSSBrMode      ! HSS brake model [-]
    REAL(DbKi)  :: THSSBrDp      ! Time to initiate deployment of the HSS brake [s]
    REAL(DbKi)  :: HSSBrDT      ! Time for HSS-brake to reach full deployment once initiated [used only when HSSBrMode=1] [s]
    REAL(ReKi)  :: HSSBrTqF      ! Fully deployed HSS-brake torque [N-m]
    INTEGER(IntKi)  :: YCMode      ! Yaw control mode [-]
    REAL(DbKi)  :: TYCOn      ! Time to enable active yaw control [unused when YCMode=0] [s]
    REAL(ReKi)  :: YawNeut      ! Neutral yaw position--yaw spring force is zero at this yaw [radians]
    REAL(ReKi)  :: YawSpr      ! Nacelle-yaw spring constant [N-m/rad]
    REAL(ReKi)  :: YawDamp      ! Nacelle-yaw constant [N-m/(rad/s)]
    REAL(DbKi)  :: TYawManS      ! Time to start override yaw maneuver and end standard yaw control [s]
    REAL(ReKi)  :: YawManRat      ! Yaw maneuver rate (in absolute value) [rad/s]
    REAL(ReKi)  :: NacYawF      ! Final yaw angle for override yaw maneuvers [radians]
    LOGICAL  :: SumPrint      ! Print summary data to <RootName>.sum [-]
    INTEGER(IntKi)  :: OutFile      ! Switch to determine where output will be placed: (1: in module output file only; 2: in glue code output file only; 3: both) [-]
    LOGICAL  :: TabDelim      ! Use tab delimiters in text tabular output file? [-]
    CHARACTER(20)  :: OutFmt      ! Format used for text tabular output (except time) [-]
    REAL(DbKi)  :: Tstart      ! Time to start module's tabular output [s]
    INTEGER(IntKi)  :: NumOuts      ! Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: OutList      ! List of user-requested output channels [-]
    CHARACTER(1024)  :: DLL_FileName      ! Name of the DLL file including the full path [-]
    CHARACTER(1024)  :: DLL_ProcName      ! Name of the procedure in the DLL that will be called [-]
    CHARACTER(1024)  :: DLL_InFile      ! Name of input file used in DLL [-]
    REAL(ReKi)  :: NacYaw_North      ! Reference yaw angle of the nacelle when the upwind end points due North [used only with DLL Interface] [radians]
    INTEGER(IntKi)  :: Ptch_Cntrl      ! Record 28: Use individual pitch control {0: collective pitch; 1: individual pitch control} [used only with DLL Interface] [-]
    REAL(ReKi)  :: Ptch_SetPnt      ! Record  5: Below-rated pitch angle set-point [used only with DLL Interface] [radians]
    REAL(ReKi)  :: Ptch_Min      ! Record  6: Minimum pitch angle [used only with DLL Interface] [radians]
    REAL(ReKi)  :: Ptch_Max      ! Record  7: Maximum pitch angle [used only with DLL Interface] [radians]
    REAL(ReKi)  :: PtchRate_Min      ! Record  8: Minimum pitch rate (most negative value allowed) [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: PtchRate_Max      ! Record  9: Maximum pitch rate [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: Gain_OM      ! Record 16: Optimal mode gain [used only with DLL Interface] [Nm/(rad/s)^2]
    REAL(ReKi)  :: GenSpd_MinOM      ! Record 17: Minimum generator speed [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: GenSpd_MaxOM      ! Record 18: Optimal mode maximum speed [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: GenSpd_Dem      ! Record 19: Demanded generator speed above rated [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: GenTrq_Dem      ! Record 22: Demanded generator torque above rated [used only with DLL Interface] [Nm]
    REAL(ReKi)  :: GenPwr_Dem      ! Record 13: Demanded power [used only with DLL Interface] [W]
    INTEGER(IntKi)  :: DLL_NumTrq      ! Record 26: No. of points in torque-speed look-up table {0 = none and use the optimal mode PARAMETERs instead, nonzero = ignore the optimal mode PARAMETERs by setting Gain_OM (Record 16) to 0.0} [used only with DLL Interface] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: GenSpd_TLU      ! Records R:2:R+2*DLL_NumTrq-2: Generator speed values in look-up table [used only with DLL Interface] [rad/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: GenTrq_TLU      ! Records R+1:2:R+2*DLL_NumTrq-1: Generator torque values in look-up table [used only with DLL Interface] [Nm]
    LOGICAL  :: CompNTMD      ! Compute nacelle tuned mass damper {true/false} [-]
    CHARACTER(1024)  :: NTMDfile      ! File for nacelle tuned mass damper (quoted string) [-]
  END TYPE SrvD_InputFile
! =======================
! =========  BladedDLLType  =======
  TYPE, PUBLIC :: BladedDLLType
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: avrSWAP      ! The swap array: used to pass data to and from the DLL controller [see Bladed DLL documentation]
    REAL(ReKi)  :: HSSBrFrac      ! Fraction of full braking torque: 0 (off) <= HSSBrFrac <= 1 (full) - from Bladed DLL [-]
    REAL(ReKi)  :: YawRateCom      ! Nacelle yaw rate demanded from Bladed DLL [rad/s]
    REAL(ReKi)  :: GenTrq      ! Electrical generator torque from Bladed DLL [N-m]
    INTEGER(IntKi)  :: GenState      ! Generator state from Bladed DLL [N-m]
    REAL(ReKi) , DIMENSION(1:3)  :: BlPitchCom      ! Commanded blade pitch angles [radians]
  END TYPE BladedDLLType
! =======================
! =========  SrvD_InitInputType  =======
  TYPE, PUBLIC :: SrvD_InitInputType
    CHARACTER(1024)  :: InputFile      ! Name of the input file [-]
    INTEGER(IntKi)  :: NumBl      ! Number of blades on the turbine [-]
    CHARACTER(1024)  :: RootName      ! RootName for writing output files [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchInit      ! Initial blade pitch [-]
    REAL(ReKi)  :: Gravity      ! Gravitational acceleration [m/s^2]
    REAL(ReKi) , DIMENSION(1:3)  :: r_N_O_G      ! nacelle origin for setting up mesh [m]
    REAL(DbKi)  :: Tmax      ! max time from glue code [s]
  END TYPE SrvD_InitInputType
! =======================
! =========  SrvD_InitOutputType  =======
  TYPE, PUBLIC :: SrvD_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      ! Names of the output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      ! Units of the output-to-file channels [-]
    TYPE(ProgDesc)  :: Ver      ! This module's name, version, and date [-]
    INTEGER(IntKi)  :: CouplingScheme      ! Switch that indicates if a particular coupling scheme is required [-]
    LOGICAL  :: UseHSSBrake      ! flag to determine if high-speed shaft brake is potentially used (true=yes) [-]
  END TYPE SrvD_InitOutputType
! =======================
! =========  SrvD_ContinuousStateType  =======
  TYPE, PUBLIC :: SrvD_ContinuousStateType
    REAL(ReKi)  :: DummyContState      ! Remove this variable if you have continuous states [-]
    TYPE(TMD_ContinuousStateType)  :: NTMD      ! TMD module states [-]
  END TYPE SrvD_ContinuousStateType
! =======================
! =========  SrvD_DiscreteStateType  =======
  TYPE, PUBLIC :: SrvD_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      ! Remove this variable if you have discrete states [-]
    TYPE(TMD_DiscreteStateType)  :: NTMD      ! TMD module states [-]
  END TYPE SrvD_DiscreteStateType
! =======================
! =========  SrvD_ConstraintStateType  =======
  TYPE, PUBLIC :: SrvD_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      ! Remove this variable if you have constraint states [-]
    TYPE(TMD_ConstraintStateType)  :: NTMD      ! TMD module states [-]
  END TYPE SrvD_ConstraintStateType
! =======================
! =========  SrvD_OtherStateType  =======
  TYPE, PUBLIC :: SrvD_OtherStateType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchI      ! Initial blade pitch angles at the start of the override pitch maneuver [radians]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: BegPitMan      ! Time that the override pitch manuever actually began [seconds]
    REAL(DbKi)  :: BegYawMan      ! Time that the yaw maneuver actually began [seconds]
    REAL(ReKi)  :: NacYawI      ! Initial yaw angle at the start of the override yaw maneuver [radians]
    REAL(ReKi)  :: YawManRat      ! Yaw rate at which override yaw maneuver head toward for final yaw angle (includes sign) [rad/s]
    REAL(DbKi)  :: TYawManE      ! Time to end override yaw maneuver [s]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TTpBrDp      ! Times to initiate deployment of tip brakes [s]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TTpBrFl      ! Times at which tip brakes are fully deployed [s]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TPitManE      ! Time to end pitch maneuvers for each blade [s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PitManRat      ! Pitch rates at which override pitch maneuvers head toward final pitch angles (includes sign) [rad/s]
    REAL(DbKi)  :: TOff4Good      ! Time that the generator went offline (for rest of simulation) [s]
    REAL(DbKi)  :: TGenOnLine      ! Time that the generator first went online [s]
    TYPE(BladedDLLType)  :: dll_data      ! data used for Bladed DLL [-]
    REAL(DbKi)  :: LastTimeCalled      ! last time the CalcOutput/Bladed DLL was called [s]
    LOGICAL  :: FirstWarn      ! Whether or not this is the first warning about the DLL being called without Explicit-Loose coupling. [-]
    TYPE(TMD_OtherStateType)  :: NTMD      ! TMD module states [-]
  END TYPE SrvD_OtherStateType
! =======================
! =========  SrvD_ParameterType  =======
  TYPE, PUBLIC :: SrvD_ParameterType
    REAL(DbKi)  :: DT      ! Time step for continuous state integration & discrete state update [seconds]
    REAL(DbKi)  :: HSSBrDT      ! Time it takes for HSS brake to reach full deployment once deployed [seconds]
    REAL(ReKi)  :: HSSBrFrac      ! Fraction of full braking torque: 0 (off) <= HSSBrFrac <= 1 (full), (-) [-]
    REAL(ReKi)  :: HSSBrTqF      ! Fully deployed HSS brake torque [-]
    REAL(ReKi)  :: SIG_POSl      ! Pullout slip [-]
    REAL(ReKi)  :: SIG_POTq      ! Pullout torque [-]
    REAL(ReKi)  :: SIG_SlPc      ! Rated generator slip percentage [-]
    REAL(ReKi)  :: SIG_Slop      ! Torque/Speed slope for simple induction generator [-]
    REAL(ReKi)  :: SIG_SySp      ! Synchronous (zero-torque) generator speed [rad/s]
    REAL(ReKi)  :: TEC_A0      ! A0 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_C0      ! C0 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_C1      ! C1 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_C2      ! C2 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_K2      ! K2 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_MR      ! Magnetizing reactance for Thevenin-equivalent circuit [ohms]
    REAL(ReKi)  :: TEC_Re1      ! Thevenin's equivalent stator resistance (ohms) [ohms]
    REAL(ReKi)  :: TEC_RLR      ! Rotor leakage reactance for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_RRes      ! Rotor resistance for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_SRes      ! Stator resistance for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_SySp      ! Synchronous speed for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_V1a      ! Source voltage for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_VLL      ! Line-to-line RMS voltage for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_Xe1      ! Thevenin's equivalent stator leakage reactance (ohms) [ohms]
    REAL(ReKi)  :: GenEff      ! Generator efficiency [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchInit      ! Initial blade pitch angles [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchF      ! Final blade pitch [-]
    REAL(ReKi)  :: NacYawF      ! Final yaw angle after override yaw maneuver [-]
    REAL(ReKi)  :: SpdGenOn      ! Generator speed to turn on the generator for a startup [-]
    REAL(DbKi)  :: THSSBrDp      ! Time to initiate deployment of the shaft brake [s]
    REAL(DbKi)  :: THSSBrFl      ! Time at which shaft brake is fully deployed [s]
    REAL(DbKi)  :: TimGenOf      ! Time to turn off generator for braking or modeling a run-away [s]
    REAL(DbKi)  :: TimGenOn      ! Time to turn on generator for startup [s]
    REAL(DbKi)  :: TPCOn      ! Time to enable active pitch control [s]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TPitManS      ! Time to start pitch maneuvers for each blade [s]
    REAL(DbKi)  :: TYawManS      ! Time to start override yaw maneuver [s]
    REAL(DbKi)  :: TYCOn      ! Time to enable active yaw control [s]
    REAL(ReKi)  :: VS_RtGnSp      ! Rated generator speed (HSS side) [rad/s]
    REAL(ReKi)  :: VS_RtTq      ! Rated generator torque/constant generator torque in Region 3 (HSS side) [N-m]
    REAL(ReKi)  :: VS_Slope      ! Torque/speed slope of region 2 1/2 induction generator [-]
    REAL(ReKi)  :: VS_SlPc      ! Rated generator slip percentage in Region 2 1/2 [-]
    REAL(ReKi)  :: VS_SySp      ! Synchronous speed of region 2 1/2 induction generator [-]
    REAL(ReKi)  :: VS_TrGnSp      ! Transitional generator speed between regions 2 and 2 1/2 [-]
    REAL(ReKi)  :: YawPosCom      ! Commanded yaw angle from user-defined routines [rad]
    REAL(ReKi)  :: YawRateCom      ! Commanded yaw rate  from user-defined routines [rad/s]
    INTEGER(IntKi)  :: GenModel      ! Generator model [-]
    INTEGER(IntKi)  :: HSSBrMode      ! HSS brake model [-]
    INTEGER(IntKi)  :: PCMode      ! Pitch control mode [-]
    INTEGER(IntKi)  :: VSContrl      ! Variable-speed-generator control switch [-]
    INTEGER(IntKi)  :: YCMode      ! Yaw control mode [-]
    LOGICAL  :: GenTiStp      ! Stop generator based upon T: time or F: generator power = 0 [-]
    LOGICAL  :: GenTiStr      ! Start generator based upon T: time or F: generator speed [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TBDepISp      ! Deployment-initiation speed for the tip brakes [rad/s]
    REAL(ReKi)  :: VS_Rgn2K      ! Generator torque constant in Region 2 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] [N-m/(rad/s)^2]
    REAL(ReKi)  :: YawNeut      ! Neutral yaw position--yaw spring force is zero at this yaw [radians]
    REAL(ReKi)  :: YawSpr      ! Nacelle-yaw spring constant [N-m/rad]
    REAL(ReKi)  :: YawDamp      ! Nacelle-yaw constant [N-m/(rad/s)]
    REAL(DbKi)  :: TpBrDT      ! Time for tip-brake to reach full deployment once released [s]
    REAL(ReKi)  :: TBDrConN      ! Tip-brake drag constant during normal operation, Cd*Area [-]
    REAL(ReKi)  :: TBDrConD      ! Tip-brake drag constant during fully-deployed operation, Cd*Area [-]
    INTEGER(IntKi)  :: NumBl      ! Number of blades on the turbine [-]
    LOGICAL  :: CompNTMD      ! Compute nacelle tuned mass damper {true/false} [-]
    INTEGER(IntKi)  :: NumOuts      ! Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(1024)  :: RootName      ! RootName for writing output files [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      ! Names and units (and other characteristics) of all requested output parameters [-]
    CHARACTER(1)  :: Delim      ! Column delimiter for output text files [-]
    LOGICAL  :: UseBladedInterface      ! Flag that determines if BladedInterface was used [-]
    INTEGER(IntKi)  :: DLL_NumTrq      ! No. of points in torque-speed look-up table, 0 = none and use the optimal mode PARAMETERs instead;  nonzero = ignore the optimal mode PARAMETERs by setting Record 16 to 0.0 [-]
    INTEGER(IntKi)  :: Ptch_Cntrl      ! Pitch control: 0 = collective;  1 = individual [-]
    REAL(ReKi)  :: Gain_OM      ! Optimal mode gain [Nm/(rad/s)^2]
    REAL(ReKi)  :: GenPwr_Dem      ! Demanded power [W]
    REAL(ReKi)  :: GenSpd_Dem      ! Demanded generator speed above rated [rad/s]
    REAL(ReKi)  :: GenSpd_MaxOM      ! Optimal mode maximum speed [rad/s]
    REAL(ReKi)  :: GenSpd_MinOM      ! Minimum generator speed [rad/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: GenSpd_TLU      ! Table (array) containing DLL_NumTrq generator speeds  for the torque-speed table look-up (TLU) -- this should be defined using an array constructor; for example,  if DLL_NumTrq = 3,  GenSpd_TLU(DLL_NumTrq)    = (/ 0.0, 99.9,  999.9 /) [rad/s]
    REAL(ReKi)  :: GenTrq_Dem      ! Demanded generator torque [Nm]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: GenTrq_TLU      ! Table (array) containing DLL_NumTrq generator torques for the torque-speed table look-up (TLU) -- this should be defined using an array constructor, for example,  if DLL_NumTrq = 3,  GenTrq_TLU(DLL_NumTrq)    = (/ 0.0, 10,  200.0 /) [Nm]
    REAL(ReKi)  :: Ptch_Max      ! Maximum pitch angle [rad]
    REAL(ReKi)  :: Ptch_Min      ! Minimum pitch angle [rad]
    REAL(ReKi)  :: Ptch_SetPnt      ! Below-rated pitch angle set-point [rad]
    REAL(ReKi)  :: PtchRate_Max      ! Maximum pitch rate [rad/s]
    REAL(ReKi)  :: PtchRate_Min      ! Minimum pitch rate (most negative value allowed) [rad/s]
    REAL(ReKi)  :: NacYaw_North      ! Reference yaw angle of the nacelle when the upwind end points due North [rad]
    CHARACTER(1024)  :: DLL_InFile      ! Name of input file used in DLL [-]
    TYPE(DLL_Type)  :: DLL_Trgt      ! The addresses and names of the Bladed DLL and its procedure [-]
    TYPE(TMD_ParameterType)  :: NTMD      ! TMD module parameters [-]
  END TYPE SrvD_ParameterType
! =======================
! =========  SrvD_InputType  =======
  TYPE, PUBLIC :: SrvD_InputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitch      ! Current blade pitch angles [radians]
    REAL(ReKi)  :: Yaw      ! Current nacelle yaw [radians]
    REAL(ReKi)  :: YawRate      ! Current nacelle yaw rate [rad/s]
    REAL(ReKi)  :: LSS_Spd      ! Low-speed shaft (LSS) speed at entrance to gearbox [rad/s]
    REAL(ReKi)  :: HSS_Spd      ! High-speed shaft (HSS) speed [rad/s]
    REAL(ReKi)  :: RotSpeed      ! Rotor azimuth angular speed [rad/s]
    REAL(ReKi)  :: ExternalYawPosCom      ! Commanded nacelle yaw position from Simulink or Labview [radians]
    REAL(ReKi)  :: ExternalYawRateCom      ! Commanded nacelle yaw rate from Simulink or Labview [rad/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ExternalBlPitchCom      ! Commanded blade pitch from Simulink or LabVIEW [radians]
    REAL(ReKi)  :: ExternalGenTrq      ! Electrical generator torque from Simulink or LabVIEW [N-m]
    REAL(ReKi)  :: ExternalElecPwr      ! Electrical power from Simulink or LabVIEW [W]
    REAL(ReKi)  :: ExternalHSSBrFrac      ! Fraction of full braking torque: 0 (off) <= HSSBrFrac <= 1 (full) from Simulink or LabVIEW [-]
    REAL(ReKi)  :: TwrAccel      ! Tower acceleration for tower feedback control (user routine only) [m/s^2]
    REAL(ReKi)  :: YawErr      ! Yaw error [radians]
    REAL(ReKi)  :: WindDir      ! Wind direction [radians]
    REAL(ReKi) , DIMENSION(1:3)  :: RootMyc      ! Out-of-plane moment (i.e., the moment caused by out-of-plane forces) at the blade root for each of the blades (max 3) [N-m]
    REAL(ReKi)  :: YawBrTAxp      ! Tower-top / yaw bearing fore-aft (translational) acceleration (absolute) [m/s^2]
    REAL(ReKi)  :: YawBrTAyp      ! Tower-top / yaw bearing side-to-side (translational) acceleration (absolute) [m/s^2]
    REAL(ReKi)  :: LSSTipPxa      ! Rotor azimuth angle (position) [radians]
    REAL(ReKi) , DIMENSION(1:3)  :: RootMxc      ! In-plane moment (i.e., the moment caused by in-plane forces) at the blade root [N-m]
    REAL(ReKi)  :: LSSTipMya      ! Rotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMza      ! Rotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMys      ! Nonrotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMzs      ! Nonrotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: YawBrMyn      ! Rotating (with nacelle) tower-top / yaw bearing pitch moment [N-m]
    REAL(ReKi)  :: YawBrMzn      ! Tower-top / yaw bearing yaw moment [N-m]
    REAL(ReKi)  :: NcIMURAxs      ! Nacelle inertial measurement unit angular (rotational) acceleration (absolute) [rad/s^2]
    REAL(ReKi)  :: NcIMURAys      ! Nacelle inertial measurement unit angular (rotational) acceleration (absolute) [rad/s^2]
    REAL(ReKi)  :: NcIMURAzs      ! Nacelle inertial measurement unit angular (rotational) acceleration (absolute) [rad/s^2]
    REAL(ReKi)  :: RotPwr      ! Rotor power (this is equivalent to the low-speed shaft power) [W]
    REAL(ReKi)  :: HorWindV      ! Horizontal hub-height wind velocity magnitude [m/s]
    REAL(ReKi)  :: YawAngle      ! Estimate of yaw (nacelle + platform) [radians]
    REAL(ReKi)  :: ElecPwr_prev      ! Electrical power (from previous step), sent to Bladed DLL [W]
    REAL(ReKi)  :: GenTrq_prev      ! Electrical generator torque (from previous step), sent to Bladed DLL [N-m]
    TYPE(TMD_InputType)  :: NTMD      ! TMD module inputs [-]
  END TYPE SrvD_InputType
! =======================
! =========  SrvD_OutputType  =======
  TYPE, PUBLIC :: SrvD_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! Data to be written to an output file: see WriteOutputHdr for names of each variable [see WriteOutputUnt]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchCom      ! Commanded blade pitch angles [radians]
    REAL(ReKi)  :: YawMom      ! Torque transmitted through the yaw bearing [N-m]
    REAL(ReKi)  :: GenTrq      ! Electrical generator torque [N-m]
    REAL(ReKi)  :: HSSBrTrqC      ! Commanded HSS brake torque [N-m]
    REAL(ReKi)  :: ElecPwr      ! Electrical power [W]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TBDrCon      ! Instantaneous tip-brake drag constant, Cd*Area [-]
    TYPE(TMD_OutputType)  :: NTMD      ! TMD module outputs [-]
  END TYPE SrvD_OutputType
! =======================
CONTAINS
 SUBROUTINE SrvD_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(SrvD_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInputFileData%DT = SrcInputFileData%DT
   DstInputFileData%PCMode = SrcInputFileData%PCMode
   DstInputFileData%TPCOn = SrcInputFileData%TPCOn
   DstInputFileData%TPitManS = SrcInputFileData%TPitManS
   DstInputFileData%PitManRat = SrcInputFileData%PitManRat
   DstInputFileData%BlPitchF = SrcInputFileData%BlPitchF
   DstInputFileData%VSContrl = SrcInputFileData%VSContrl
   DstInputFileData%GenModel = SrcInputFileData%GenModel
   DstInputFileData%GenEff = SrcInputFileData%GenEff
   DstInputFileData%GenTiStr = SrcInputFileData%GenTiStr
   DstInputFileData%GenTiStp = SrcInputFileData%GenTiStp
   DstInputFileData%SpdGenOn = SrcInputFileData%SpdGenOn
   DstInputFileData%TimGenOn = SrcInputFileData%TimGenOn
   DstInputFileData%TimGenOf = SrcInputFileData%TimGenOf
   DstInputFileData%VS_RtGnSp = SrcInputFileData%VS_RtGnSp
   DstInputFileData%VS_RtTq = SrcInputFileData%VS_RtTq
   DstInputFileData%VS_Rgn2K = SrcInputFileData%VS_Rgn2K
   DstInputFileData%VS_SlPc = SrcInputFileData%VS_SlPc
   DstInputFileData%SIG_SlPc = SrcInputFileData%SIG_SlPc
   DstInputFileData%SIG_SySp = SrcInputFileData%SIG_SySp
   DstInputFileData%SIG_RtTq = SrcInputFileData%SIG_RtTq
   DstInputFileData%SIG_PORt = SrcInputFileData%SIG_PORt
   DstInputFileData%TEC_Freq = SrcInputFileData%TEC_Freq
   DstInputFileData%TEC_NPol = SrcInputFileData%TEC_NPol
   DstInputFileData%TEC_SRes = SrcInputFileData%TEC_SRes
   DstInputFileData%TEC_RRes = SrcInputFileData%TEC_RRes
   DstInputFileData%TEC_VLL = SrcInputFileData%TEC_VLL
   DstInputFileData%TEC_SLR = SrcInputFileData%TEC_SLR
   DstInputFileData%TEC_RLR = SrcInputFileData%TEC_RLR
   DstInputFileData%TEC_MR = SrcInputFileData%TEC_MR
   DstInputFileData%HSSBrMode = SrcInputFileData%HSSBrMode
   DstInputFileData%THSSBrDp = SrcInputFileData%THSSBrDp
   DstInputFileData%HSSBrDT = SrcInputFileData%HSSBrDT
   DstInputFileData%HSSBrTqF = SrcInputFileData%HSSBrTqF
   DstInputFileData%YCMode = SrcInputFileData%YCMode
   DstInputFileData%TYCOn = SrcInputFileData%TYCOn
   DstInputFileData%YawNeut = SrcInputFileData%YawNeut
   DstInputFileData%YawSpr = SrcInputFileData%YawSpr
   DstInputFileData%YawDamp = SrcInputFileData%YawDamp
   DstInputFileData%TYawManS = SrcInputFileData%TYawManS
   DstInputFileData%YawManRat = SrcInputFileData%YawManRat
   DstInputFileData%NacYawF = SrcInputFileData%NacYawF
   DstInputFileData%SumPrint = SrcInputFileData%SumPrint
   DstInputFileData%OutFile = SrcInputFileData%OutFile
   DstInputFileData%TabDelim = SrcInputFileData%TabDelim
   DstInputFileData%OutFmt = SrcInputFileData%OutFmt
   DstInputFileData%Tstart = SrcInputFileData%Tstart
   DstInputFileData%NumOuts = SrcInputFileData%NumOuts
IF (ALLOCATED(SrcInputFileData%OutList)) THEN
   i1_l = LBOUND(SrcInputFileData%OutList,1)
   i1_u = UBOUND(SrcInputFileData%OutList,1)
   IF (.NOT. ALLOCATED(DstInputFileData%OutList)) THEN 
      ALLOCATE(DstInputFileData%OutList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg,'SrvD_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%OutList = SrcInputFileData%OutList
ENDIF
   DstInputFileData%DLL_FileName = SrcInputFileData%DLL_FileName
   DstInputFileData%DLL_ProcName = SrcInputFileData%DLL_ProcName
   DstInputFileData%DLL_InFile = SrcInputFileData%DLL_InFile
   DstInputFileData%NacYaw_North = SrcInputFileData%NacYaw_North
   DstInputFileData%Ptch_Cntrl = SrcInputFileData%Ptch_Cntrl
   DstInputFileData%Ptch_SetPnt = SrcInputFileData%Ptch_SetPnt
   DstInputFileData%Ptch_Min = SrcInputFileData%Ptch_Min
   DstInputFileData%Ptch_Max = SrcInputFileData%Ptch_Max
   DstInputFileData%PtchRate_Min = SrcInputFileData%PtchRate_Min
   DstInputFileData%PtchRate_Max = SrcInputFileData%PtchRate_Max
   DstInputFileData%Gain_OM = SrcInputFileData%Gain_OM
   DstInputFileData%GenSpd_MinOM = SrcInputFileData%GenSpd_MinOM
   DstInputFileData%GenSpd_MaxOM = SrcInputFileData%GenSpd_MaxOM
   DstInputFileData%GenSpd_Dem = SrcInputFileData%GenSpd_Dem
   DstInputFileData%GenTrq_Dem = SrcInputFileData%GenTrq_Dem
   DstInputFileData%GenPwr_Dem = SrcInputFileData%GenPwr_Dem
   DstInputFileData%DLL_NumTrq = SrcInputFileData%DLL_NumTrq
IF (ALLOCATED(SrcInputFileData%GenSpd_TLU)) THEN
   i1_l = LBOUND(SrcInputFileData%GenSpd_TLU,1)
   i1_u = UBOUND(SrcInputFileData%GenSpd_TLU,1)
   IF (.NOT. ALLOCATED(DstInputFileData%GenSpd_TLU)) THEN 
      ALLOCATE(DstInputFileData%GenSpd_TLU(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GenSpd_TLU.', ErrStat, ErrMsg,'SrvD_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%GenSpd_TLU = SrcInputFileData%GenSpd_TLU
ENDIF
IF (ALLOCATED(SrcInputFileData%GenTrq_TLU)) THEN
   i1_l = LBOUND(SrcInputFileData%GenTrq_TLU,1)
   i1_u = UBOUND(SrcInputFileData%GenTrq_TLU,1)
   IF (.NOT. ALLOCATED(DstInputFileData%GenTrq_TLU)) THEN 
      ALLOCATE(DstInputFileData%GenTrq_TLU(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GenTrq_TLU.', ErrStat, ErrMsg,'SrvD_CopyInputFile')
         RETURN
      END IF
   END IF
   DstInputFileData%GenTrq_TLU = SrcInputFileData%GenTrq_TLU
ENDIF
   DstInputFileData%CompNTMD = SrcInputFileData%CompNTMD
   DstInputFileData%NTMDfile = SrcInputFileData%NTMDfile
 END SUBROUTINE SrvD_CopyInputFile

 SUBROUTINE SrvD_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(SrvD_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputFileData%OutList)) THEN
   DEALLOCATE(InputFileData%OutList)
ENDIF
IF (ALLOCATED(InputFileData%GenSpd_TLU)) THEN
   DEALLOCATE(InputFileData%GenSpd_TLU)
ENDIF
IF (ALLOCATED(InputFileData%GenTrq_TLU)) THEN
   DEALLOCATE(InputFileData%GenTrq_TLU)
ENDIF
 END SUBROUTINE SrvD_DestroyInputFile

 SUBROUTINE SrvD_PackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_InputFile),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Int_BufSz  = Int_BufSz  + 1  ! PCMode
  Db_BufSz   = Db_BufSz   + 1  ! TPCOn
  Db_BufSz    = Db_BufSz    + SIZE( InData%TPitManS )  ! TPitManS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PitManRat )  ! PitManRat 
  Re_BufSz    = Re_BufSz    + SIZE( InData%BlPitchF )  ! BlPitchF 
  Int_BufSz  = Int_BufSz  + 1  ! VSContrl
  Int_BufSz  = Int_BufSz  + 1  ! GenModel
  Re_BufSz   = Re_BufSz   + 1  ! GenEff
  Int_BufSz  = Int_BufSz  + 1  ! GenTiStr
  Int_BufSz  = Int_BufSz  + 1  ! GenTiStp
  Re_BufSz   = Re_BufSz   + 1  ! SpdGenOn
  Db_BufSz   = Db_BufSz   + 1  ! TimGenOn
  Db_BufSz   = Db_BufSz   + 1  ! TimGenOf
  Re_BufSz   = Re_BufSz   + 1  ! VS_RtGnSp
  Re_BufSz   = Re_BufSz   + 1  ! VS_RtTq
  Re_BufSz   = Re_BufSz   + 1  ! VS_Rgn2K
  Re_BufSz   = Re_BufSz   + 1  ! VS_SlPc
  Re_BufSz   = Re_BufSz   + 1  ! SIG_SlPc
  Re_BufSz   = Re_BufSz   + 1  ! SIG_SySp
  Re_BufSz   = Re_BufSz   + 1  ! SIG_RtTq
  Re_BufSz   = Re_BufSz   + 1  ! SIG_PORt
  Re_BufSz   = Re_BufSz   + 1  ! TEC_Freq
  Int_BufSz  = Int_BufSz  + 1  ! TEC_NPol
  Re_BufSz   = Re_BufSz   + 1  ! TEC_SRes
  Re_BufSz   = Re_BufSz   + 1  ! TEC_RRes
  Re_BufSz   = Re_BufSz   + 1  ! TEC_VLL
  Re_BufSz   = Re_BufSz   + 1  ! TEC_SLR
  Re_BufSz   = Re_BufSz   + 1  ! TEC_RLR
  Re_BufSz   = Re_BufSz   + 1  ! TEC_MR
  Int_BufSz  = Int_BufSz  + 1  ! HSSBrMode
  Db_BufSz   = Db_BufSz   + 1  ! THSSBrDp
  Db_BufSz   = Db_BufSz   + 1  ! HSSBrDT
  Re_BufSz   = Re_BufSz   + 1  ! HSSBrTqF
  Int_BufSz  = Int_BufSz  + 1  ! YCMode
  Db_BufSz   = Db_BufSz   + 1  ! TYCOn
  Re_BufSz   = Re_BufSz   + 1  ! YawNeut
  Re_BufSz   = Re_BufSz   + 1  ! YawSpr
  Re_BufSz   = Re_BufSz   + 1  ! YawDamp
  Db_BufSz   = Db_BufSz   + 1  ! TYawManS
  Re_BufSz   = Re_BufSz   + 1  ! YawManRat
  Re_BufSz   = Re_BufSz   + 1  ! NacYawF
  Int_BufSz  = Int_BufSz  + 1  ! SumPrint
  Int_BufSz  = Int_BufSz  + 1  ! OutFile
  Int_BufSz  = Int_BufSz  + 1  ! TabDelim
!  missing buffer for OutFmt
  Db_BufSz   = Db_BufSz   + 1  ! Tstart
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
!  missing buffer for OutList
!  missing buffer for DLL_FileName
!  missing buffer for DLL_ProcName
!  missing buffer for DLL_InFile
  Re_BufSz   = Re_BufSz   + 1  ! NacYaw_North
  Int_BufSz  = Int_BufSz  + 1  ! Ptch_Cntrl
  Re_BufSz   = Re_BufSz   + 1  ! Ptch_SetPnt
  Re_BufSz   = Re_BufSz   + 1  ! Ptch_Min
  Re_BufSz   = Re_BufSz   + 1  ! Ptch_Max
  Re_BufSz   = Re_BufSz   + 1  ! PtchRate_Min
  Re_BufSz   = Re_BufSz   + 1  ! PtchRate_Max
  Re_BufSz   = Re_BufSz   + 1  ! Gain_OM
  Re_BufSz   = Re_BufSz   + 1  ! GenSpd_MinOM
  Re_BufSz   = Re_BufSz   + 1  ! GenSpd_MaxOM
  Re_BufSz   = Re_BufSz   + 1  ! GenSpd_Dem
  Re_BufSz   = Re_BufSz   + 1  ! GenTrq_Dem
  Re_BufSz   = Re_BufSz   + 1  ! GenPwr_Dem
  Int_BufSz  = Int_BufSz  + 1  ! DLL_NumTrq
  IF ( ALLOCATED(InData%GenSpd_TLU) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GenSpd_TLU )  ! GenSpd_TLU 
  IF ( ALLOCATED(InData%GenTrq_TLU) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GenTrq_TLU )  ! GenTrq_TLU 
  Int_BufSz  = Int_BufSz  + 1  ! CompNTMD
!  missing buffer for NTMDfile
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%PCMode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TPCOn )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%TPitManS))-1 ) =  PACK(InData%TPitManS ,.TRUE.)
  Db_Xferred   = Db_Xferred   + SIZE(InData%TPitManS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PitManRat))-1 ) =  PACK(InData%PitManRat ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PitManRat)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BlPitchF))-1 ) =  PACK(InData%BlPitchF ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%BlPitchF)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%VSContrl )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%GenModel )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenEff )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%GenTiStr ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%GenTiStp ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SpdGenOn )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TimGenOn )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TimGenOf )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_RtGnSp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_RtTq )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_Rgn2K )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_SlPc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SIG_SlPc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SIG_SySp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SIG_RtTq )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SIG_PORt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_Freq )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TEC_NPol )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_SRes )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_RRes )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_VLL )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_SLR )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_RLR )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_MR )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%HSSBrMode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%THSSBrDp )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%HSSBrDT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HSSBrTqF )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%YCMode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TYCOn )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawNeut )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawSpr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawDamp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TYawManS )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawManRat )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NacYawF )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%SumPrint ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutFile )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%TabDelim ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%Tstart )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NacYaw_North )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Ptch_Cntrl )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ptch_SetPnt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ptch_Min )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ptch_Max )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtchRate_Min )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtchRate_Max )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gain_OM )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenSpd_MinOM )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenSpd_MaxOM )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenSpd_Dem )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenTrq_Dem )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenPwr_Dem )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DLL_NumTrq )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%GenSpd_TLU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GenSpd_TLU))-1 ) =  PACK(InData%GenSpd_TLU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GenSpd_TLU)
  ENDIF
  IF ( ALLOCATED(InData%GenTrq_TLU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GenTrq_TLU))-1 ) =  PACK(InData%GenTrq_TLU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GenTrq_TLU)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%CompNTMD ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SrvD_PackInputFile

 SUBROUTINE SrvD_UnPackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_InputFile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%PCMode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TPCOn = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%TPitManS,1)))
  mask1 = .TRUE.
  OutData%TPitManS = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%TPitManS))-1 ),mask1,OutData%TPitManS)
  DEALLOCATE(mask1)
  Db_Xferred   = Db_Xferred   + SIZE(OutData%TPitManS)
  ALLOCATE(mask1(SIZE(OutData%PitManRat,1)))
  mask1 = .TRUE.
  OutData%PitManRat = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PitManRat))-1 ),mask1,OutData%PitManRat)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PitManRat)
  ALLOCATE(mask1(SIZE(OutData%BlPitchF,1)))
  mask1 = .TRUE.
  OutData%BlPitchF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BlPitchF))-1 ),mask1,OutData%BlPitchF)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%BlPitchF)
  OutData%VSContrl = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%GenModel = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%GenEff = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SpdGenOn = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TimGenOn = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%TimGenOf = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%VS_RtGnSp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%VS_RtTq = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%VS_Rgn2K = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%VS_SlPc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SIG_SlPc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SIG_SySp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SIG_RtTq = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SIG_PORt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_Freq = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_NPol = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TEC_SRes = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_RRes = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_VLL = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_SLR = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_RLR = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_MR = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HSSBrMode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%THSSBrDp = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%HSSBrDT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%HSSBrTqF = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YCMode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TYCOn = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%YawNeut = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawSpr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawDamp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TYawManS = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%YawManRat = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NacYawF = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%OutFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Tstart = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NacYaw_North = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ptch_Cntrl = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Ptch_SetPnt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ptch_Min = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ptch_Max = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PtchRate_Min = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PtchRate_Max = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Gain_OM = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenSpd_MinOM = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenSpd_MaxOM = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenSpd_Dem = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenTrq_Dem = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenPwr_Dem = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DLL_NumTrq = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%GenSpd_TLU) ) THEN
  ALLOCATE(mask1(SIZE(OutData%GenSpd_TLU,1)))
  mask1 = .TRUE.
    OutData%GenSpd_TLU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GenSpd_TLU))-1 ),mask1,OutData%GenSpd_TLU)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GenSpd_TLU)
  ENDIF
  IF ( ALLOCATED(OutData%GenTrq_TLU) ) THEN
  ALLOCATE(mask1(SIZE(OutData%GenTrq_TLU,1)))
  mask1 = .TRUE.
    OutData%GenTrq_TLU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GenTrq_TLU))-1 ),mask1,OutData%GenTrq_TLU)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GenTrq_TLU)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackInputFile

 SUBROUTINE SrvD_CopyBladedDLLType( SrcBladedDLLTypeData, DstBladedDLLTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BladedDLLType), INTENT(IN) :: SrcBladedDLLTypeData
   TYPE(BladedDLLType), INTENT(INOUT) :: DstBladedDLLTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcBladedDLLTypeData%avrSWAP)) THEN
   i1_l = LBOUND(SrcBladedDLLTypeData%avrSWAP,1)
   i1_u = UBOUND(SrcBladedDLLTypeData%avrSWAP,1)
   IF (.NOT. ALLOCATED(DstBladedDLLTypeData%avrSWAP)) THEN 
      ALLOCATE(DstBladedDLLTypeData%avrSWAP(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%avrSWAP.', ErrStat, ErrMsg,'SrvD_CopyBladedDLLType')
         RETURN
      END IF
   END IF
   DstBladedDLLTypeData%avrSWAP = SrcBladedDLLTypeData%avrSWAP
ENDIF
   DstBladedDLLTypeData%HSSBrFrac = SrcBladedDLLTypeData%HSSBrFrac
   DstBladedDLLTypeData%YawRateCom = SrcBladedDLLTypeData%YawRateCom
   DstBladedDLLTypeData%GenTrq = SrcBladedDLLTypeData%GenTrq
   DstBladedDLLTypeData%GenState = SrcBladedDLLTypeData%GenState
   DstBladedDLLTypeData%BlPitchCom = SrcBladedDLLTypeData%BlPitchCom
 END SUBROUTINE SrvD_CopyBladedDLLType

 SUBROUTINE SrvD_DestroyBladedDLLType( BladedDLLTypeData, ErrStat, ErrMsg )
  TYPE(BladedDLLType), INTENT(INOUT) :: BladedDLLTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(BladedDLLTypeData%avrSWAP)) THEN
   DEALLOCATE(BladedDLLTypeData%avrSWAP)
ENDIF
 END SUBROUTINE SrvD_DestroyBladedDLLType

 SUBROUTINE SrvD_PackBladedDLLType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BladedDLLType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%avrSWAP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%avrSWAP )  ! avrSWAP 
  Re_BufSz   = Re_BufSz   + 1  ! HSSBrFrac
  Re_BufSz   = Re_BufSz   + 1  ! YawRateCom
  Re_BufSz   = Re_BufSz   + 1  ! GenTrq
  Int_BufSz  = Int_BufSz  + 1  ! GenState
  Re_BufSz    = Re_BufSz    + SIZE( InData%BlPitchCom )  ! BlPitchCom 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%avrSWAP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%avrSWAP))-1 ) =  PACK(InData%avrSWAP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%avrSWAP)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HSSBrFrac )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawRateCom )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenTrq )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%GenState )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BlPitchCom))-1 ) =  PACK(InData%BlPitchCom ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%BlPitchCom)
 END SUBROUTINE SrvD_PackBladedDLLType

 SUBROUTINE SrvD_UnPackBladedDLLType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BladedDLLType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%avrSWAP) ) THEN
  ALLOCATE(mask1(SIZE(OutData%avrSWAP,1)))
  mask1 = .TRUE.
    OutData%avrSWAP = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%avrSWAP))-1 ),mask1,REAL(OutData%avrSWAP,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%avrSWAP)
  ENDIF
  OutData%HSSBrFrac = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawRateCom = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenTrq = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenState = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%BlPitchCom,1)))
  mask1 = .TRUE.
  OutData%BlPitchCom = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BlPitchCom))-1 ),mask1,OutData%BlPitchCom)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%BlPitchCom)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackBladedDLLType

 SUBROUTINE SrvD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(SrvD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%InputFile = SrcInitInputData%InputFile
   DstInitInputData%NumBl = SrcInitInputData%NumBl
   DstInitInputData%RootName = SrcInitInputData%RootName
IF (ALLOCATED(SrcInitInputData%BlPitchInit)) THEN
   i1_l = LBOUND(SrcInitInputData%BlPitchInit,1)
   i1_u = UBOUND(SrcInitInputData%BlPitchInit,1)
   IF (.NOT. ALLOCATED(DstInitInputData%BlPitchInit)) THEN 
      ALLOCATE(DstInitInputData%BlPitchInit(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%BlPitchInit.', ErrStat, ErrMsg,'SrvD_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%BlPitchInit = SrcInitInputData%BlPitchInit
ENDIF
   DstInitInputData%Gravity = SrcInitInputData%Gravity
   DstInitInputData%r_N_O_G = SrcInitInputData%r_N_O_G
   DstInitInputData%Tmax = SrcInitInputData%Tmax
 END SUBROUTINE SrvD_CopyInitInput

 SUBROUTINE SrvD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SrvD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%BlPitchInit)) THEN
   DEALLOCATE(InitInputData%BlPitchInit)
ENDIF
 END SUBROUTINE SrvD_DestroyInitInput

 SUBROUTINE SrvD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for InputFile
  Int_BufSz  = Int_BufSz  + 1  ! NumBl
!  missing buffer for RootName
  IF ( ALLOCATED(InData%BlPitchInit) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BlPitchInit )  ! BlPitchInit 
  Re_BufSz   = Re_BufSz   + 1  ! Gravity
  Re_BufSz    = Re_BufSz    + SIZE( InData%r_N_O_G )  ! r_N_O_G 
  Db_BufSz   = Db_BufSz   + 1  ! Tmax
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumBl )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%BlPitchInit) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BlPitchInit))-1 ) =  PACK(InData%BlPitchInit ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BlPitchInit)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%r_N_O_G))-1 ) =  PACK(InData%r_N_O_G ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%r_N_O_G)
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%Tmax )
  Db_Xferred   = Db_Xferred   + 1
 END SUBROUTINE SrvD_PackInitInput

 SUBROUTINE SrvD_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%NumBl = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%BlPitchInit) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BlPitchInit,1)))
  mask1 = .TRUE.
    OutData%BlPitchInit = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BlPitchInit))-1 ),mask1,OutData%BlPitchInit)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BlPitchInit)
  ENDIF
  OutData%Gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%r_N_O_G,1)))
  mask1 = .TRUE.
  OutData%r_N_O_G = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%r_N_O_G))-1 ),mask1,OutData%r_N_O_G)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%r_N_O_G)
  OutData%Tmax = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackInitInput

 SUBROUTINE SrvD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(SrvD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'SrvD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'SrvD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyInitOutput:Ver')
         IF (ErrStat>=AbortErrLev) RETURN
   DstInitOutputData%CouplingScheme = SrcInitOutputData%CouplingScheme
   DstInitOutputData%UseHSSBrake = SrcInitOutputData%UseHSSBrake
 END SUBROUTINE SrvD_CopyInitOutput

 SUBROUTINE SrvD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SrvD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
 END SUBROUTINE SrvD_DestroyInitOutput

 SUBROUTINE SrvD_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  Int_BufSz  = Int_BufSz  + 1  ! CouplingScheme
  Int_BufSz  = Int_BufSz  + 1  ! UseHSSBrake
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%CouplingScheme )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%UseHSSBrake ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SrvD_PackInitOutput

 SUBROUTINE SrvD_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  OutData%CouplingScheme = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackInitOutput

 SUBROUTINE SrvD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(SrvD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%DummyContState = SrcContStateData%DummyContState
      CALL TMD_CopyContState( SrcContStateData%NTMD, DstContStateData%NTMD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyContState:NTMD')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SrvD_CopyContState

 SUBROUTINE SrvD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(SrvD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL TMD_DestroyContState( ContStateData%NTMD, ErrStat, ErrMsg )
 END SUBROUTINE SrvD_DestroyContState

 SUBROUTINE SrvD_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_NTMD_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  CALL TMD_PackContState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Db_NTMD_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Int_NTMD_Buf))Int_BufSz = Int_BufSz + SIZE( Int_NTMD_Buf ) ! NTMD
  IF(ALLOCATED(Re_NTMD_Buf))  DEALLOCATE(Re_NTMD_Buf)
  IF(ALLOCATED(Db_NTMD_Buf))  DEALLOCATE(Db_NTMD_Buf)
  IF(ALLOCATED(Int_NTMD_Buf)) DEALLOCATE(Int_NTMD_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
  CALL TMD_PackContState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, OnlySize ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 ) = Re_NTMD_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 ) = Db_NTMD_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 ) = Int_NTMD_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  IF( ALLOCATED(Re_NTMD_Buf) )  DEALLOCATE(Re_NTMD_Buf)
  IF( ALLOCATED(Db_NTMD_Buf) )  DEALLOCATE(Db_NTMD_Buf)
  IF( ALLOCATED(Int_NTMD_Buf) ) DEALLOCATE(Int_NTMD_Buf)
 END SUBROUTINE SrvD_PackContState

 SUBROUTINE SrvD_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_NTMD_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
 ! first call TMD_PackContState to get correctly sized buffers for unpacking
  CALL TMD_PackContState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    Re_NTMD_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    Db_NTMD_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    Int_NTMD_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  CALL TMD_UnPackContState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg ) ! NTMD 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackContState

 SUBROUTINE SrvD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(SrvD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
      CALL TMD_CopyDiscState( SrcDiscStateData%NTMD, DstDiscStateData%NTMD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyDiscState:NTMD')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SrvD_CopyDiscState

 SUBROUTINE SrvD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(SrvD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL TMD_DestroyDiscState( DiscStateData%NTMD, ErrStat, ErrMsg )
 END SUBROUTINE SrvD_DestroyDiscState

 SUBROUTINE SrvD_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_NTMD_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  CALL TMD_PackDiscState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Db_NTMD_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Int_NTMD_Buf))Int_BufSz = Int_BufSz + SIZE( Int_NTMD_Buf ) ! NTMD
  IF(ALLOCATED(Re_NTMD_Buf))  DEALLOCATE(Re_NTMD_Buf)
  IF(ALLOCATED(Db_NTMD_Buf))  DEALLOCATE(Db_NTMD_Buf)
  IF(ALLOCATED(Int_NTMD_Buf)) DEALLOCATE(Int_NTMD_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
  CALL TMD_PackDiscState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, OnlySize ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 ) = Re_NTMD_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 ) = Db_NTMD_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 ) = Int_NTMD_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  IF( ALLOCATED(Re_NTMD_Buf) )  DEALLOCATE(Re_NTMD_Buf)
  IF( ALLOCATED(Db_NTMD_Buf) )  DEALLOCATE(Db_NTMD_Buf)
  IF( ALLOCATED(Int_NTMD_Buf) ) DEALLOCATE(Int_NTMD_Buf)
 END SUBROUTINE SrvD_PackDiscState

 SUBROUTINE SrvD_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_NTMD_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
 ! first call TMD_PackDiscState to get correctly sized buffers for unpacking
  CALL TMD_PackDiscState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    Re_NTMD_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    Db_NTMD_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    Int_NTMD_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  CALL TMD_UnPackDiscState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg ) ! NTMD 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackDiscState

 SUBROUTINE SrvD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(SrvD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
      CALL TMD_CopyConstrState( SrcConstrStateData%NTMD, DstConstrStateData%NTMD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyConstrState:NTMD')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SrvD_CopyConstrState

 SUBROUTINE SrvD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(SrvD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL TMD_DestroyConstrState( ConstrStateData%NTMD, ErrStat, ErrMsg )
 END SUBROUTINE SrvD_DestroyConstrState

 SUBROUTINE SrvD_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_NTMD_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  CALL TMD_PackConstrState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Db_NTMD_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Int_NTMD_Buf))Int_BufSz = Int_BufSz + SIZE( Int_NTMD_Buf ) ! NTMD
  IF(ALLOCATED(Re_NTMD_Buf))  DEALLOCATE(Re_NTMD_Buf)
  IF(ALLOCATED(Db_NTMD_Buf))  DEALLOCATE(Db_NTMD_Buf)
  IF(ALLOCATED(Int_NTMD_Buf)) DEALLOCATE(Int_NTMD_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
  CALL TMD_PackConstrState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, OnlySize ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 ) = Re_NTMD_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 ) = Db_NTMD_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 ) = Int_NTMD_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  IF( ALLOCATED(Re_NTMD_Buf) )  DEALLOCATE(Re_NTMD_Buf)
  IF( ALLOCATED(Db_NTMD_Buf) )  DEALLOCATE(Db_NTMD_Buf)
  IF( ALLOCATED(Int_NTMD_Buf) ) DEALLOCATE(Int_NTMD_Buf)
 END SUBROUTINE SrvD_PackConstrState

 SUBROUTINE SrvD_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_NTMD_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
 ! first call TMD_PackConstrState to get correctly sized buffers for unpacking
  CALL TMD_PackConstrState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    Re_NTMD_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    Db_NTMD_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    Int_NTMD_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  CALL TMD_UnPackConstrState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg ) ! NTMD 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackConstrState

 SUBROUTINE SrvD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(SrvD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%BlPitchI)) THEN
   i1_l = LBOUND(SrcOtherStateData%BlPitchI,1)
   i1_u = UBOUND(SrcOtherStateData%BlPitchI,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%BlPitchI)) THEN 
      ALLOCATE(DstOtherStateData%BlPitchI(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%BlPitchI.', ErrStat, ErrMsg,'SrvD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%BlPitchI = SrcOtherStateData%BlPitchI
ENDIF
IF (ALLOCATED(SrcOtherStateData%BegPitMan)) THEN
   i1_l = LBOUND(SrcOtherStateData%BegPitMan,1)
   i1_u = UBOUND(SrcOtherStateData%BegPitMan,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%BegPitMan)) THEN 
      ALLOCATE(DstOtherStateData%BegPitMan(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%BegPitMan.', ErrStat, ErrMsg,'SrvD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%BegPitMan = SrcOtherStateData%BegPitMan
ENDIF
   DstOtherStateData%BegYawMan = SrcOtherStateData%BegYawMan
   DstOtherStateData%NacYawI = SrcOtherStateData%NacYawI
   DstOtherStateData%YawManRat = SrcOtherStateData%YawManRat
   DstOtherStateData%TYawManE = SrcOtherStateData%TYawManE
IF (ALLOCATED(SrcOtherStateData%TTpBrDp)) THEN
   i1_l = LBOUND(SrcOtherStateData%TTpBrDp,1)
   i1_u = UBOUND(SrcOtherStateData%TTpBrDp,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%TTpBrDp)) THEN 
      ALLOCATE(DstOtherStateData%TTpBrDp(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%TTpBrDp.', ErrStat, ErrMsg,'SrvD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%TTpBrDp = SrcOtherStateData%TTpBrDp
ENDIF
IF (ALLOCATED(SrcOtherStateData%TTpBrFl)) THEN
   i1_l = LBOUND(SrcOtherStateData%TTpBrFl,1)
   i1_u = UBOUND(SrcOtherStateData%TTpBrFl,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%TTpBrFl)) THEN 
      ALLOCATE(DstOtherStateData%TTpBrFl(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%TTpBrFl.', ErrStat, ErrMsg,'SrvD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%TTpBrFl = SrcOtherStateData%TTpBrFl
ENDIF
IF (ALLOCATED(SrcOtherStateData%TPitManE)) THEN
   i1_l = LBOUND(SrcOtherStateData%TPitManE,1)
   i1_u = UBOUND(SrcOtherStateData%TPitManE,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%TPitManE)) THEN 
      ALLOCATE(DstOtherStateData%TPitManE(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%TPitManE.', ErrStat, ErrMsg,'SrvD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%TPitManE = SrcOtherStateData%TPitManE
ENDIF
IF (ALLOCATED(SrcOtherStateData%PitManRat)) THEN
   i1_l = LBOUND(SrcOtherStateData%PitManRat,1)
   i1_u = UBOUND(SrcOtherStateData%PitManRat,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%PitManRat)) THEN 
      ALLOCATE(DstOtherStateData%PitManRat(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%PitManRat.', ErrStat, ErrMsg,'SrvD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%PitManRat = SrcOtherStateData%PitManRat
ENDIF
   DstOtherStateData%TOff4Good = SrcOtherStateData%TOff4Good
   DstOtherStateData%TGenOnLine = SrcOtherStateData%TGenOnLine
      CALL SrvD_Copybladeddlltype( SrcOtherStateData%dll_data, DstOtherStateData%dll_data, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyOtherState:dll_data')
         IF (ErrStat>=AbortErrLev) RETURN
   DstOtherStateData%LastTimeCalled = SrcOtherStateData%LastTimeCalled
   DstOtherStateData%FirstWarn = SrcOtherStateData%FirstWarn
      CALL TMD_CopyOtherState( SrcOtherStateData%NTMD, DstOtherStateData%NTMD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyOtherState:NTMD')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SrvD_CopyOtherState

 SUBROUTINE SrvD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(SrvD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%BlPitchI)) THEN
   DEALLOCATE(OtherStateData%BlPitchI)
ENDIF
IF (ALLOCATED(OtherStateData%BegPitMan)) THEN
   DEALLOCATE(OtherStateData%BegPitMan)
ENDIF
IF (ALLOCATED(OtherStateData%TTpBrDp)) THEN
   DEALLOCATE(OtherStateData%TTpBrDp)
ENDIF
IF (ALLOCATED(OtherStateData%TTpBrFl)) THEN
   DEALLOCATE(OtherStateData%TTpBrFl)
ENDIF
IF (ALLOCATED(OtherStateData%TPitManE)) THEN
   DEALLOCATE(OtherStateData%TPitManE)
ENDIF
IF (ALLOCATED(OtherStateData%PitManRat)) THEN
   DEALLOCATE(OtherStateData%PitManRat)
ENDIF
  CALL SrvD_Destroybladeddlltype( OtherStateData%dll_data, ErrStat, ErrMsg )
  CALL TMD_DestroyOtherState( OtherStateData%NTMD, ErrStat, ErrMsg )
 END SUBROUTINE SrvD_DestroyOtherState

 SUBROUTINE SrvD_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_dll_data_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_dll_data_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_dll_data_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_NTMD_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%BlPitchI) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BlPitchI )  ! BlPitchI 
  IF ( ALLOCATED(InData%BegPitMan) )   Db_BufSz    = Db_BufSz    + SIZE( InData%BegPitMan )  ! BegPitMan 
  Db_BufSz   = Db_BufSz   + 1  ! BegYawMan
  Re_BufSz   = Re_BufSz   + 1  ! NacYawI
  Re_BufSz   = Re_BufSz   + 1  ! YawManRat
  Db_BufSz   = Db_BufSz   + 1  ! TYawManE
  IF ( ALLOCATED(InData%TTpBrDp) )   Db_BufSz    = Db_BufSz    + SIZE( InData%TTpBrDp )  ! TTpBrDp 
  IF ( ALLOCATED(InData%TTpBrFl) )   Db_BufSz    = Db_BufSz    + SIZE( InData%TTpBrFl )  ! TTpBrFl 
  IF ( ALLOCATED(InData%TPitManE) )   Db_BufSz    = Db_BufSz    + SIZE( InData%TPitManE )  ! TPitManE 
  IF ( ALLOCATED(InData%PitManRat) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PitManRat )  ! PitManRat 
  Db_BufSz   = Db_BufSz   + 1  ! TOff4Good
  Db_BufSz   = Db_BufSz   + 1  ! TGenOnLine
  CALL SrvD_Packbladeddlltype( Re_dll_data_Buf, Db_dll_data_Buf, Int_dll_data_Buf, InData%dll_data, ErrStat, ErrMsg, .TRUE. ) ! dll_data 
  IF(ALLOCATED(Re_dll_data_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_dll_data_Buf  ) ! dll_data
  IF(ALLOCATED(Db_dll_data_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_dll_data_Buf  ) ! dll_data
  IF(ALLOCATED(Int_dll_data_Buf))Int_BufSz = Int_BufSz + SIZE( Int_dll_data_Buf ) ! dll_data
  IF(ALLOCATED(Re_dll_data_Buf))  DEALLOCATE(Re_dll_data_Buf)
  IF(ALLOCATED(Db_dll_data_Buf))  DEALLOCATE(Db_dll_data_Buf)
  IF(ALLOCATED(Int_dll_data_Buf)) DEALLOCATE(Int_dll_data_Buf)
  Db_BufSz   = Db_BufSz   + 1  ! LastTimeCalled
  Int_BufSz  = Int_BufSz  + 1  ! FirstWarn
  CALL TMD_PackOtherState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Db_NTMD_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Int_NTMD_Buf))Int_BufSz = Int_BufSz + SIZE( Int_NTMD_Buf ) ! NTMD
  IF(ALLOCATED(Re_NTMD_Buf))  DEALLOCATE(Re_NTMD_Buf)
  IF(ALLOCATED(Db_NTMD_Buf))  DEALLOCATE(Db_NTMD_Buf)
  IF(ALLOCATED(Int_NTMD_Buf)) DEALLOCATE(Int_NTMD_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%BlPitchI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BlPitchI))-1 ) =  PACK(InData%BlPitchI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BlPitchI)
  ENDIF
  IF ( ALLOCATED(InData%BegPitMan) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%BegPitMan))-1 ) =  PACK(InData%BegPitMan ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%BegPitMan)
  ENDIF
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%BegYawMan )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NacYawI )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawManRat )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TYawManE )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%TTpBrDp) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%TTpBrDp))-1 ) =  PACK(InData%TTpBrDp ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%TTpBrDp)
  ENDIF
  IF ( ALLOCATED(InData%TTpBrFl) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%TTpBrFl))-1 ) =  PACK(InData%TTpBrFl ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%TTpBrFl)
  ENDIF
  IF ( ALLOCATED(InData%TPitManE) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%TPitManE))-1 ) =  PACK(InData%TPitManE ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%TPitManE)
  ENDIF
  IF ( ALLOCATED(InData%PitManRat) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PitManRat))-1 ) =  PACK(InData%PitManRat ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PitManRat)
  ENDIF
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TOff4Good )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TGenOnLine )
  Db_Xferred   = Db_Xferred   + 1
  CALL SrvD_Packbladeddlltype( Re_dll_data_Buf, Db_dll_data_Buf, Int_dll_data_Buf, InData%dll_data, ErrStat, ErrMsg, OnlySize ) ! dll_data 
  IF(ALLOCATED(Re_dll_data_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_dll_data_Buf)-1 ) = Re_dll_data_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_dll_data_Buf)
  ENDIF
  IF(ALLOCATED(Db_dll_data_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_dll_data_Buf)-1 ) = Db_dll_data_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_dll_data_Buf)
  ENDIF
  IF(ALLOCATED(Int_dll_data_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_dll_data_Buf)-1 ) = Int_dll_data_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_dll_data_Buf)
  ENDIF
  IF( ALLOCATED(Re_dll_data_Buf) )  DEALLOCATE(Re_dll_data_Buf)
  IF( ALLOCATED(Db_dll_data_Buf) )  DEALLOCATE(Db_dll_data_Buf)
  IF( ALLOCATED(Int_dll_data_Buf) ) DEALLOCATE(Int_dll_data_Buf)
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%LastTimeCalled )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%FirstWarn ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  CALL TMD_PackOtherState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, OnlySize ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 ) = Re_NTMD_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 ) = Db_NTMD_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 ) = Int_NTMD_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  IF( ALLOCATED(Re_NTMD_Buf) )  DEALLOCATE(Re_NTMD_Buf)
  IF( ALLOCATED(Db_NTMD_Buf) )  DEALLOCATE(Db_NTMD_Buf)
  IF( ALLOCATED(Int_NTMD_Buf) ) DEALLOCATE(Int_NTMD_Buf)
 END SUBROUTINE SrvD_PackOtherState

 SUBROUTINE SrvD_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_dll_data_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_dll_data_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_dll_data_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_NTMD_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%BlPitchI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BlPitchI,1)))
  mask1 = .TRUE.
    OutData%BlPitchI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BlPitchI))-1 ),mask1,OutData%BlPitchI)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BlPitchI)
  ENDIF
  IF ( ALLOCATED(OutData%BegPitMan) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BegPitMan,1)))
  mask1 = .TRUE.
    OutData%BegPitMan = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%BegPitMan))-1 ),mask1,OutData%BegPitMan)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%BegPitMan)
  ENDIF
  OutData%BegYawMan = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%NacYawI = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawManRat = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TYawManE = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%TTpBrDp) ) THEN
  ALLOCATE(mask1(SIZE(OutData%TTpBrDp,1)))
  mask1 = .TRUE.
    OutData%TTpBrDp = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%TTpBrDp))-1 ),mask1,OutData%TTpBrDp)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%TTpBrDp)
  ENDIF
  IF ( ALLOCATED(OutData%TTpBrFl) ) THEN
  ALLOCATE(mask1(SIZE(OutData%TTpBrFl,1)))
  mask1 = .TRUE.
    OutData%TTpBrFl = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%TTpBrFl))-1 ),mask1,OutData%TTpBrFl)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%TTpBrFl)
  ENDIF
  IF ( ALLOCATED(OutData%TPitManE) ) THEN
  ALLOCATE(mask1(SIZE(OutData%TPitManE,1)))
  mask1 = .TRUE.
    OutData%TPitManE = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%TPitManE))-1 ),mask1,OutData%TPitManE)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%TPitManE)
  ENDIF
  IF ( ALLOCATED(OutData%PitManRat) ) THEN
  ALLOCATE(mask1(SIZE(OutData%PitManRat,1)))
  mask1 = .TRUE.
    OutData%PitManRat = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PitManRat))-1 ),mask1,OutData%PitManRat)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PitManRat)
  ENDIF
  OutData%TOff4Good = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%TGenOnLine = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
 ! first call SrvD_Packbladeddlltype to get correctly sized buffers for unpacking
  CALL SrvD_Packbladeddlltype( Re_dll_data_Buf, Db_dll_data_Buf, Int_dll_data_Buf, OutData%dll_data, ErrStat, ErrMsg, .TRUE. ) ! dll_data 
  IF(ALLOCATED(Re_dll_data_Buf)) THEN
    Re_dll_data_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_dll_data_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_dll_data_Buf)
  ENDIF
  IF(ALLOCATED(Db_dll_data_Buf)) THEN
    Db_dll_data_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_dll_data_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_dll_data_Buf)
  ENDIF
  IF(ALLOCATED(Int_dll_data_Buf)) THEN
    Int_dll_data_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_dll_data_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_dll_data_Buf)
  ENDIF
  CALL SrvD_UnPackbladeddlltype( Re_dll_data_Buf, Db_dll_data_Buf, Int_dll_data_Buf, OutData%dll_data, ErrStat, ErrMsg ) ! dll_data 
  OutData%LastTimeCalled = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
 ! first call TMD_PackOtherState to get correctly sized buffers for unpacking
  CALL TMD_PackOtherState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    Re_NTMD_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    Db_NTMD_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    Int_NTMD_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  CALL TMD_UnPackOtherState( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg ) ! NTMD 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackOtherState

 SUBROUTINE SrvD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(SrvD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%DT = SrcParamData%DT
   DstParamData%HSSBrDT = SrcParamData%HSSBrDT
   DstParamData%HSSBrFrac = SrcParamData%HSSBrFrac
   DstParamData%HSSBrTqF = SrcParamData%HSSBrTqF
   DstParamData%SIG_POSl = SrcParamData%SIG_POSl
   DstParamData%SIG_POTq = SrcParamData%SIG_POTq
   DstParamData%SIG_SlPc = SrcParamData%SIG_SlPc
   DstParamData%SIG_Slop = SrcParamData%SIG_Slop
   DstParamData%SIG_SySp = SrcParamData%SIG_SySp
   DstParamData%TEC_A0 = SrcParamData%TEC_A0
   DstParamData%TEC_C0 = SrcParamData%TEC_C0
   DstParamData%TEC_C1 = SrcParamData%TEC_C1
   DstParamData%TEC_C2 = SrcParamData%TEC_C2
   DstParamData%TEC_K2 = SrcParamData%TEC_K2
   DstParamData%TEC_MR = SrcParamData%TEC_MR
   DstParamData%TEC_Re1 = SrcParamData%TEC_Re1
   DstParamData%TEC_RLR = SrcParamData%TEC_RLR
   DstParamData%TEC_RRes = SrcParamData%TEC_RRes
   DstParamData%TEC_SRes = SrcParamData%TEC_SRes
   DstParamData%TEC_SySp = SrcParamData%TEC_SySp
   DstParamData%TEC_V1a = SrcParamData%TEC_V1a
   DstParamData%TEC_VLL = SrcParamData%TEC_VLL
   DstParamData%TEC_Xe1 = SrcParamData%TEC_Xe1
   DstParamData%GenEff = SrcParamData%GenEff
IF (ALLOCATED(SrcParamData%BlPitchInit)) THEN
   i1_l = LBOUND(SrcParamData%BlPitchInit,1)
   i1_u = UBOUND(SrcParamData%BlPitchInit,1)
   IF (.NOT. ALLOCATED(DstParamData%BlPitchInit)) THEN 
      ALLOCATE(DstParamData%BlPitchInit(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BlPitchInit.', ErrStat, ErrMsg,'SrvD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%BlPitchInit = SrcParamData%BlPitchInit
ENDIF
IF (ALLOCATED(SrcParamData%BlPitchF)) THEN
   i1_l = LBOUND(SrcParamData%BlPitchF,1)
   i1_u = UBOUND(SrcParamData%BlPitchF,1)
   IF (.NOT. ALLOCATED(DstParamData%BlPitchF)) THEN 
      ALLOCATE(DstParamData%BlPitchF(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BlPitchF.', ErrStat, ErrMsg,'SrvD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%BlPitchF = SrcParamData%BlPitchF
ENDIF
   DstParamData%NacYawF = SrcParamData%NacYawF
   DstParamData%SpdGenOn = SrcParamData%SpdGenOn
   DstParamData%THSSBrDp = SrcParamData%THSSBrDp
   DstParamData%THSSBrFl = SrcParamData%THSSBrFl
   DstParamData%TimGenOf = SrcParamData%TimGenOf
   DstParamData%TimGenOn = SrcParamData%TimGenOn
   DstParamData%TPCOn = SrcParamData%TPCOn
IF (ALLOCATED(SrcParamData%TPitManS)) THEN
   i1_l = LBOUND(SrcParamData%TPitManS,1)
   i1_u = UBOUND(SrcParamData%TPitManS,1)
   IF (.NOT. ALLOCATED(DstParamData%TPitManS)) THEN 
      ALLOCATE(DstParamData%TPitManS(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TPitManS.', ErrStat, ErrMsg,'SrvD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%TPitManS = SrcParamData%TPitManS
ENDIF
   DstParamData%TYawManS = SrcParamData%TYawManS
   DstParamData%TYCOn = SrcParamData%TYCOn
   DstParamData%VS_RtGnSp = SrcParamData%VS_RtGnSp
   DstParamData%VS_RtTq = SrcParamData%VS_RtTq
   DstParamData%VS_Slope = SrcParamData%VS_Slope
   DstParamData%VS_SlPc = SrcParamData%VS_SlPc
   DstParamData%VS_SySp = SrcParamData%VS_SySp
   DstParamData%VS_TrGnSp = SrcParamData%VS_TrGnSp
   DstParamData%YawPosCom = SrcParamData%YawPosCom
   DstParamData%YawRateCom = SrcParamData%YawRateCom
   DstParamData%GenModel = SrcParamData%GenModel
   DstParamData%HSSBrMode = SrcParamData%HSSBrMode
   DstParamData%PCMode = SrcParamData%PCMode
   DstParamData%VSContrl = SrcParamData%VSContrl
   DstParamData%YCMode = SrcParamData%YCMode
   DstParamData%GenTiStp = SrcParamData%GenTiStp
   DstParamData%GenTiStr = SrcParamData%GenTiStr
IF (ALLOCATED(SrcParamData%TBDepISp)) THEN
   i1_l = LBOUND(SrcParamData%TBDepISp,1)
   i1_u = UBOUND(SrcParamData%TBDepISp,1)
   IF (.NOT. ALLOCATED(DstParamData%TBDepISp)) THEN 
      ALLOCATE(DstParamData%TBDepISp(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TBDepISp.', ErrStat, ErrMsg,'SrvD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%TBDepISp = SrcParamData%TBDepISp
ENDIF
   DstParamData%VS_Rgn2K = SrcParamData%VS_Rgn2K
   DstParamData%YawNeut = SrcParamData%YawNeut
   DstParamData%YawSpr = SrcParamData%YawSpr
   DstParamData%YawDamp = SrcParamData%YawDamp
   DstParamData%TpBrDT = SrcParamData%TpBrDT
   DstParamData%TBDrConN = SrcParamData%TBDrConN
   DstParamData%TBDrConD = SrcParamData%TBDrConD
   DstParamData%NumBl = SrcParamData%NumBl
   DstParamData%CompNTMD = SrcParamData%CompNTMD
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%RootName = SrcParamData%RootName
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,'SrvD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyParam:OutParam(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%UseBladedInterface = SrcParamData%UseBladedInterface
   DstParamData%DLL_NumTrq = SrcParamData%DLL_NumTrq
   DstParamData%Ptch_Cntrl = SrcParamData%Ptch_Cntrl
   DstParamData%Gain_OM = SrcParamData%Gain_OM
   DstParamData%GenPwr_Dem = SrcParamData%GenPwr_Dem
   DstParamData%GenSpd_Dem = SrcParamData%GenSpd_Dem
   DstParamData%GenSpd_MaxOM = SrcParamData%GenSpd_MaxOM
   DstParamData%GenSpd_MinOM = SrcParamData%GenSpd_MinOM
IF (ALLOCATED(SrcParamData%GenSpd_TLU)) THEN
   i1_l = LBOUND(SrcParamData%GenSpd_TLU,1)
   i1_u = UBOUND(SrcParamData%GenSpd_TLU,1)
   IF (.NOT. ALLOCATED(DstParamData%GenSpd_TLU)) THEN 
      ALLOCATE(DstParamData%GenSpd_TLU(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%GenSpd_TLU.', ErrStat, ErrMsg,'SrvD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%GenSpd_TLU = SrcParamData%GenSpd_TLU
ENDIF
   DstParamData%GenTrq_Dem = SrcParamData%GenTrq_Dem
IF (ALLOCATED(SrcParamData%GenTrq_TLU)) THEN
   i1_l = LBOUND(SrcParamData%GenTrq_TLU,1)
   i1_u = UBOUND(SrcParamData%GenTrq_TLU,1)
   IF (.NOT. ALLOCATED(DstParamData%GenTrq_TLU)) THEN 
      ALLOCATE(DstParamData%GenTrq_TLU(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%GenTrq_TLU.', ErrStat, ErrMsg,'SrvD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%GenTrq_TLU = SrcParamData%GenTrq_TLU
ENDIF
   DstParamData%Ptch_Max = SrcParamData%Ptch_Max
   DstParamData%Ptch_Min = SrcParamData%Ptch_Min
   DstParamData%Ptch_SetPnt = SrcParamData%Ptch_SetPnt
   DstParamData%PtchRate_Max = SrcParamData%PtchRate_Max
   DstParamData%PtchRate_Min = SrcParamData%PtchRate_Min
   DstParamData%NacYaw_North = SrcParamData%NacYaw_North
   DstParamData%DLL_InFile = SrcParamData%DLL_InFile
   DstParamData%DLL_Trgt = SrcParamData%DLL_Trgt
      CALL TMD_CopyParam( SrcParamData%NTMD, DstParamData%NTMD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyParam:NTMD')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SrvD_CopyParam

 SUBROUTINE SrvD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SrvD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%BlPitchInit)) THEN
   DEALLOCATE(ParamData%BlPitchInit)
ENDIF
IF (ALLOCATED(ParamData%BlPitchF)) THEN
   DEALLOCATE(ParamData%BlPitchF)
ENDIF
IF (ALLOCATED(ParamData%TPitManS)) THEN
   DEALLOCATE(ParamData%TPitManS)
ENDIF
IF (ALLOCATED(ParamData%TBDepISp)) THEN
   DEALLOCATE(ParamData%TBDepISp)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
IF (ALLOCATED(ParamData%GenSpd_TLU)) THEN
   DEALLOCATE(ParamData%GenSpd_TLU)
ENDIF
IF (ALLOCATED(ParamData%GenTrq_TLU)) THEN
   DEALLOCATE(ParamData%GenTrq_TLU)
ENDIF
   CALL FreeDynamicLib( ParamData%DLL_Trgt, ErrStat, ErrMsg )
  CALL TMD_DestroyParam( ParamData%NTMD, ErrStat, ErrMsg )
 END SUBROUTINE SrvD_DestroyParam

 SUBROUTINE SrvD_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_DLL_Trgt_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DLL_Trgt_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DLL_Trgt_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_NTMD_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Db_BufSz   = Db_BufSz   + 1  ! HSSBrDT
  Re_BufSz   = Re_BufSz   + 1  ! HSSBrFrac
  Re_BufSz   = Re_BufSz   + 1  ! HSSBrTqF
  Re_BufSz   = Re_BufSz   + 1  ! SIG_POSl
  Re_BufSz   = Re_BufSz   + 1  ! SIG_POTq
  Re_BufSz   = Re_BufSz   + 1  ! SIG_SlPc
  Re_BufSz   = Re_BufSz   + 1  ! SIG_Slop
  Re_BufSz   = Re_BufSz   + 1  ! SIG_SySp
  Re_BufSz   = Re_BufSz   + 1  ! TEC_A0
  Re_BufSz   = Re_BufSz   + 1  ! TEC_C0
  Re_BufSz   = Re_BufSz   + 1  ! TEC_C1
  Re_BufSz   = Re_BufSz   + 1  ! TEC_C2
  Re_BufSz   = Re_BufSz   + 1  ! TEC_K2
  Re_BufSz   = Re_BufSz   + 1  ! TEC_MR
  Re_BufSz   = Re_BufSz   + 1  ! TEC_Re1
  Re_BufSz   = Re_BufSz   + 1  ! TEC_RLR
  Re_BufSz   = Re_BufSz   + 1  ! TEC_RRes
  Re_BufSz   = Re_BufSz   + 1  ! TEC_SRes
  Re_BufSz   = Re_BufSz   + 1  ! TEC_SySp
  Re_BufSz   = Re_BufSz   + 1  ! TEC_V1a
  Re_BufSz   = Re_BufSz   + 1  ! TEC_VLL
  Re_BufSz   = Re_BufSz   + 1  ! TEC_Xe1
  Re_BufSz   = Re_BufSz   + 1  ! GenEff
  IF ( ALLOCATED(InData%BlPitchInit) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BlPitchInit )  ! BlPitchInit 
  IF ( ALLOCATED(InData%BlPitchF) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BlPitchF )  ! BlPitchF 
  Re_BufSz   = Re_BufSz   + 1  ! NacYawF
  Re_BufSz   = Re_BufSz   + 1  ! SpdGenOn
  Db_BufSz   = Db_BufSz   + 1  ! THSSBrDp
  Db_BufSz   = Db_BufSz   + 1  ! THSSBrFl
  Db_BufSz   = Db_BufSz   + 1  ! TimGenOf
  Db_BufSz   = Db_BufSz   + 1  ! TimGenOn
  Db_BufSz   = Db_BufSz   + 1  ! TPCOn
  IF ( ALLOCATED(InData%TPitManS) )   Db_BufSz    = Db_BufSz    + SIZE( InData%TPitManS )  ! TPitManS 
  Db_BufSz   = Db_BufSz   + 1  ! TYawManS
  Db_BufSz   = Db_BufSz   + 1  ! TYCOn
  Re_BufSz   = Re_BufSz   + 1  ! VS_RtGnSp
  Re_BufSz   = Re_BufSz   + 1  ! VS_RtTq
  Re_BufSz   = Re_BufSz   + 1  ! VS_Slope
  Re_BufSz   = Re_BufSz   + 1  ! VS_SlPc
  Re_BufSz   = Re_BufSz   + 1  ! VS_SySp
  Re_BufSz   = Re_BufSz   + 1  ! VS_TrGnSp
  Re_BufSz   = Re_BufSz   + 1  ! YawPosCom
  Re_BufSz   = Re_BufSz   + 1  ! YawRateCom
  Int_BufSz  = Int_BufSz  + 1  ! GenModel
  Int_BufSz  = Int_BufSz  + 1  ! HSSBrMode
  Int_BufSz  = Int_BufSz  + 1  ! PCMode
  Int_BufSz  = Int_BufSz  + 1  ! VSContrl
  Int_BufSz  = Int_BufSz  + 1  ! YCMode
  Int_BufSz  = Int_BufSz  + 1  ! GenTiStp
  Int_BufSz  = Int_BufSz  + 1  ! GenTiStr
  IF ( ALLOCATED(InData%TBDepISp) )   Re_BufSz    = Re_BufSz    + SIZE( InData%TBDepISp )  ! TBDepISp 
  Re_BufSz   = Re_BufSz   + 1  ! VS_Rgn2K
  Re_BufSz   = Re_BufSz   + 1  ! YawNeut
  Re_BufSz   = Re_BufSz   + 1  ! YawSpr
  Re_BufSz   = Re_BufSz   + 1  ! YawDamp
  Db_BufSz   = Db_BufSz   + 1  ! TpBrDT
  Re_BufSz   = Re_BufSz   + 1  ! TBDrConN
  Re_BufSz   = Re_BufSz   + 1  ! TBDrConD
  Int_BufSz  = Int_BufSz  + 1  ! NumBl
  Int_BufSz  = Int_BufSz  + 1  ! CompNTMD
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
!  missing buffer for RootName
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
!  missing buffer for Delim
  Int_BufSz  = Int_BufSz  + 1  ! UseBladedInterface
  Int_BufSz  = Int_BufSz  + 1  ! DLL_NumTrq
  Int_BufSz  = Int_BufSz  + 1  ! Ptch_Cntrl
  Re_BufSz   = Re_BufSz   + 1  ! Gain_OM
  Re_BufSz   = Re_BufSz   + 1  ! GenPwr_Dem
  Re_BufSz   = Re_BufSz   + 1  ! GenSpd_Dem
  Re_BufSz   = Re_BufSz   + 1  ! GenSpd_MaxOM
  Re_BufSz   = Re_BufSz   + 1  ! GenSpd_MinOM
  IF ( ALLOCATED(InData%GenSpd_TLU) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GenSpd_TLU )  ! GenSpd_TLU 
  Re_BufSz   = Re_BufSz   + 1  ! GenTrq_Dem
  IF ( ALLOCATED(InData%GenTrq_TLU) )   Re_BufSz    = Re_BufSz    + SIZE( InData%GenTrq_TLU )  ! GenTrq_TLU 
  Re_BufSz   = Re_BufSz   + 1  ! Ptch_Max
  Re_BufSz   = Re_BufSz   + 1  ! Ptch_Min
  Re_BufSz   = Re_BufSz   + 1  ! Ptch_SetPnt
  Re_BufSz   = Re_BufSz   + 1  ! PtchRate_Max
  Re_BufSz   = Re_BufSz   + 1  ! PtchRate_Min
  Re_BufSz   = Re_BufSz   + 1  ! NacYaw_North
!  missing buffer for DLL_InFile
 ! Allocate dll_type buffers, if any (we'll also get sizes from these) 
  CALL DLLTypePack( InData%DLL_Trgt, Re_DLL_Trgt_Buf, Db_DLL_Trgt_Buf, Int_DLL_Trgt_Buf, ErrStat, ErrMsg, .TRUE. ) ! DLL_Trgt 
  IF(ALLOCATED(Int_DLL_Trgt_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DLL_Trgt_Buf ) ! DLL_Trgt
  IF(ALLOCATED(Int_DLL_Trgt_Buf)) DEALLOCATE(Int_DLL_Trgt_Buf)
  CALL TMD_PackParam( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Db_NTMD_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Int_NTMD_Buf))Int_BufSz = Int_BufSz + SIZE( Int_NTMD_Buf ) ! NTMD
  IF(ALLOCATED(Re_NTMD_Buf))  DEALLOCATE(Re_NTMD_Buf)
  IF(ALLOCATED(Db_NTMD_Buf))  DEALLOCATE(Db_NTMD_Buf)
  IF(ALLOCATED(Int_NTMD_Buf)) DEALLOCATE(Int_NTMD_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%HSSBrDT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HSSBrFrac )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HSSBrTqF )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SIG_POSl )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SIG_POTq )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SIG_SlPc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SIG_Slop )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SIG_SySp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_A0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_C0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_C1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_C2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_K2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_MR )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_Re1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_RLR )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_RRes )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_SRes )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_SySp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_V1a )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_VLL )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TEC_Xe1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenEff )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%BlPitchInit) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BlPitchInit))-1 ) =  PACK(InData%BlPitchInit ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BlPitchInit)
  ENDIF
  IF ( ALLOCATED(InData%BlPitchF) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BlPitchF))-1 ) =  PACK(InData%BlPitchF ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BlPitchF)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NacYawF )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SpdGenOn )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%THSSBrDp )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%THSSBrFl )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TimGenOf )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TimGenOn )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TPCOn )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%TPitManS) ) THEN
    IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(SIZE(InData%TPitManS))-1 ) =  PACK(InData%TPitManS ,.TRUE.)
    Db_Xferred   = Db_Xferred   + SIZE(InData%TPitManS)
  ENDIF
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TYawManS )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TYCOn )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_RtGnSp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_RtTq )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_Slope )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_SlPc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_SySp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_TrGnSp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawPosCom )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawRateCom )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%GenModel )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%HSSBrMode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%PCMode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%VSContrl )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%YCMode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%GenTiStp ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%GenTiStr ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%TBDepISp) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TBDepISp))-1 ) =  PACK(InData%TBDepISp ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TBDepISp)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%VS_Rgn2K )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawNeut )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawSpr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawDamp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%TpBrDT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TBDrConN )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TBDrConD )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumBl )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%CompNTMD ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%UseBladedInterface ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DLL_NumTrq )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Ptch_Cntrl )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gain_OM )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenPwr_Dem )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenSpd_Dem )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenSpd_MaxOM )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenSpd_MinOM )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%GenSpd_TLU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GenSpd_TLU))-1 ) =  PACK(InData%GenSpd_TLU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GenSpd_TLU)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenTrq_Dem )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%GenTrq_TLU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GenTrq_TLU))-1 ) =  PACK(InData%GenTrq_TLU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GenTrq_TLU)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ptch_Max )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ptch_Min )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ptch_SetPnt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtchRate_Max )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtchRate_Min )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NacYaw_North )
  Re_Xferred   = Re_Xferred   + 1
  CALL DLLTypePack( InData%DLL_Trgt, Re_DLL_Trgt_Buf, Db_DLL_Trgt_Buf, Int_DLL_Trgt_Buf, ErrStat, ErrMsg, OnlySize ) ! DLL_Trgt 
  IF(ALLOCATED(Int_DLL_Trgt_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DLL_Trgt_Buf)-1 ) = Int_DLL_Trgt_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DLL_Trgt_Buf)
  ENDIF
  IF( ALLOCATED(Int_DLL_Trgt_Buf) ) DEALLOCATE(Int_DLL_Trgt_Buf)
  CALL TMD_PackParam( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, OnlySize ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 ) = Re_NTMD_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 ) = Db_NTMD_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 ) = Int_NTMD_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  IF( ALLOCATED(Re_NTMD_Buf) )  DEALLOCATE(Re_NTMD_Buf)
  IF( ALLOCATED(Db_NTMD_Buf) )  DEALLOCATE(Db_NTMD_Buf)
  IF( ALLOCATED(Int_NTMD_Buf) ) DEALLOCATE(Int_NTMD_Buf)
 END SUBROUTINE SrvD_PackParam

 SUBROUTINE SrvD_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_DLL_Trgt_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DLL_Trgt_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DLL_Trgt_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_NTMD_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%HSSBrDT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%HSSBrFrac = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HSSBrTqF = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SIG_POSl = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SIG_POTq = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SIG_SlPc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SIG_Slop = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SIG_SySp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_A0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_C0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_C1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_C2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_K2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_MR = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_Re1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_RLR = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_RRes = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_SRes = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_SySp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_V1a = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_VLL = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TEC_Xe1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenEff = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%BlPitchInit) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BlPitchInit,1)))
  mask1 = .TRUE.
    OutData%BlPitchInit = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BlPitchInit))-1 ),mask1,OutData%BlPitchInit)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BlPitchInit)
  ENDIF
  IF ( ALLOCATED(OutData%BlPitchF) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BlPitchF,1)))
  mask1 = .TRUE.
    OutData%BlPitchF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BlPitchF))-1 ),mask1,OutData%BlPitchF)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BlPitchF)
  ENDIF
  OutData%NacYawF = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SpdGenOn = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%THSSBrDp = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%THSSBrFl = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%TimGenOf = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%TimGenOn = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%TPCOn = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%TPitManS) ) THEN
  ALLOCATE(mask1(SIZE(OutData%TPitManS,1)))
  mask1 = .TRUE.
    OutData%TPitManS = UNPACK(DbKiBuf( Db_Xferred:Re_Xferred+(SIZE(OutData%TPitManS))-1 ),mask1,OutData%TPitManS)
  DEALLOCATE(mask1)
    Db_Xferred   = Db_Xferred   + SIZE(OutData%TPitManS)
  ENDIF
  OutData%TYawManS = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%TYCOn = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%VS_RtGnSp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%VS_RtTq = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%VS_Slope = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%VS_SlPc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%VS_SySp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%VS_TrGnSp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawPosCom = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawRateCom = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenModel = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%HSSBrMode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%PCMode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%VSContrl = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%YCMode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%TBDepISp) ) THEN
  ALLOCATE(mask1(SIZE(OutData%TBDepISp,1)))
  mask1 = .TRUE.
    OutData%TBDepISp = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TBDepISp))-1 ),mask1,OutData%TBDepISp)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TBDepISp)
  ENDIF
  OutData%VS_Rgn2K = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawNeut = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawSpr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawDamp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TpBrDT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%TBDrConN = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TBDrConD = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumBl = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call NWTC_Library_Packoutparmtype to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL NWTC_Library_UnPackoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  OutData%DLL_NumTrq = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Ptch_Cntrl = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Gain_OM = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenPwr_Dem = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenSpd_Dem = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenSpd_MaxOM = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenSpd_MinOM = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%GenSpd_TLU) ) THEN
  ALLOCATE(mask1(SIZE(OutData%GenSpd_TLU,1)))
  mask1 = .TRUE.
    OutData%GenSpd_TLU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GenSpd_TLU))-1 ),mask1,OutData%GenSpd_TLU)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GenSpd_TLU)
  ENDIF
  OutData%GenTrq_Dem = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%GenTrq_TLU) ) THEN
  ALLOCATE(mask1(SIZE(OutData%GenTrq_TLU,1)))
  mask1 = .TRUE.
    OutData%GenTrq_TLU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GenTrq_TLU))-1 ),mask1,OutData%GenTrq_TLU)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GenTrq_TLU)
  ENDIF
  OutData%Ptch_Max = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ptch_Min = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ptch_SetPnt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PtchRate_Max = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PtchRate_Min = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NacYaw_North = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
 ! first call DLLTypePack to get correctly sized buffers for unpacking
  CALL DLLTypePack( OutData%DLL_Trgt, Re_DLL_Trgt_Buf, Db_DLL_Trgt_Buf, Int_DLL_Trgt_Buf, ErrStat, ErrMsg , .TRUE. ) ! DLL_Trgt 
  IF(ALLOCATED(Int_DLL_Trgt_Buf)) THEN
    Int_DLL_Trgt_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DLL_Trgt_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DLL_Trgt_Buf)
  ENDIF
  CALL DLLTypeUnPack( OutData%DLL_Trgt, Re_DLL_Trgt_Buf, Db_DLL_Trgt_Buf, Int_DLL_Trgt_Buf, ErrStat, ErrMsg ) ! DLL_Trgt 
  IF( ALLOCATED(Int_DLL_Trgt_Buf) ) DEALLOCATE(Int_DLL_Trgt_Buf)
 ! first call TMD_PackParam to get correctly sized buffers for unpacking
  CALL TMD_PackParam( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    Re_NTMD_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    Db_NTMD_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    Int_NTMD_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  CALL TMD_UnPackParam( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg ) ! NTMD 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackParam

 SUBROUTINE SrvD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(SrvD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%BlPitch)) THEN
   i1_l = LBOUND(SrcInputData%BlPitch,1)
   i1_u = UBOUND(SrcInputData%BlPitch,1)
   IF (.NOT. ALLOCATED(DstInputData%BlPitch)) THEN 
      ALLOCATE(DstInputData%BlPitch(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%BlPitch.', ErrStat, ErrMsg,'SrvD_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%BlPitch = SrcInputData%BlPitch
ENDIF
   DstInputData%Yaw = SrcInputData%Yaw
   DstInputData%YawRate = SrcInputData%YawRate
   DstInputData%LSS_Spd = SrcInputData%LSS_Spd
   DstInputData%HSS_Spd = SrcInputData%HSS_Spd
   DstInputData%RotSpeed = SrcInputData%RotSpeed
   DstInputData%ExternalYawPosCom = SrcInputData%ExternalYawPosCom
   DstInputData%ExternalYawRateCom = SrcInputData%ExternalYawRateCom
IF (ALLOCATED(SrcInputData%ExternalBlPitchCom)) THEN
   i1_l = LBOUND(SrcInputData%ExternalBlPitchCom,1)
   i1_u = UBOUND(SrcInputData%ExternalBlPitchCom,1)
   IF (.NOT. ALLOCATED(DstInputData%ExternalBlPitchCom)) THEN 
      ALLOCATE(DstInputData%ExternalBlPitchCom(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%ExternalBlPitchCom.', ErrStat, ErrMsg,'SrvD_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%ExternalBlPitchCom = SrcInputData%ExternalBlPitchCom
ENDIF
   DstInputData%ExternalGenTrq = SrcInputData%ExternalGenTrq
   DstInputData%ExternalElecPwr = SrcInputData%ExternalElecPwr
   DstInputData%ExternalHSSBrFrac = SrcInputData%ExternalHSSBrFrac
   DstInputData%TwrAccel = SrcInputData%TwrAccel
   DstInputData%YawErr = SrcInputData%YawErr
   DstInputData%WindDir = SrcInputData%WindDir
   DstInputData%RootMyc = SrcInputData%RootMyc
   DstInputData%YawBrTAxp = SrcInputData%YawBrTAxp
   DstInputData%YawBrTAyp = SrcInputData%YawBrTAyp
   DstInputData%LSSTipPxa = SrcInputData%LSSTipPxa
   DstInputData%RootMxc = SrcInputData%RootMxc
   DstInputData%LSSTipMya = SrcInputData%LSSTipMya
   DstInputData%LSSTipMza = SrcInputData%LSSTipMza
   DstInputData%LSSTipMys = SrcInputData%LSSTipMys
   DstInputData%LSSTipMzs = SrcInputData%LSSTipMzs
   DstInputData%YawBrMyn = SrcInputData%YawBrMyn
   DstInputData%YawBrMzn = SrcInputData%YawBrMzn
   DstInputData%NcIMURAxs = SrcInputData%NcIMURAxs
   DstInputData%NcIMURAys = SrcInputData%NcIMURAys
   DstInputData%NcIMURAzs = SrcInputData%NcIMURAzs
   DstInputData%RotPwr = SrcInputData%RotPwr
   DstInputData%HorWindV = SrcInputData%HorWindV
   DstInputData%YawAngle = SrcInputData%YawAngle
   DstInputData%ElecPwr_prev = SrcInputData%ElecPwr_prev
   DstInputData%GenTrq_prev = SrcInputData%GenTrq_prev
      CALL TMD_CopyInput( SrcInputData%NTMD, DstInputData%NTMD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyInput:NTMD')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SrvD_CopyInput

 SUBROUTINE SrvD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(SrvD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputData%BlPitch)) THEN
   DEALLOCATE(InputData%BlPitch)
ENDIF
IF (ALLOCATED(InputData%ExternalBlPitchCom)) THEN
   DEALLOCATE(InputData%ExternalBlPitchCom)
ENDIF
  CALL TMD_DestroyInput( InputData%NTMD, ErrStat, ErrMsg )
 END SUBROUTINE SrvD_DestroyInput

 SUBROUTINE SrvD_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_NTMD_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%BlPitch) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BlPitch )  ! BlPitch 
  Re_BufSz   = Re_BufSz   + 1  ! Yaw
  Re_BufSz   = Re_BufSz   + 1  ! YawRate
  Re_BufSz   = Re_BufSz   + 1  ! LSS_Spd
  Re_BufSz   = Re_BufSz   + 1  ! HSS_Spd
  Re_BufSz   = Re_BufSz   + 1  ! RotSpeed
  Re_BufSz   = Re_BufSz   + 1  ! ExternalYawPosCom
  Re_BufSz   = Re_BufSz   + 1  ! ExternalYawRateCom
  IF ( ALLOCATED(InData%ExternalBlPitchCom) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ExternalBlPitchCom )  ! ExternalBlPitchCom 
  Re_BufSz   = Re_BufSz   + 1  ! ExternalGenTrq
  Re_BufSz   = Re_BufSz   + 1  ! ExternalElecPwr
  Re_BufSz   = Re_BufSz   + 1  ! ExternalHSSBrFrac
  Re_BufSz   = Re_BufSz   + 1  ! TwrAccel
  Re_BufSz   = Re_BufSz   + 1  ! YawErr
  Re_BufSz   = Re_BufSz   + 1  ! WindDir
  Re_BufSz    = Re_BufSz    + SIZE( InData%RootMyc )  ! RootMyc 
  Re_BufSz   = Re_BufSz   + 1  ! YawBrTAxp
  Re_BufSz   = Re_BufSz   + 1  ! YawBrTAyp
  Re_BufSz   = Re_BufSz   + 1  ! LSSTipPxa
  Re_BufSz    = Re_BufSz    + SIZE( InData%RootMxc )  ! RootMxc 
  Re_BufSz   = Re_BufSz   + 1  ! LSSTipMya
  Re_BufSz   = Re_BufSz   + 1  ! LSSTipMza
  Re_BufSz   = Re_BufSz   + 1  ! LSSTipMys
  Re_BufSz   = Re_BufSz   + 1  ! LSSTipMzs
  Re_BufSz   = Re_BufSz   + 1  ! YawBrMyn
  Re_BufSz   = Re_BufSz   + 1  ! YawBrMzn
  Re_BufSz   = Re_BufSz   + 1  ! NcIMURAxs
  Re_BufSz   = Re_BufSz   + 1  ! NcIMURAys
  Re_BufSz   = Re_BufSz   + 1  ! NcIMURAzs
  Re_BufSz   = Re_BufSz   + 1  ! RotPwr
  Re_BufSz   = Re_BufSz   + 1  ! HorWindV
  Re_BufSz   = Re_BufSz   + 1  ! YawAngle
  Re_BufSz   = Re_BufSz   + 1  ! ElecPwr_prev
  Re_BufSz   = Re_BufSz   + 1  ! GenTrq_prev
  CALL TMD_PackInput( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Db_NTMD_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Int_NTMD_Buf))Int_BufSz = Int_BufSz + SIZE( Int_NTMD_Buf ) ! NTMD
  IF(ALLOCATED(Re_NTMD_Buf))  DEALLOCATE(Re_NTMD_Buf)
  IF(ALLOCATED(Db_NTMD_Buf))  DEALLOCATE(Db_NTMD_Buf)
  IF(ALLOCATED(Int_NTMD_Buf)) DEALLOCATE(Int_NTMD_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%BlPitch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BlPitch))-1 ) =  PACK(InData%BlPitch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BlPitch)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Yaw )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawRate )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%LSS_Spd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HSS_Spd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%RotSpeed )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ExternalYawPosCom )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ExternalYawRateCom )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%ExternalBlPitchCom) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ExternalBlPitchCom))-1 ) =  PACK(InData%ExternalBlPitchCom ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ExternalBlPitchCom)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ExternalGenTrq )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ExternalElecPwr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ExternalHSSBrFrac )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TwrAccel )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawErr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WindDir )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RootMyc))-1 ) =  PACK(InData%RootMyc ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RootMyc)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawBrTAxp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawBrTAyp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%LSSTipPxa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RootMxc))-1 ) =  PACK(InData%RootMxc ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RootMxc)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%LSSTipMya )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%LSSTipMza )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%LSSTipMys )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%LSSTipMzs )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawBrMyn )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawBrMzn )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NcIMURAxs )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NcIMURAys )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NcIMURAzs )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%RotPwr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HorWindV )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawAngle )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ElecPwr_prev )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenTrq_prev )
  Re_Xferred   = Re_Xferred   + 1
  CALL TMD_PackInput( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, OnlySize ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 ) = Re_NTMD_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 ) = Db_NTMD_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 ) = Int_NTMD_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  IF( ALLOCATED(Re_NTMD_Buf) )  DEALLOCATE(Re_NTMD_Buf)
  IF( ALLOCATED(Db_NTMD_Buf) )  DEALLOCATE(Db_NTMD_Buf)
  IF( ALLOCATED(Int_NTMD_Buf) ) DEALLOCATE(Int_NTMD_Buf)
 END SUBROUTINE SrvD_PackInput

 SUBROUTINE SrvD_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_NTMD_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%BlPitch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BlPitch,1)))
  mask1 = .TRUE.
    OutData%BlPitch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BlPitch))-1 ),mask1,OutData%BlPitch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BlPitch)
  ENDIF
  OutData%Yaw = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawRate = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%LSS_Spd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HSS_Spd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%RotSpeed = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ExternalYawPosCom = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ExternalYawRateCom = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%ExternalBlPitchCom) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ExternalBlPitchCom,1)))
  mask1 = .TRUE.
    OutData%ExternalBlPitchCom = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ExternalBlPitchCom))-1 ),mask1,OutData%ExternalBlPitchCom)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ExternalBlPitchCom)
  ENDIF
  OutData%ExternalGenTrq = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ExternalElecPwr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ExternalHSSBrFrac = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TwrAccel = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawErr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WindDir = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%RootMyc,1)))
  mask1 = .TRUE.
  OutData%RootMyc = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RootMyc))-1 ),mask1,OutData%RootMyc)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RootMyc)
  OutData%YawBrTAxp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawBrTAyp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%LSSTipPxa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%RootMxc,1)))
  mask1 = .TRUE.
  OutData%RootMxc = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RootMxc))-1 ),mask1,OutData%RootMxc)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RootMxc)
  OutData%LSSTipMya = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%LSSTipMza = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%LSSTipMys = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%LSSTipMzs = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawBrMyn = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawBrMzn = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NcIMURAxs = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NcIMURAys = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NcIMURAzs = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%RotPwr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HorWindV = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YawAngle = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ElecPwr_prev = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenTrq_prev = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
 ! first call TMD_PackInput to get correctly sized buffers for unpacking
  CALL TMD_PackInput( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    Re_NTMD_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    Db_NTMD_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    Int_NTMD_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  CALL TMD_UnPackInput( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg ) ! NTMD 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackInput

 SUBROUTINE SrvD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(SrvD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'SrvD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
IF (ALLOCATED(SrcOutputData%BlPitchCom)) THEN
   i1_l = LBOUND(SrcOutputData%BlPitchCom,1)
   i1_u = UBOUND(SrcOutputData%BlPitchCom,1)
   IF (.NOT. ALLOCATED(DstOutputData%BlPitchCom)) THEN 
      ALLOCATE(DstOutputData%BlPitchCom(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%BlPitchCom.', ErrStat, ErrMsg,'SrvD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%BlPitchCom = SrcOutputData%BlPitchCom
ENDIF
   DstOutputData%YawMom = SrcOutputData%YawMom
   DstOutputData%GenTrq = SrcOutputData%GenTrq
   DstOutputData%HSSBrTrqC = SrcOutputData%HSSBrTrqC
   DstOutputData%ElecPwr = SrcOutputData%ElecPwr
IF (ALLOCATED(SrcOutputData%TBDrCon)) THEN
   i1_l = LBOUND(SrcOutputData%TBDrCon,1)
   i1_u = UBOUND(SrcOutputData%TBDrCon,1)
   IF (.NOT. ALLOCATED(DstOutputData%TBDrCon)) THEN 
      ALLOCATE(DstOutputData%TBDrCon(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%TBDrCon.', ErrStat, ErrMsg,'SrvD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%TBDrCon = SrcOutputData%TBDrCon
ENDIF
      CALL TMD_CopyOutput( SrcOutputData%NTMD, DstOutputData%NTMD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_CopyOutput:NTMD')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SrvD_CopyOutput

 SUBROUTINE SrvD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(SrvD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
IF (ALLOCATED(OutputData%BlPitchCom)) THEN
   DEALLOCATE(OutputData%BlPitchCom)
ENDIF
IF (ALLOCATED(OutputData%TBDrCon)) THEN
   DEALLOCATE(OutputData%TBDrCon)
ENDIF
  CALL TMD_DestroyOutput( OutputData%NTMD, ErrStat, ErrMsg )
 END SUBROUTINE SrvD_DestroyOutput

 SUBROUTINE SrvD_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SrvD_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_NTMD_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( ALLOCATED(InData%BlPitchCom) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BlPitchCom )  ! BlPitchCom 
  Re_BufSz   = Re_BufSz   + 1  ! YawMom
  Re_BufSz   = Re_BufSz   + 1  ! GenTrq
  Re_BufSz   = Re_BufSz   + 1  ! HSSBrTrqC
  Re_BufSz   = Re_BufSz   + 1  ! ElecPwr
  IF ( ALLOCATED(InData%TBDrCon) )   Re_BufSz    = Re_BufSz    + SIZE( InData%TBDrCon )  ! TBDrCon 
  CALL TMD_PackOutput( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Db_NTMD_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_NTMD_Buf  ) ! NTMD
  IF(ALLOCATED(Int_NTMD_Buf))Int_BufSz = Int_BufSz + SIZE( Int_NTMD_Buf ) ! NTMD
  IF(ALLOCATED(Re_NTMD_Buf))  DEALLOCATE(Re_NTMD_Buf)
  IF(ALLOCATED(Db_NTMD_Buf))  DEALLOCATE(Db_NTMD_Buf)
  IF(ALLOCATED(Int_NTMD_Buf)) DEALLOCATE(Int_NTMD_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
  IF ( ALLOCATED(InData%BlPitchCom) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BlPitchCom))-1 ) =  PACK(InData%BlPitchCom ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BlPitchCom)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YawMom )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%GenTrq )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HSSBrTrqC )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ElecPwr )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%TBDrCon) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TBDrCon))-1 ) =  PACK(InData%TBDrCon ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TBDrCon)
  ENDIF
  CALL TMD_PackOutput( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, InData%NTMD, ErrStat, ErrMsg, OnlySize ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 ) = Re_NTMD_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 ) = Db_NTMD_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 ) = Int_NTMD_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  IF( ALLOCATED(Re_NTMD_Buf) )  DEALLOCATE(Re_NTMD_Buf)
  IF( ALLOCATED(Db_NTMD_Buf) )  DEALLOCATE(Db_NTMD_Buf)
  IF( ALLOCATED(Int_NTMD_Buf) ) DEALLOCATE(Int_NTMD_Buf)
 END SUBROUTINE SrvD_PackOutput

 SUBROUTINE SrvD_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SrvD_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_NTMD_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_NTMD_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_NTMD_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  IF ( ALLOCATED(OutData%BlPitchCom) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BlPitchCom,1)))
  mask1 = .TRUE.
    OutData%BlPitchCom = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BlPitchCom))-1 ),mask1,OutData%BlPitchCom)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BlPitchCom)
  ENDIF
  OutData%YawMom = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%GenTrq = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HSSBrTrqC = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ElecPwr = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%TBDrCon) ) THEN
  ALLOCATE(mask1(SIZE(OutData%TBDrCon,1)))
  mask1 = .TRUE.
    OutData%TBDrCon = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TBDrCon))-1 ),mask1,OutData%TBDrCon)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TBDrCon)
  ENDIF
 ! first call TMD_PackOutput to get correctly sized buffers for unpacking
  CALL TMD_PackOutput( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg, .TRUE. ) ! NTMD 
  IF(ALLOCATED(Re_NTMD_Buf)) THEN
    Re_NTMD_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_NTMD_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Db_NTMD_Buf)) THEN
    Db_NTMD_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_NTMD_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_NTMD_Buf)
  ENDIF
  IF(ALLOCATED(Int_NTMD_Buf)) THEN
    Int_NTMD_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_NTMD_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_NTMD_Buf)
  ENDIF
  CALL TMD_UnPackOutput( Re_NTMD_Buf, Db_NTMD_Buf, Int_NTMD_Buf, OutData%NTMD, ErrStat, ErrMsg ) ! NTMD 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SrvD_UnPackOutput


 SUBROUTINE SrvD_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SrvD_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SrvD_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SrvD_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%BlPitch) .AND. ALLOCATED(u(1)%BlPitch)) THEN
  u_out%BlPitch = u(1)%BlPitch
END IF ! check if allocated
  u_out%Yaw = u(1)%Yaw
  u_out%YawRate = u(1)%YawRate
  u_out%LSS_Spd = u(1)%LSS_Spd
  u_out%HSS_Spd = u(1)%HSS_Spd
  u_out%RotSpeed = u(1)%RotSpeed
  u_out%ExternalYawPosCom = u(1)%ExternalYawPosCom
  u_out%ExternalYawRateCom = u(1)%ExternalYawRateCom
IF (ALLOCATED(u_out%ExternalBlPitchCom) .AND. ALLOCATED(u(1)%ExternalBlPitchCom)) THEN
  u_out%ExternalBlPitchCom = u(1)%ExternalBlPitchCom
END IF ! check if allocated
  u_out%ExternalGenTrq = u(1)%ExternalGenTrq
  u_out%ExternalElecPwr = u(1)%ExternalElecPwr
  u_out%ExternalHSSBrFrac = u(1)%ExternalHSSBrFrac
  u_out%TwrAccel = u(1)%TwrAccel
  u_out%YawErr = u(1)%YawErr
  u_out%WindDir = u(1)%WindDir
  u_out%RootMyc = u(1)%RootMyc
  u_out%YawBrTAxp = u(1)%YawBrTAxp
  u_out%YawBrTAyp = u(1)%YawBrTAyp
  u_out%LSSTipPxa = u(1)%LSSTipPxa
  u_out%RootMxc = u(1)%RootMxc
  u_out%LSSTipMya = u(1)%LSSTipMya
  u_out%LSSTipMza = u(1)%LSSTipMza
  u_out%LSSTipMys = u(1)%LSSTipMys
  u_out%LSSTipMzs = u(1)%LSSTipMzs
  u_out%YawBrMyn = u(1)%YawBrMyn
  u_out%YawBrMzn = u(1)%YawBrMzn
  u_out%NcIMURAxs = u(1)%NcIMURAxs
  u_out%NcIMURAys = u(1)%NcIMURAys
  u_out%NcIMURAzs = u(1)%NcIMURAzs
  u_out%RotPwr = u(1)%RotPwr
  u_out%HorWindV = u(1)%HorWindV
  u_out%YawAngle = u(1)%YawAngle
  u_out%ElecPwr_prev = u(1)%ElecPwr_prev
  u_out%GenTrq_prev = u(1)%GenTrq_prev
      CALL TMD_Input_ExtrapInterp( u%NTMD, tin, u_out%NTMD, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_Input_ExtrapInterp')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%BlPitch) .AND. ALLOCATED(u(1)%BlPitch)) THEN
  ALLOCATE(b1(SIZE(u_out%BlPitch,1)))
  ALLOCATE(c1(SIZE(u_out%BlPitch,1)))
  b1 = -(u(1)%BlPitch - u(2)%BlPitch)/t(2)
  u_out%BlPitch = u(1)%BlPitch + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = -(u(1)%Yaw - u(2)%Yaw)/t(2)
  u_out%Yaw = u(1)%Yaw + b0 * t_out
  b0 = -(u(1)%YawRate - u(2)%YawRate)/t(2)
  u_out%YawRate = u(1)%YawRate + b0 * t_out
  b0 = -(u(1)%LSS_Spd - u(2)%LSS_Spd)/t(2)
  u_out%LSS_Spd = u(1)%LSS_Spd + b0 * t_out
  b0 = -(u(1)%HSS_Spd - u(2)%HSS_Spd)/t(2)
  u_out%HSS_Spd = u(1)%HSS_Spd + b0 * t_out
  b0 = -(u(1)%RotSpeed - u(2)%RotSpeed)/t(2)
  u_out%RotSpeed = u(1)%RotSpeed + b0 * t_out
  b0 = -(u(1)%ExternalYawPosCom - u(2)%ExternalYawPosCom)/t(2)
  u_out%ExternalYawPosCom = u(1)%ExternalYawPosCom + b0 * t_out
  b0 = -(u(1)%ExternalYawRateCom - u(2)%ExternalYawRateCom)/t(2)
  u_out%ExternalYawRateCom = u(1)%ExternalYawRateCom + b0 * t_out
IF (ALLOCATED(u_out%ExternalBlPitchCom) .AND. ALLOCATED(u(1)%ExternalBlPitchCom)) THEN
  ALLOCATE(b1(SIZE(u_out%ExternalBlPitchCom,1)))
  ALLOCATE(c1(SIZE(u_out%ExternalBlPitchCom,1)))
  b1 = -(u(1)%ExternalBlPitchCom - u(2)%ExternalBlPitchCom)/t(2)
  u_out%ExternalBlPitchCom = u(1)%ExternalBlPitchCom + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = -(u(1)%ExternalGenTrq - u(2)%ExternalGenTrq)/t(2)
  u_out%ExternalGenTrq = u(1)%ExternalGenTrq + b0 * t_out
  b0 = -(u(1)%ExternalElecPwr - u(2)%ExternalElecPwr)/t(2)
  u_out%ExternalElecPwr = u(1)%ExternalElecPwr + b0 * t_out
  b0 = -(u(1)%ExternalHSSBrFrac - u(2)%ExternalHSSBrFrac)/t(2)
  u_out%ExternalHSSBrFrac = u(1)%ExternalHSSBrFrac + b0 * t_out
  b0 = -(u(1)%TwrAccel - u(2)%TwrAccel)/t(2)
  u_out%TwrAccel = u(1)%TwrAccel + b0 * t_out
  b0 = -(u(1)%YawErr - u(2)%YawErr)/t(2)
  u_out%YawErr = u(1)%YawErr + b0 * t_out
  b0 = -(u(1)%WindDir - u(2)%WindDir)/t(2)
  u_out%WindDir = u(1)%WindDir + b0 * t_out
  ALLOCATE(b1(SIZE(u_out%RootMyc,1)))
  ALLOCATE(c1(SIZE(u_out%RootMyc,1)))
  b1 = -(u(1)%RootMyc - u(2)%RootMyc)/t(2)
  u_out%RootMyc = u(1)%RootMyc + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  b0 = -(u(1)%YawBrTAxp - u(2)%YawBrTAxp)/t(2)
  u_out%YawBrTAxp = u(1)%YawBrTAxp + b0 * t_out
  b0 = -(u(1)%YawBrTAyp - u(2)%YawBrTAyp)/t(2)
  u_out%YawBrTAyp = u(1)%YawBrTAyp + b0 * t_out
  b0 = -(u(1)%LSSTipPxa - u(2)%LSSTipPxa)/t(2)
  u_out%LSSTipPxa = u(1)%LSSTipPxa + b0 * t_out
  ALLOCATE(b1(SIZE(u_out%RootMxc,1)))
  ALLOCATE(c1(SIZE(u_out%RootMxc,1)))
  b1 = -(u(1)%RootMxc - u(2)%RootMxc)/t(2)
  u_out%RootMxc = u(1)%RootMxc + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  b0 = -(u(1)%LSSTipMya - u(2)%LSSTipMya)/t(2)
  u_out%LSSTipMya = u(1)%LSSTipMya + b0 * t_out
  b0 = -(u(1)%LSSTipMza - u(2)%LSSTipMza)/t(2)
  u_out%LSSTipMza = u(1)%LSSTipMza + b0 * t_out
  b0 = -(u(1)%LSSTipMys - u(2)%LSSTipMys)/t(2)
  u_out%LSSTipMys = u(1)%LSSTipMys + b0 * t_out
  b0 = -(u(1)%LSSTipMzs - u(2)%LSSTipMzs)/t(2)
  u_out%LSSTipMzs = u(1)%LSSTipMzs + b0 * t_out
  b0 = -(u(1)%YawBrMyn - u(2)%YawBrMyn)/t(2)
  u_out%YawBrMyn = u(1)%YawBrMyn + b0 * t_out
  b0 = -(u(1)%YawBrMzn - u(2)%YawBrMzn)/t(2)
  u_out%YawBrMzn = u(1)%YawBrMzn + b0 * t_out
  b0 = -(u(1)%NcIMURAxs - u(2)%NcIMURAxs)/t(2)
  u_out%NcIMURAxs = u(1)%NcIMURAxs + b0 * t_out
  b0 = -(u(1)%NcIMURAys - u(2)%NcIMURAys)/t(2)
  u_out%NcIMURAys = u(1)%NcIMURAys + b0 * t_out
  b0 = -(u(1)%NcIMURAzs - u(2)%NcIMURAzs)/t(2)
  u_out%NcIMURAzs = u(1)%NcIMURAzs + b0 * t_out
  b0 = -(u(1)%RotPwr - u(2)%RotPwr)/t(2)
  u_out%RotPwr = u(1)%RotPwr + b0 * t_out
  b0 = -(u(1)%HorWindV - u(2)%HorWindV)/t(2)
  u_out%HorWindV = u(1)%HorWindV + b0 * t_out
  b0 = -(u(1)%YawAngle - u(2)%YawAngle)/t(2)
  u_out%YawAngle = u(1)%YawAngle + b0 * t_out
  b0 = -(u(1)%ElecPwr_prev - u(2)%ElecPwr_prev)/t(2)
  u_out%ElecPwr_prev = u(1)%ElecPwr_prev + b0 * t_out
  b0 = -(u(1)%GenTrq_prev - u(2)%GenTrq_prev)/t(2)
  u_out%GenTrq_prev = u(1)%GenTrq_prev + b0 * t_out
      CALL TMD_Input_ExtrapInterp( u%NTMD, tin, u_out%NTMD, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_Input_ExtrapInterp')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%BlPitch) .AND. ALLOCATED(u(1)%BlPitch)) THEN
  ALLOCATE(b1(SIZE(u_out%BlPitch,1)))
  ALLOCATE(c1(SIZE(u_out%BlPitch,1)))
  b1 = (t(3)**2*(u(1)%BlPitch - u(2)%BlPitch) + t(2)**2*(-u(1)%BlPitch + u(3)%BlPitch))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%BlPitch + t(3)*u(2)%BlPitch - t(2)*u(3)%BlPitch ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%BlPitch = u(1)%BlPitch + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%Yaw - u(2)%Yaw) + t(2)**2*(-u(1)%Yaw + u(3)%Yaw))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Yaw + t(3)*u(2)%Yaw - t(2)*u(3)%Yaw ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Yaw = u(1)%Yaw + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%YawRate - u(2)%YawRate) + t(2)**2*(-u(1)%YawRate + u(3)%YawRate))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%YawRate + t(3)*u(2)%YawRate - t(2)*u(3)%YawRate ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%YawRate = u(1)%YawRate + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%LSS_Spd - u(2)%LSS_Spd) + t(2)**2*(-u(1)%LSS_Spd + u(3)%LSS_Spd))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%LSS_Spd + t(3)*u(2)%LSS_Spd - t(2)*u(3)%LSS_Spd ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%LSS_Spd = u(1)%LSS_Spd + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%HSS_Spd - u(2)%HSS_Spd) + t(2)**2*(-u(1)%HSS_Spd + u(3)%HSS_Spd))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%HSS_Spd + t(3)*u(2)%HSS_Spd - t(2)*u(3)%HSS_Spd ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%HSS_Spd = u(1)%HSS_Spd + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%RotSpeed - u(2)%RotSpeed) + t(2)**2*(-u(1)%RotSpeed + u(3)%RotSpeed))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%RotSpeed + t(3)*u(2)%RotSpeed - t(2)*u(3)%RotSpeed ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%RotSpeed = u(1)%RotSpeed + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%ExternalYawPosCom - u(2)%ExternalYawPosCom) + t(2)**2*(-u(1)%ExternalYawPosCom + u(3)%ExternalYawPosCom))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%ExternalYawPosCom + t(3)*u(2)%ExternalYawPosCom - t(2)*u(3)%ExternalYawPosCom ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%ExternalYawPosCom = u(1)%ExternalYawPosCom + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%ExternalYawRateCom - u(2)%ExternalYawRateCom) + t(2)**2*(-u(1)%ExternalYawRateCom + u(3)%ExternalYawRateCom))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%ExternalYawRateCom + t(3)*u(2)%ExternalYawRateCom - t(2)*u(3)%ExternalYawRateCom ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%ExternalYawRateCom = u(1)%ExternalYawRateCom + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%ExternalBlPitchCom) .AND. ALLOCATED(u(1)%ExternalBlPitchCom)) THEN
  ALLOCATE(b1(SIZE(u_out%ExternalBlPitchCom,1)))
  ALLOCATE(c1(SIZE(u_out%ExternalBlPitchCom,1)))
  b1 = (t(3)**2*(u(1)%ExternalBlPitchCom - u(2)%ExternalBlPitchCom) + t(2)**2*(-u(1)%ExternalBlPitchCom + u(3)%ExternalBlPitchCom))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%ExternalBlPitchCom + t(3)*u(2)%ExternalBlPitchCom - t(2)*u(3)%ExternalBlPitchCom ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%ExternalBlPitchCom = u(1)%ExternalBlPitchCom + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%ExternalGenTrq - u(2)%ExternalGenTrq) + t(2)**2*(-u(1)%ExternalGenTrq + u(3)%ExternalGenTrq))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%ExternalGenTrq + t(3)*u(2)%ExternalGenTrq - t(2)*u(3)%ExternalGenTrq ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%ExternalGenTrq = u(1)%ExternalGenTrq + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%ExternalElecPwr - u(2)%ExternalElecPwr) + t(2)**2*(-u(1)%ExternalElecPwr + u(3)%ExternalElecPwr))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%ExternalElecPwr + t(3)*u(2)%ExternalElecPwr - t(2)*u(3)%ExternalElecPwr ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%ExternalElecPwr = u(1)%ExternalElecPwr + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%ExternalHSSBrFrac - u(2)%ExternalHSSBrFrac) + t(2)**2*(-u(1)%ExternalHSSBrFrac + u(3)%ExternalHSSBrFrac))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%ExternalHSSBrFrac + t(3)*u(2)%ExternalHSSBrFrac - t(2)*u(3)%ExternalHSSBrFrac ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%ExternalHSSBrFrac = u(1)%ExternalHSSBrFrac + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%TwrAccel - u(2)%TwrAccel) + t(2)**2*(-u(1)%TwrAccel + u(3)%TwrAccel))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%TwrAccel + t(3)*u(2)%TwrAccel - t(2)*u(3)%TwrAccel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TwrAccel = u(1)%TwrAccel + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%YawErr - u(2)%YawErr) + t(2)**2*(-u(1)%YawErr + u(3)%YawErr))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%YawErr + t(3)*u(2)%YawErr - t(2)*u(3)%YawErr ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%YawErr = u(1)%YawErr + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%WindDir - u(2)%WindDir) + t(2)**2*(-u(1)%WindDir + u(3)%WindDir))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%WindDir + t(3)*u(2)%WindDir - t(2)*u(3)%WindDir ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WindDir = u(1)%WindDir + b0 * t_out + c0 * t_out**2
  ALLOCATE(b1(SIZE(u_out%RootMyc,1)))
  ALLOCATE(c1(SIZE(u_out%RootMyc,1)))
  b1 = (t(3)**2*(u(1)%RootMyc - u(2)%RootMyc) + t(2)**2*(-u(1)%RootMyc + u(3)%RootMyc))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%RootMyc + t(3)*u(2)%RootMyc - t(2)*u(3)%RootMyc ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%RootMyc = u(1)%RootMyc + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  b0 = (t(3)**2*(u(1)%YawBrTAxp - u(2)%YawBrTAxp) + t(2)**2*(-u(1)%YawBrTAxp + u(3)%YawBrTAxp))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%YawBrTAxp + t(3)*u(2)%YawBrTAxp - t(2)*u(3)%YawBrTAxp ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%YawBrTAxp = u(1)%YawBrTAxp + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%YawBrTAyp - u(2)%YawBrTAyp) + t(2)**2*(-u(1)%YawBrTAyp + u(3)%YawBrTAyp))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%YawBrTAyp + t(3)*u(2)%YawBrTAyp - t(2)*u(3)%YawBrTAyp ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%YawBrTAyp = u(1)%YawBrTAyp + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%LSSTipPxa - u(2)%LSSTipPxa) + t(2)**2*(-u(1)%LSSTipPxa + u(3)%LSSTipPxa))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%LSSTipPxa + t(3)*u(2)%LSSTipPxa - t(2)*u(3)%LSSTipPxa ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%LSSTipPxa = u(1)%LSSTipPxa + b0 * t_out + c0 * t_out**2
  ALLOCATE(b1(SIZE(u_out%RootMxc,1)))
  ALLOCATE(c1(SIZE(u_out%RootMxc,1)))
  b1 = (t(3)**2*(u(1)%RootMxc - u(2)%RootMxc) + t(2)**2*(-u(1)%RootMxc + u(3)%RootMxc))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%RootMxc + t(3)*u(2)%RootMxc - t(2)*u(3)%RootMxc ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%RootMxc = u(1)%RootMxc + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  b0 = (t(3)**2*(u(1)%LSSTipMya - u(2)%LSSTipMya) + t(2)**2*(-u(1)%LSSTipMya + u(3)%LSSTipMya))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%LSSTipMya + t(3)*u(2)%LSSTipMya - t(2)*u(3)%LSSTipMya ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%LSSTipMya = u(1)%LSSTipMya + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%LSSTipMza - u(2)%LSSTipMza) + t(2)**2*(-u(1)%LSSTipMza + u(3)%LSSTipMza))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%LSSTipMza + t(3)*u(2)%LSSTipMza - t(2)*u(3)%LSSTipMza ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%LSSTipMza = u(1)%LSSTipMza + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%LSSTipMys - u(2)%LSSTipMys) + t(2)**2*(-u(1)%LSSTipMys + u(3)%LSSTipMys))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%LSSTipMys + t(3)*u(2)%LSSTipMys - t(2)*u(3)%LSSTipMys ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%LSSTipMys = u(1)%LSSTipMys + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%LSSTipMzs - u(2)%LSSTipMzs) + t(2)**2*(-u(1)%LSSTipMzs + u(3)%LSSTipMzs))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%LSSTipMzs + t(3)*u(2)%LSSTipMzs - t(2)*u(3)%LSSTipMzs ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%LSSTipMzs = u(1)%LSSTipMzs + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%YawBrMyn - u(2)%YawBrMyn) + t(2)**2*(-u(1)%YawBrMyn + u(3)%YawBrMyn))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%YawBrMyn + t(3)*u(2)%YawBrMyn - t(2)*u(3)%YawBrMyn ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%YawBrMyn = u(1)%YawBrMyn + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%YawBrMzn - u(2)%YawBrMzn) + t(2)**2*(-u(1)%YawBrMzn + u(3)%YawBrMzn))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%YawBrMzn + t(3)*u(2)%YawBrMzn - t(2)*u(3)%YawBrMzn ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%YawBrMzn = u(1)%YawBrMzn + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%NcIMURAxs - u(2)%NcIMURAxs) + t(2)**2*(-u(1)%NcIMURAxs + u(3)%NcIMURAxs))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%NcIMURAxs + t(3)*u(2)%NcIMURAxs - t(2)*u(3)%NcIMURAxs ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%NcIMURAxs = u(1)%NcIMURAxs + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%NcIMURAys - u(2)%NcIMURAys) + t(2)**2*(-u(1)%NcIMURAys + u(3)%NcIMURAys))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%NcIMURAys + t(3)*u(2)%NcIMURAys - t(2)*u(3)%NcIMURAys ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%NcIMURAys = u(1)%NcIMURAys + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%NcIMURAzs - u(2)%NcIMURAzs) + t(2)**2*(-u(1)%NcIMURAzs + u(3)%NcIMURAzs))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%NcIMURAzs + t(3)*u(2)%NcIMURAzs - t(2)*u(3)%NcIMURAzs ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%NcIMURAzs = u(1)%NcIMURAzs + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%RotPwr - u(2)%RotPwr) + t(2)**2*(-u(1)%RotPwr + u(3)%RotPwr))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%RotPwr + t(3)*u(2)%RotPwr - t(2)*u(3)%RotPwr ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%RotPwr = u(1)%RotPwr + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%HorWindV - u(2)%HorWindV) + t(2)**2*(-u(1)%HorWindV + u(3)%HorWindV))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%HorWindV + t(3)*u(2)%HorWindV - t(2)*u(3)%HorWindV ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%HorWindV = u(1)%HorWindV + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%YawAngle - u(2)%YawAngle) + t(2)**2*(-u(1)%YawAngle + u(3)%YawAngle))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%YawAngle + t(3)*u(2)%YawAngle - t(2)*u(3)%YawAngle ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%YawAngle = u(1)%YawAngle + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%ElecPwr_prev - u(2)%ElecPwr_prev) + t(2)**2*(-u(1)%ElecPwr_prev + u(3)%ElecPwr_prev))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%ElecPwr_prev + t(3)*u(2)%ElecPwr_prev - t(2)*u(3)%ElecPwr_prev ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%ElecPwr_prev = u(1)%ElecPwr_prev + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%GenTrq_prev - u(2)%GenTrq_prev) + t(2)**2*(-u(1)%GenTrq_prev + u(3)%GenTrq_prev))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%GenTrq_prev + t(3)*u(2)%GenTrq_prev - t(2)*u(3)%GenTrq_prev ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%GenTrq_prev = u(1)%GenTrq_prev + b0 * t_out + c0 * t_out**2
      CALL TMD_Input_ExtrapInterp( u%NTMD, tin, u_out%NTMD, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_Input_ExtrapInterp')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SrvD_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SrvD_Input_ExtrapInterp


 SUBROUTINE SrvD_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SrvD_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SrvD_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SrvD_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
IF (ALLOCATED(u_out%BlPitchCom) .AND. ALLOCATED(u(1)%BlPitchCom)) THEN
  u_out%BlPitchCom = u(1)%BlPitchCom
END IF ! check if allocated
  u_out%YawMom = u(1)%YawMom
  u_out%GenTrq = u(1)%GenTrq
  u_out%HSSBrTrqC = u(1)%HSSBrTrqC
  u_out%ElecPwr = u(1)%ElecPwr
IF (ALLOCATED(u_out%TBDrCon) .AND. ALLOCATED(u(1)%TBDrCon)) THEN
  u_out%TBDrCon = u(1)%TBDrCon
END IF ! check if allocated
      CALL TMD_Output_ExtrapInterp( u%NTMD, tin, u_out%NTMD, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_Output_ExtrapInterp')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%BlPitchCom) .AND. ALLOCATED(u(1)%BlPitchCom)) THEN
  ALLOCATE(b1(SIZE(u_out%BlPitchCom,1)))
  ALLOCATE(c1(SIZE(u_out%BlPitchCom,1)))
  b1 = -(u(1)%BlPitchCom - u(2)%BlPitchCom)/t(2)
  u_out%BlPitchCom = u(1)%BlPitchCom + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = -(u(1)%YawMom - u(2)%YawMom)/t(2)
  u_out%YawMom = u(1)%YawMom + b0 * t_out
  b0 = -(u(1)%GenTrq - u(2)%GenTrq)/t(2)
  u_out%GenTrq = u(1)%GenTrq + b0 * t_out
  b0 = -(u(1)%HSSBrTrqC - u(2)%HSSBrTrqC)/t(2)
  u_out%HSSBrTrqC = u(1)%HSSBrTrqC + b0 * t_out
  b0 = -(u(1)%ElecPwr - u(2)%ElecPwr)/t(2)
  u_out%ElecPwr = u(1)%ElecPwr + b0 * t_out
IF (ALLOCATED(u_out%TBDrCon) .AND. ALLOCATED(u(1)%TBDrCon)) THEN
  ALLOCATE(b1(SIZE(u_out%TBDrCon,1)))
  ALLOCATE(c1(SIZE(u_out%TBDrCon,1)))
  b1 = -(u(1)%TBDrCon - u(2)%TBDrCon)/t(2)
  u_out%TBDrCon = u(1)%TBDrCon + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
      CALL TMD_Output_ExtrapInterp( u%NTMD, tin, u_out%NTMD, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_Output_ExtrapInterp')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SrvD_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%BlPitchCom) .AND. ALLOCATED(u(1)%BlPitchCom)) THEN
  ALLOCATE(b1(SIZE(u_out%BlPitchCom,1)))
  ALLOCATE(c1(SIZE(u_out%BlPitchCom,1)))
  b1 = (t(3)**2*(u(1)%BlPitchCom - u(2)%BlPitchCom) + t(2)**2*(-u(1)%BlPitchCom + u(3)%BlPitchCom))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%BlPitchCom + t(3)*u(2)%BlPitchCom - t(2)*u(3)%BlPitchCom ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%BlPitchCom = u(1)%BlPitchCom + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%YawMom - u(2)%YawMom) + t(2)**2*(-u(1)%YawMom + u(3)%YawMom))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%YawMom + t(3)*u(2)%YawMom - t(2)*u(3)%YawMom ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%YawMom = u(1)%YawMom + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%GenTrq - u(2)%GenTrq) + t(2)**2*(-u(1)%GenTrq + u(3)%GenTrq))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%GenTrq + t(3)*u(2)%GenTrq - t(2)*u(3)%GenTrq ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%GenTrq = u(1)%GenTrq + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%HSSBrTrqC - u(2)%HSSBrTrqC) + t(2)**2*(-u(1)%HSSBrTrqC + u(3)%HSSBrTrqC))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%HSSBrTrqC + t(3)*u(2)%HSSBrTrqC - t(2)*u(3)%HSSBrTrqC ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%HSSBrTrqC = u(1)%HSSBrTrqC + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%ElecPwr - u(2)%ElecPwr) + t(2)**2*(-u(1)%ElecPwr + u(3)%ElecPwr))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%ElecPwr + t(3)*u(2)%ElecPwr - t(2)*u(3)%ElecPwr ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%ElecPwr = u(1)%ElecPwr + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%TBDrCon) .AND. ALLOCATED(u(1)%TBDrCon)) THEN
  ALLOCATE(b1(SIZE(u_out%TBDrCon,1)))
  ALLOCATE(c1(SIZE(u_out%TBDrCon,1)))
  b1 = (t(3)**2*(u(1)%TBDrCon - u(2)%TBDrCon) + t(2)**2*(-u(1)%TBDrCon + u(3)%TBDrCon))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%TBDrCon + t(3)*u(2)%TBDrCon - t(2)*u(3)%TBDrCon ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%TBDrCon = u(1)%TBDrCon + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
      CALL TMD_Output_ExtrapInterp( u%NTMD, tin, u_out%NTMD, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SrvD_Output_ExtrapInterp')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SrvD_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SrvD_Output_ExtrapInterp

END MODULE ServoDyn_Types
!ENDOFREGISTRYGENERATEDFILE
