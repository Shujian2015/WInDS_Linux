!STARTOFREGISTRYGENERATEDFILE './SubDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 14-Jan-2015)
!*********************************************************************************************************************************
! SubDyn_Types
!.................................................................................................................................
! This file is part of SubDyn.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE SubDyn_Types
! This module contains all of the user-defined types needed in SubDyn. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  SD_InitInputType  =======
  TYPE, PUBLIC :: SD_InitInputType
    CHARACTER(1024)  :: SDInputFile      ! Name of the input file [-]
    CHARACTER(1024)  :: RootName      ! SubDyn rootname [-]
    REAL(ReKi)  :: g      ! Gravity acceleration [-]
    REAL(ReKi)  :: WtrDpth      ! Water Depth (positive valued) [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TP_RefPoint      ! global position of transition piece reference point (could also be defined in SubDyn itself) [-]
    REAL(ReKi)  :: SubRotateZ      ! Rotation angle in degrees about global Z [-]
  END TYPE SD_InitInputType
! =======================
! =========  SD_InitOutputType  =======
  TYPE, PUBLIC :: SD_InitOutputType
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      ! Names of the output-to-file channels [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      ! Units of the output-to-file channels [-]
    TYPE(ProgDesc)  :: Ver      ! This module's name, version, and date [-]
  END TYPE SD_InitOutputType
! =======================
! =========  MeshAuxDataType  =======
  TYPE, PUBLIC :: MeshAuxDataType
    INTEGER(IntKi)  :: MemberID      ! Member ID for Output [-]
    INTEGER(IntKi)  :: NOutCnt      ! Number of Nodes for the output member [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeCnt      ! Node ordinal numbers for the output member [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeIDs      ! Node IDs associated with ordinal numbers for the output member [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmIDs      ! Element IDs connected to each NodeIDs; max 10 elements [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmNds      ! Flag to indicate 1st or 2nd node of element for each ElmIDs [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: ElmID2s      ! Element IDs connected to each joint node [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: ElmNd2s      ! Flag [to]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Me      ! Mass matrix connected to each joint element for outAll output [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Ke      ! Mass matrix connected to each joint element for outAll output [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Fg      ! Gravity load vector connected to each joint element for requested member output [-]
    REAL(ReKi) , DIMENSION(1:12,1:12,1:2)  :: Me2      ! Mass matrix connected to each joint element for outAll output [-]
    REAL(ReKi) , DIMENSION(1:12,1:12,1:2)  :: Ke2      ! Mass matrix connected to each joint element for outAll output [-]
    REAL(ReKi) , DIMENSION(1:12,1:2)  :: Fg2      ! Gravity load vector connected to each joint element for outAll output [-]
  END TYPE MeshAuxDataType
! =======================
! =========  CB_MatArrays  =======
  TYPE, PUBLIC :: CB_MatArrays
    INTEGER(IntKi)  :: DOFM      ! retained degrees of freedom (modes) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TI2      ! TI2 matrix to refer to total mass to (0,0,0) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBB      ! FULL MBB ( no constraints applied) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBM      ! FULL MBM ( no constraints applied) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: KBB      ! FULL KBB ( no constraints applied) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiL      ! Retained CB modes, possibly allPhiL(DOFL,DOFL), or PhiL(DOFL,DOFM) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiR      ! FULL PhiR ( no constraints applied) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OmegaL      ! Eigenvalues of retained CB modes, possibly all (DOFL or DOFM) [-]
  END TYPE CB_MatArrays
! =======================
! =========  FEM_MatArrays  =======
  TYPE, PUBLIC :: FEM_MatArrays
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Omega      ! Eigenvalues of full FEM model,  we calculate them all [-]
    INTEGER(IntKi)  :: NOmega      ! Number of full FEM Eigenvalues (for now TDOF-6*Nreact) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Modes      ! Eigenmodes of full FEM model,  we calculate them all [-]
  END TYPE FEM_MatArrays
! =======================
! =========  ElemPropType  =======
  TYPE, PUBLIC :: ElemPropType
    REAL(ReKi)  :: Area      ! Area of an element [-]
    REAL(ReKi)  :: Length      ! Length of an element [-]
    REAL(ReKi)  :: Ixx      ! Moment of inertia of an element [-]
    REAL(ReKi)  :: Iyy      ! Moment of inertia of an element [-]
    REAL(ReKi)  :: Jzz      ! Moment of inertia of an element [-]
    LOGICAL  :: Shear      ! Use timoshenko (true) E-B (false) [-]
    REAL(ReKi)  :: Kappa      ! Shear coefficient [-]
    REAL(ReKi)  :: YoungE      ! Young's modulus [-]
    REAL(ReKi)  :: ShearG      ! Shear modulus [-]
    REAL(ReKi)  :: Rho      ! Density [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: DirCos      ! Element direction cosine matrix [-]
  END TYPE ElemPropType
! =======================
! =========  SD_InitType  =======
  TYPE, PUBLIC :: SD_InitType
    CHARACTER(1024)  :: RootName      ! SubDyn rootname [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TP_RefPoint      ! global position of transition piece reference point (could also be defined in SubDyn itself) [-]
    REAL(ReKi)  :: SubRotateZ      ! Rotation angle in degrees about global Z [-]
    REAL(ReKi)  :: g      ! Gravity acceleration [-]
    REAL(DbKi)  :: DT      ! Time step from Glue Code [seconds]
    INTEGER(IntKi)  :: NJoints      ! Number of joints of the sub structure [-]
    INTEGER(IntKi)  :: NPropSets      ! Number of property sets [-]
    INTEGER(IntKi)  :: NXPropSets      ! Number of extended property sets [-]
    INTEGER(IntKi)  :: NInterf      ! Number of joints attached to transition piece [-]
    INTEGER(IntKi)  :: NCMass      ! Number of joints with concentrated mass [-]
    INTEGER(IntKi)  :: NCOSMs      ! Number of independent cosine matrices [-]
    INTEGER(IntKi)  :: FEMMod      ! FEM switch: element model in the FEM [-]
    INTEGER(IntKi)  :: NDiv      ! Number of divisions for each member [-]
    LOGICAL  :: CBMod      ! Perform C-B flag [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Joints      ! Joints number and coordinate values [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropSets      ! Property sets number and values [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: XPropSets      ! Extended property sets [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: COSMs      ! Independent direction cosine matrices [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CMass      ! Concentrated mass information [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: JDampings      ! Damping coefficients for internal modes [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Members      ! Member joints connection [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Interf      ! Interface degree of freedoms [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: SSOutList      ! List of Output Channels [-]
    LOGICAL  :: OutCOSM      ! Output Cos-matrices Flag [-]
    LOGICAL  :: TabDelim      ! Generate a tab-delimited output file in OutJckF-Flag [-]
    INTEGER(IntKi)  :: NNode      ! Total number of nodes [-]
    INTEGER(IntKi)  :: NElem      ! Total number of elements [-]
    INTEGER(IntKi)  :: NProp      ! Total number of property sets [-]
    INTEGER(IntKi)  :: TDOF      ! Total degree of freedom [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Nodes      ! Nodes number and coordinates [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Props      ! Property sets and values [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: K      ! System stiffness matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: M      ! System mass matrix [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F      ! System force vector [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FG      ! Gravity force vector [N]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ElemProps      ! Element properties(A, L, Ixx, Iyy, Jzz, Shear, Kappa, E, G, Rho, DirCos(1,1), DirCos(2, 1), ....., DirCos(3, 3) ) [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: BCs      ! Boundary constraint degree of freedoms. First column - DOFs(rows in the system matrices), Second column - constrained(1) or not(0) [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: IntFc      ! Interface constraint degree of freedoms [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: MemberNodes      ! Member number and nodes in the member [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnN      ! Nodes that connect to a common node [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnE      ! Elements that connect to a common node [-]
    LOGICAL  :: SSSum      ! SubDyn Summary File Flag [-]
  END TYPE SD_InitType
! =======================
! =========  SD_ContinuousStateType  =======
  TYPE, PUBLIC :: SD_ContinuousStateType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qm      ! Virtual states, Nmod elements [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qmdot      ! Derivative of states, Nmod elements [-]
  END TYPE SD_ContinuousStateType
! =======================
! =========  SD_DiscreteStateType  =======
  TYPE, PUBLIC :: SD_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      ! Remove this variable if you have discrete states [-]
  END TYPE SD_DiscreteStateType
! =======================
! =========  SD_ConstraintStateType  =======
  TYPE, PUBLIC :: SD_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      ! Remove this variable if you have constraint states [-]
  END TYPE SD_ConstraintStateType
! =======================
! =========  SD_OtherStateType  =======
  TYPE, PUBLIC :: SD_OtherStateType
    TYPE(SD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: xdot      ! previous state derivs for m-step time integrator [-]
    INTEGER(IntKi)  :: n      ! tracks time step for which OtherState was updated last [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: SDWrOutput      ! Data from previous step to be written to a SubDyn output file [-]
    REAL(DbKi)  :: LastOutTime      ! The time of the most recent stored output data [s]
    INTEGER(IntKi)  :: Decimat      ! Current output decimation counter [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qmdotdot      ! 2nd Derivative of states, used only for output-file purposes [-]
    REAL(ReKi) , DIMENSION(1:6)  :: u_TP 
    REAL(ReKi) , DIMENSION(1:6)  :: udot_TP 
    REAL(ReKi) , DIMENSION(1:6)  :: udotdot_TP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UFL 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UR_bar 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UR_bar_dot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UR_bar_dotdot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL_dot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL_dotdot 
  END TYPE SD_OtherStateType
! =======================
! =========  SD_ParameterType  =======
  TYPE, PUBLIC :: SD_ParameterType
    REAL(DbKi)  :: SDDeltaT      ! Time step (for integration of continuous states) [seconds]
    LOGICAL  :: SttcSolve      ! Solve dynamics about static equilibrium point (flag) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: NOmegaM2      ! Coefficient of x in X (negative omegaM squared) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: N2OmegaMJDamp      ! Coefficient of x in X (negative 2 omegaM * JDamping) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MMB      ! Matrix after C-B reduction (transpose of MBM [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FX      ! Load components in X [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_11      ! Coefficient of x in Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_12      ! Coefficient of x in Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_13      ! Coefficient of u in Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_14      ! Coefficient of u in Y1 [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FY      ! Load Components in  Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiM      ! Coefficient of x in Y2 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_61      ! Coefficient of x in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_62      ! Coefficient of x in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiRb_TI      ! Coefficient of u in Y2 (Phi_R bar * TI) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_63      ! Coefficient of u in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_64      ! Coefficient of u in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F2_61      ! Load Component in Y2 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBB      ! Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: KBB      ! Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBM      ! Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiL_T      ! Transpose of Matrix of C-B  modes [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiLInvOmgL2      ! Matrix of C-B  modes times the inverse of OmegaL**2 (Phi_L*(Omg**2)^-1) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FGL      ! Internal node DOFL, gravity loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AM2Jac      ! Jacobian (factored) for Adams-Boulton 2nd order Integration [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AM2JacPiv      ! Pivot array for Jacobian factorization (for Adams-Boulton 2nd order Integration) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TI      ! Matrix to calculate TP reference point reaction at top of structure [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TIreact      ! Matrix to calculate single point reaction at base of structure [-]
    INTEGER(IntKi)  :: NModes      ! Number of modes to retain in C-B method [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Elems      ! Element nodes connections [-]
    INTEGER(IntKi)  :: qmL      ! Length of state array [-]
    INTEGER(IntKi)  :: DofL      ! Internal nodes   of DOFs [-]
    INTEGER(IntKi)  :: NNodes_I      ! Number of Interface nodes [-]
    INTEGER(IntKi)  :: NNodes_L      ! Number of Internal nodes [-]
    INTEGER(IntKi)  :: NNodes_RbarL      ! Number of Interface + Internal nodes [-]
    INTEGER(IntKi)  :: DofI      ! Interface nodes   of DOFs [-]
    INTEGER(IntKi)  :: DofR      ! Interface and restrained nodes   of DOFs [-]
    INTEGER(IntKi)  :: DofC      ! Contrained nodes   of DOFs [-]
    INTEGER(IntKi)  :: NReact      ! Number of joints with reactions [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Reacts      ! React degree of freedoms [-]
    INTEGER(IntKi)  :: Nmembers      ! Number of members of the sub structure [-]
    INTEGER(IntKi)  :: URbarL      ! Length of URbar, subarray of y2 array (DOFRb) [-]
    INTEGER(IntKi)  :: IntMethod      ! INtegration Method (1/2/3)Length of y2 array [-]
    INTEGER(IntKi)  :: NAvgEls = 2      ! Max number of elements that should be averaged when calculating outputs at nodes [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDI      ! Index array of the interface(nodes connect to TP) dofs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDR      ! Index array of the interface and restraint dofs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDL      ! Index array of the internal dofs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDC      ! Index array of the contraint dofs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDY      ! Index array of the all dofs in Y2 [-]
    INTEGER(IntKi)  :: NMOutputs      ! Number of members whose output is written [-]
    INTEGER(IntKi)  :: NumOuts      ! Number of output channels read from input file [-]
    INTEGER(IntKi)  :: OutSwtch      ! Output Requested Channels to local or global output file [1/2/3] [-]
    INTEGER(IntKi)  :: UnJckF      ! Unit of SD ouput file [-]
    CHARACTER(1)  :: Delim      ! Column delimiter for output text files [-]
    CHARACTER(20)  :: OutFmt      ! Format for Output [-]
    CHARACTER(20)  :: OutSFmt      ! Format for Output Headers [-]
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst      ! List of user requested members and nodes [-]
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst2      ! List of all member joint nodes and elements for output [-]
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst3      ! List of all member joint nodes and elements for output [-]
    TYPE(ElemPropType) , DIMENSION(:), ALLOCATABLE  :: ElemProps      ! List of element properties [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      ! An array holding names, units, and indices of all of the selected output channels.   logical [-]
    LOGICAL  :: OutAll      ! Flag to output or not all joint forces [-]
    LOGICAL  :: OutReact      ! Flag to check whether reactions are requested [-]
    INTEGER(IntKi)  :: OutAllInt      ! Integer version of OutAll [-]
    INTEGER(IntKi)  :: OutAllDims      ! Integer version of OutAll [-]
    INTEGER(IntKi)  :: OutDec      ! Output Decimation for Requested Channels [-]
  END TYPE SD_ParameterType
! =======================
! =========  SD_InputType  =======
  TYPE, PUBLIC :: SD_InputType
    TYPE(MeshType)  :: TPMesh      ! Transition piece inputs on a point mesh [-]
    TYPE(MeshType)  :: LMesh      ! Point mesh for interior node inputs [-]
  END TYPE SD_InputType
! =======================
! =========  SD_OutputType  =======
  TYPE, PUBLIC :: SD_OutputType
    TYPE(MeshType)  :: Y1Mesh      ! Transition piece outputs on a point mesh [-]
    TYPE(MeshType)  :: Y2Mesh      ! Interior+Interface nodes outputs on a point mesh [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! Data to be written to an output file [-]
  END TYPE SD_OutputType
! =======================
! =========  SD_PartialOutputPInputType  =======
  TYPE, PUBLIC :: SD_PartialOutputPInputType
    TYPE(SD_InputType)  :: DummyOutput      ! If you have output equations and input data, update this variable [-]
  END TYPE SD_PartialOutputPInputType
! =======================
! =========  SD_PartialContStatePInputType  =======
  TYPE, PUBLIC :: SD_PartialContStatePInputType
    TYPE(SD_InputType)  :: DummyContState      ! If you have continuous state equations and input data, update this variable [-]
  END TYPE SD_PartialContStatePInputType
! =======================
! =========  SD_PartialDiscStatePInputType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePInputType
    TYPE(SD_InputType)  :: DummyDiscState      ! If you have discrete state equations and input data, update this variable [-]
  END TYPE SD_PartialDiscStatePInputType
! =======================
! =========  SD_PartialConstrStatePInputType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePInputType
    TYPE(SD_InputType)  :: DummyConstrState      ! If you have constraint state equations and input data, update this variable [-]
  END TYPE SD_PartialConstrStatePInputType
! =======================
! =========  SD_PartialOutputPContStateType  =======
  TYPE, PUBLIC :: SD_PartialOutputPContStateType
    TYPE(SD_ContinuousStateType)  :: DummyOutput      ! If you have output equations and continuous states, update this variable [-]
  END TYPE SD_PartialOutputPContStateType
! =======================
! =========  SD_PartialContStatePContStateType  =======
  TYPE, PUBLIC :: SD_PartialContStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyContState      ! If you have continuous state equations and continuous states, update this variable [-]
  END TYPE SD_PartialContStatePContStateType
! =======================
! =========  SD_PartialDiscStatePContStateType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyDiscState      ! If you have discrete state equations and continuous states, update this variable [-]
  END TYPE SD_PartialDiscStatePContStateType
! =======================
! =========  SD_PartialConstrStatePContStateType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyConstrState      ! If you have constraint state equations and continuous states, update this variable [-]
  END TYPE SD_PartialConstrStatePContStateType
! =======================
! =========  SD_PartialOutputPDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialOutputPDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyOutput      ! If you have output equations and discrete states, update this variable [-]
  END TYPE SD_PartialOutputPDiscStateType
! =======================
! =========  SD_PartialContStatePDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialContStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyContState      ! If you have continuous state equations and discrete states, update this variable [-]
  END TYPE SD_PartialContStatePDiscStateType
! =======================
! =========  SD_PartialDiscStatePDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyDiscState      ! If you have discrete state equations and discrete states, update this variable [-]
  END TYPE SD_PartialDiscStatePDiscStateType
! =======================
! =========  SD_PartialConstrStatePDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyConstrState      ! If you have constraint state equations and discrete states, update this variable [-]
  END TYPE SD_PartialConstrStatePDiscStateType
! =======================
! =========  SD_PartialOutputPConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialOutputPConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyOutput      ! If you have output equations and constraint states, update this variable [-]
  END TYPE SD_PartialOutputPConstrStateType
! =======================
! =========  SD_PartialContStatePConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialContStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyContState      ! If you have continuous state equations and constraint states, update this variable [-]
  END TYPE SD_PartialContStatePConstrStateType
! =======================
! =========  SD_PartialDiscStatePConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyDiscState      ! If you have discrete state equations and constraint states, update this variable [-]
  END TYPE SD_PartialDiscStatePConstrStateType
! =======================
! =========  SD_PartialConstrStatePConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyConstrState      ! If you have constraint state equations and constraint states, update this variable [-]
  END TYPE SD_PartialConstrStatePConstrStateType
! =======================
CONTAINS
 SUBROUTINE SD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(SD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%SDInputFile = SrcInitInputData%SDInputFile
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%g = SrcInitInputData%g
   DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
   DstInitInputData%TP_RefPoint = SrcInitInputData%TP_RefPoint
   DstInitInputData%SubRotateZ = SrcInitInputData%SubRotateZ
 END SUBROUTINE SD_CopyInitInput

 SUBROUTINE SD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyInitInput

 SUBROUTINE SD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for SDInputFile
!  missing buffer for RootName
  Re_BufSz   = Re_BufSz   + 1  ! g
  Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
  Re_BufSz    = Re_BufSz    + SIZE( InData%TP_RefPoint )  ! TP_RefPoint 
  Re_BufSz   = Re_BufSz   + 1  ! SubRotateZ
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDpth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TP_RefPoint))-1 ) =  PACK(InData%TP_RefPoint ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TP_RefPoint)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SubRotateZ )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackInitInput

 SUBROUTINE SD_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDpth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%TP_RefPoint,1)))
  mask1 = .TRUE.
  OutData%TP_RefPoint = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TP_RefPoint))-1 ),mask1,OutData%TP_RefPoint)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TP_RefPoint)
  OutData%SubRotateZ = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInitInput

 SUBROUTINE SD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(SD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'SD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'SD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyInitOutput:Ver')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyInitOutput

 SUBROUTINE SD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyInitOutput

 SUBROUTINE SD_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
 END SUBROUTINE SD_PackInitOutput

 SUBROUTINE SD_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInitOutput

 SUBROUTINE SD_CopyMeshAuxDataType( SrcMeshAuxDataTypeData, DstMeshAuxDataTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MeshAuxDataType), INTENT(IN) :: SrcMeshAuxDataTypeData
   TYPE(MeshAuxDataType), INTENT(INOUT) :: DstMeshAuxDataTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstMeshAuxDataTypeData%MemberID = SrcMeshAuxDataTypeData%MemberID
   DstMeshAuxDataTypeData%NOutCnt = SrcMeshAuxDataTypeData%NOutCnt
IF (ALLOCATED(SrcMeshAuxDataTypeData%NodeCnt)) THEN
   i1_l = LBOUND(SrcMeshAuxDataTypeData%NodeCnt,1)
   i1_u = UBOUND(SrcMeshAuxDataTypeData%NodeCnt,1)
   IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%NodeCnt)) THEN 
      ALLOCATE(DstMeshAuxDataTypeData%NodeCnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%NodeCnt.', ErrStat, ErrMsg,'SD_CopyMeshAuxDataType')
         RETURN
      END IF
   END IF
   DstMeshAuxDataTypeData%NodeCnt = SrcMeshAuxDataTypeData%NodeCnt
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%NodeIDs)) THEN
   i1_l = LBOUND(SrcMeshAuxDataTypeData%NodeIDs,1)
   i1_u = UBOUND(SrcMeshAuxDataTypeData%NodeIDs,1)
   IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%NodeIDs)) THEN 
      ALLOCATE(DstMeshAuxDataTypeData%NodeIDs(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%NodeIDs.', ErrStat, ErrMsg,'SD_CopyMeshAuxDataType')
         RETURN
      END IF
   END IF
   DstMeshAuxDataTypeData%NodeIDs = SrcMeshAuxDataTypeData%NodeIDs
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%ElmIDs)) THEN
   i1_l = LBOUND(SrcMeshAuxDataTypeData%ElmIDs,1)
   i1_u = UBOUND(SrcMeshAuxDataTypeData%ElmIDs,1)
   i2_l = LBOUND(SrcMeshAuxDataTypeData%ElmIDs,2)
   i2_u = UBOUND(SrcMeshAuxDataTypeData%ElmIDs,2)
   IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%ElmIDs)) THEN 
      ALLOCATE(DstMeshAuxDataTypeData%ElmIDs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%ElmIDs.', ErrStat, ErrMsg,'SD_CopyMeshAuxDataType')
         RETURN
      END IF
   END IF
   DstMeshAuxDataTypeData%ElmIDs = SrcMeshAuxDataTypeData%ElmIDs
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%ElmNds)) THEN
   i1_l = LBOUND(SrcMeshAuxDataTypeData%ElmNds,1)
   i1_u = UBOUND(SrcMeshAuxDataTypeData%ElmNds,1)
   i2_l = LBOUND(SrcMeshAuxDataTypeData%ElmNds,2)
   i2_u = UBOUND(SrcMeshAuxDataTypeData%ElmNds,2)
   IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%ElmNds)) THEN 
      ALLOCATE(DstMeshAuxDataTypeData%ElmNds(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%ElmNds.', ErrStat, ErrMsg,'SD_CopyMeshAuxDataType')
         RETURN
      END IF
   END IF
   DstMeshAuxDataTypeData%ElmNds = SrcMeshAuxDataTypeData%ElmNds
ENDIF
   DstMeshAuxDataTypeData%ElmID2s = SrcMeshAuxDataTypeData%ElmID2s
   DstMeshAuxDataTypeData%ElmNd2s = SrcMeshAuxDataTypeData%ElmNd2s
IF (ALLOCATED(SrcMeshAuxDataTypeData%Me)) THEN
   i1_l = LBOUND(SrcMeshAuxDataTypeData%Me,1)
   i1_u = UBOUND(SrcMeshAuxDataTypeData%Me,1)
   i2_l = LBOUND(SrcMeshAuxDataTypeData%Me,2)
   i2_u = UBOUND(SrcMeshAuxDataTypeData%Me,2)
   i3_l = LBOUND(SrcMeshAuxDataTypeData%Me,3)
   i3_u = UBOUND(SrcMeshAuxDataTypeData%Me,3)
   i4_l = LBOUND(SrcMeshAuxDataTypeData%Me,4)
   i4_u = UBOUND(SrcMeshAuxDataTypeData%Me,4)
   IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%Me)) THEN 
      ALLOCATE(DstMeshAuxDataTypeData%Me(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%Me.', ErrStat, ErrMsg,'SD_CopyMeshAuxDataType')
         RETURN
      END IF
   END IF
   DstMeshAuxDataTypeData%Me = SrcMeshAuxDataTypeData%Me
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%Ke)) THEN
   i1_l = LBOUND(SrcMeshAuxDataTypeData%Ke,1)
   i1_u = UBOUND(SrcMeshAuxDataTypeData%Ke,1)
   i2_l = LBOUND(SrcMeshAuxDataTypeData%Ke,2)
   i2_u = UBOUND(SrcMeshAuxDataTypeData%Ke,2)
   i3_l = LBOUND(SrcMeshAuxDataTypeData%Ke,3)
   i3_u = UBOUND(SrcMeshAuxDataTypeData%Ke,3)
   i4_l = LBOUND(SrcMeshAuxDataTypeData%Ke,4)
   i4_u = UBOUND(SrcMeshAuxDataTypeData%Ke,4)
   IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%Ke)) THEN 
      ALLOCATE(DstMeshAuxDataTypeData%Ke(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%Ke.', ErrStat, ErrMsg,'SD_CopyMeshAuxDataType')
         RETURN
      END IF
   END IF
   DstMeshAuxDataTypeData%Ke = SrcMeshAuxDataTypeData%Ke
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%Fg)) THEN
   i1_l = LBOUND(SrcMeshAuxDataTypeData%Fg,1)
   i1_u = UBOUND(SrcMeshAuxDataTypeData%Fg,1)
   i2_l = LBOUND(SrcMeshAuxDataTypeData%Fg,2)
   i2_u = UBOUND(SrcMeshAuxDataTypeData%Fg,2)
   i3_l = LBOUND(SrcMeshAuxDataTypeData%Fg,3)
   i3_u = UBOUND(SrcMeshAuxDataTypeData%Fg,3)
   IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%Fg)) THEN 
      ALLOCATE(DstMeshAuxDataTypeData%Fg(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%Fg.', ErrStat, ErrMsg,'SD_CopyMeshAuxDataType')
         RETURN
      END IF
   END IF
   DstMeshAuxDataTypeData%Fg = SrcMeshAuxDataTypeData%Fg
ENDIF
   DstMeshAuxDataTypeData%Me2 = SrcMeshAuxDataTypeData%Me2
   DstMeshAuxDataTypeData%Ke2 = SrcMeshAuxDataTypeData%Ke2
   DstMeshAuxDataTypeData%Fg2 = SrcMeshAuxDataTypeData%Fg2
 END SUBROUTINE SD_CopyMeshAuxDataType

 SUBROUTINE SD_DestroyMeshAuxDataType( MeshAuxDataTypeData, ErrStat, ErrMsg )
  TYPE(MeshAuxDataType), INTENT(INOUT) :: MeshAuxDataTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(MeshAuxDataTypeData%NodeCnt)) THEN
   DEALLOCATE(MeshAuxDataTypeData%NodeCnt)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%NodeIDs)) THEN
   DEALLOCATE(MeshAuxDataTypeData%NodeIDs)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%ElmIDs)) THEN
   DEALLOCATE(MeshAuxDataTypeData%ElmIDs)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%ElmNds)) THEN
   DEALLOCATE(MeshAuxDataTypeData%ElmNds)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%Me)) THEN
   DEALLOCATE(MeshAuxDataTypeData%Me)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%Ke)) THEN
   DEALLOCATE(MeshAuxDataTypeData%Ke)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%Fg)) THEN
   DEALLOCATE(MeshAuxDataTypeData%Fg)
ENDIF
 END SUBROUTINE SD_DestroyMeshAuxDataType

 SUBROUTINE SD_PackMeshAuxDataType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MeshAuxDataType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! MemberID
  Int_BufSz  = Int_BufSz  + 1  ! NOutCnt
  IF ( ALLOCATED(InData%NodeCnt) )   Int_BufSz   = Int_BufSz   + SIZE( InData%NodeCnt )  ! NodeCnt 
  IF ( ALLOCATED(InData%NodeIDs) )   Int_BufSz   = Int_BufSz   + SIZE( InData%NodeIDs )  ! NodeIDs 
  IF ( ALLOCATED(InData%ElmIDs) )   Int_BufSz   = Int_BufSz   + SIZE( InData%ElmIDs )  ! ElmIDs 
  IF ( ALLOCATED(InData%ElmNds) )   Int_BufSz   = Int_BufSz   + SIZE( InData%ElmNds )  ! ElmNds 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmID2s )  ! ElmID2s 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmNd2s )  ! ElmNd2s 
  IF ( ALLOCATED(InData%Me) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Me )  ! Me 
  IF ( ALLOCATED(InData%Ke) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Ke )  ! Ke 
  IF ( ALLOCATED(InData%Fg) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Fg )  ! Fg 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Me2 )  ! Me2 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Ke2 )  ! Ke2 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fg2 )  ! Fg2 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MemberID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NOutCnt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NodeCnt) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodeCnt))-1 ) = PACK(InData%NodeCnt ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodeCnt)
  ENDIF
  IF ( ALLOCATED(InData%NodeIDs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodeIDs))-1 ) = PACK(InData%NodeIDs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodeIDs)
  ENDIF
  IF ( ALLOCATED(InData%ElmIDs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmIDs))-1 ) = PACK(InData%ElmIDs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%ElmIDs)
  ENDIF
  IF ( ALLOCATED(InData%ElmNds) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmNds))-1 ) = PACK(InData%ElmNds ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%ElmNds)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmID2s))-1 ) = PACK(InData%ElmID2s ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ElmID2s)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmNd2s))-1 ) = PACK(InData%ElmNd2s ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ElmNd2s)
  IF ( ALLOCATED(InData%Me) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Me))-1 ) =  PACK(InData%Me ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Me)
  ENDIF
  IF ( ALLOCATED(InData%Ke) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ke))-1 ) =  PACK(InData%Ke ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Ke)
  ENDIF
  IF ( ALLOCATED(InData%Fg) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fg))-1 ) =  PACK(InData%Fg ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Fg)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Me2))-1 ) =  PACK(InData%Me2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Me2)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ke2))-1 ) =  PACK(InData%Ke2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Ke2)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fg2))-1 ) =  PACK(InData%Fg2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Fg2)
 END SUBROUTINE SD_PackMeshAuxDataType

 SUBROUTINE SD_UnPackMeshAuxDataType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MeshAuxDataType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MemberID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NOutCnt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%NodeCnt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NodeCnt,1)))
  mask1 = .TRUE.
    OutData%NodeCnt = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodeCnt))-1 ),mask1,OutData%NodeCnt)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodeCnt)
  ENDIF
  IF ( ALLOCATED(OutData%NodeIDs) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NodeIDs,1)))
  mask1 = .TRUE.
    OutData%NodeIDs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodeIDs))-1 ),mask1,OutData%NodeIDs)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodeIDs)
  ENDIF
  IF ( ALLOCATED(OutData%ElmIDs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElmIDs,1),SIZE(OutData%ElmIDs,2)))
  mask2 = .TRUE.
    OutData%ElmIDs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmIDs))-1 ),mask2,OutData%ElmIDs)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmIDs)
  ENDIF
  IF ( ALLOCATED(OutData%ElmNds) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElmNds,1),SIZE(OutData%ElmNds,2)))
  mask2 = .TRUE.
    OutData%ElmNds = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmNds))-1 ),mask2,OutData%ElmNds)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmNds)
  ENDIF
  ALLOCATE(mask1(SIZE(OutData%ElmID2s,1)))
  mask1 = .TRUE.
  OutData%ElmID2s = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmID2s))-1 ),mask1,OutData%ElmID2s)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmID2s)
  ALLOCATE(mask1(SIZE(OutData%ElmNd2s,1)))
  mask1 = .TRUE.
  OutData%ElmNd2s = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmNd2s))-1 ),mask1,OutData%ElmNd2s)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmNd2s)
  IF ( ALLOCATED(OutData%Me) ) THEN
  ALLOCATE(mask4(SIZE(OutData%Me,1),SIZE(OutData%Me,2),SIZE(OutData%Me,3),SIZE(OutData%Me,4)))
  mask4 = .TRUE.
    OutData%Me = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Me))-1 ),mask4,OutData%Me)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Me)
  ENDIF
  IF ( ALLOCATED(OutData%Ke) ) THEN
  ALLOCATE(mask4(SIZE(OutData%Ke,1),SIZE(OutData%Ke,2),SIZE(OutData%Ke,3),SIZE(OutData%Ke,4)))
  mask4 = .TRUE.
    OutData%Ke = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ke))-1 ),mask4,OutData%Ke)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Ke)
  ENDIF
  IF ( ALLOCATED(OutData%Fg) ) THEN
  ALLOCATE(mask3(SIZE(OutData%Fg,1),SIZE(OutData%Fg,2),SIZE(OutData%Fg,3)))
  mask3 = .TRUE.
    OutData%Fg = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fg))-1 ),mask3,OutData%Fg)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Fg)
  ENDIF
  ALLOCATE(mask3(SIZE(OutData%Me2,1),SIZE(OutData%Me2,2),SIZE(OutData%Me2,3)))
  mask3 = .TRUE.
  OutData%Me2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Me2))-1 ),mask3,OutData%Me2)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Me2)
  ALLOCATE(mask3(SIZE(OutData%Ke2,1),SIZE(OutData%Ke2,2),SIZE(OutData%Ke2,3)))
  mask3 = .TRUE.
  OutData%Ke2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ke2))-1 ),mask3,OutData%Ke2)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Ke2)
  ALLOCATE(mask2(SIZE(OutData%Fg2,1),SIZE(OutData%Fg2,2)))
  mask2 = .TRUE.
  OutData%Fg2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fg2))-1 ),mask2,OutData%Fg2)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Fg2)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackMeshAuxDataType

 SUBROUTINE SD_CopyCB_MatArrays( SrcCB_MatArraysData, DstCB_MatArraysData, CtrlCode, ErrStat, ErrMsg )
   TYPE(CB_MatArrays), INTENT(IN) :: SrcCB_MatArraysData
   TYPE(CB_MatArrays), INTENT(INOUT) :: DstCB_MatArraysData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstCB_MatArraysData%DOFM = SrcCB_MatArraysData%DOFM
IF (ALLOCATED(SrcCB_MatArraysData%TI2)) THEN
   i1_l = LBOUND(SrcCB_MatArraysData%TI2,1)
   i1_u = UBOUND(SrcCB_MatArraysData%TI2,1)
   i2_l = LBOUND(SrcCB_MatArraysData%TI2,2)
   i2_u = UBOUND(SrcCB_MatArraysData%TI2,2)
   IF (.NOT. ALLOCATED(DstCB_MatArraysData%TI2)) THEN 
      ALLOCATE(DstCB_MatArraysData%TI2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%TI2.', ErrStat, ErrMsg,'SD_CopyCB_MatArrays')
         RETURN
      END IF
   END IF
   DstCB_MatArraysData%TI2 = SrcCB_MatArraysData%TI2
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%MBB)) THEN
   i1_l = LBOUND(SrcCB_MatArraysData%MBB,1)
   i1_u = UBOUND(SrcCB_MatArraysData%MBB,1)
   i2_l = LBOUND(SrcCB_MatArraysData%MBB,2)
   i2_u = UBOUND(SrcCB_MatArraysData%MBB,2)
   IF (.NOT. ALLOCATED(DstCB_MatArraysData%MBB)) THEN 
      ALLOCATE(DstCB_MatArraysData%MBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%MBB.', ErrStat, ErrMsg,'SD_CopyCB_MatArrays')
         RETURN
      END IF
   END IF
   DstCB_MatArraysData%MBB = SrcCB_MatArraysData%MBB
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%MBM)) THEN
   i1_l = LBOUND(SrcCB_MatArraysData%MBM,1)
   i1_u = UBOUND(SrcCB_MatArraysData%MBM,1)
   i2_l = LBOUND(SrcCB_MatArraysData%MBM,2)
   i2_u = UBOUND(SrcCB_MatArraysData%MBM,2)
   IF (.NOT. ALLOCATED(DstCB_MatArraysData%MBM)) THEN 
      ALLOCATE(DstCB_MatArraysData%MBM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%MBM.', ErrStat, ErrMsg,'SD_CopyCB_MatArrays')
         RETURN
      END IF
   END IF
   DstCB_MatArraysData%MBM = SrcCB_MatArraysData%MBM
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%KBB)) THEN
   i1_l = LBOUND(SrcCB_MatArraysData%KBB,1)
   i1_u = UBOUND(SrcCB_MatArraysData%KBB,1)
   i2_l = LBOUND(SrcCB_MatArraysData%KBB,2)
   i2_u = UBOUND(SrcCB_MatArraysData%KBB,2)
   IF (.NOT. ALLOCATED(DstCB_MatArraysData%KBB)) THEN 
      ALLOCATE(DstCB_MatArraysData%KBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%KBB.', ErrStat, ErrMsg,'SD_CopyCB_MatArrays')
         RETURN
      END IF
   END IF
   DstCB_MatArraysData%KBB = SrcCB_MatArraysData%KBB
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%PhiL)) THEN
   i1_l = LBOUND(SrcCB_MatArraysData%PhiL,1)
   i1_u = UBOUND(SrcCB_MatArraysData%PhiL,1)
   i2_l = LBOUND(SrcCB_MatArraysData%PhiL,2)
   i2_u = UBOUND(SrcCB_MatArraysData%PhiL,2)
   IF (.NOT. ALLOCATED(DstCB_MatArraysData%PhiL)) THEN 
      ALLOCATE(DstCB_MatArraysData%PhiL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%PhiL.', ErrStat, ErrMsg,'SD_CopyCB_MatArrays')
         RETURN
      END IF
   END IF
   DstCB_MatArraysData%PhiL = SrcCB_MatArraysData%PhiL
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%PhiR)) THEN
   i1_l = LBOUND(SrcCB_MatArraysData%PhiR,1)
   i1_u = UBOUND(SrcCB_MatArraysData%PhiR,1)
   i2_l = LBOUND(SrcCB_MatArraysData%PhiR,2)
   i2_u = UBOUND(SrcCB_MatArraysData%PhiR,2)
   IF (.NOT. ALLOCATED(DstCB_MatArraysData%PhiR)) THEN 
      ALLOCATE(DstCB_MatArraysData%PhiR(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%PhiR.', ErrStat, ErrMsg,'SD_CopyCB_MatArrays')
         RETURN
      END IF
   END IF
   DstCB_MatArraysData%PhiR = SrcCB_MatArraysData%PhiR
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%OmegaL)) THEN
   i1_l = LBOUND(SrcCB_MatArraysData%OmegaL,1)
   i1_u = UBOUND(SrcCB_MatArraysData%OmegaL,1)
   IF (.NOT. ALLOCATED(DstCB_MatArraysData%OmegaL)) THEN 
      ALLOCATE(DstCB_MatArraysData%OmegaL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%OmegaL.', ErrStat, ErrMsg,'SD_CopyCB_MatArrays')
         RETURN
      END IF
   END IF
   DstCB_MatArraysData%OmegaL = SrcCB_MatArraysData%OmegaL
ENDIF
 END SUBROUTINE SD_CopyCB_MatArrays

 SUBROUTINE SD_DestroyCB_MatArrays( CB_MatArraysData, ErrStat, ErrMsg )
  TYPE(CB_MatArrays), INTENT(INOUT) :: CB_MatArraysData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(CB_MatArraysData%TI2)) THEN
   DEALLOCATE(CB_MatArraysData%TI2)
ENDIF
IF (ALLOCATED(CB_MatArraysData%MBB)) THEN
   DEALLOCATE(CB_MatArraysData%MBB)
ENDIF
IF (ALLOCATED(CB_MatArraysData%MBM)) THEN
   DEALLOCATE(CB_MatArraysData%MBM)
ENDIF
IF (ALLOCATED(CB_MatArraysData%KBB)) THEN
   DEALLOCATE(CB_MatArraysData%KBB)
ENDIF
IF (ALLOCATED(CB_MatArraysData%PhiL)) THEN
   DEALLOCATE(CB_MatArraysData%PhiL)
ENDIF
IF (ALLOCATED(CB_MatArraysData%PhiR)) THEN
   DEALLOCATE(CB_MatArraysData%PhiR)
ENDIF
IF (ALLOCATED(CB_MatArraysData%OmegaL)) THEN
   DEALLOCATE(CB_MatArraysData%OmegaL)
ENDIF
 END SUBROUTINE SD_DestroyCB_MatArrays

 SUBROUTINE SD_PackCB_MatArrays( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(CB_MatArrays),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! DOFM
  IF ( ALLOCATED(InData%TI2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%TI2 )  ! TI2 
  IF ( ALLOCATED(InData%MBB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MBB )  ! MBB 
  IF ( ALLOCATED(InData%MBM) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MBM )  ! MBM 
  IF ( ALLOCATED(InData%KBB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%KBB )  ! KBB 
  IF ( ALLOCATED(InData%PhiL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiL )  ! PhiL 
  IF ( ALLOCATED(InData%PhiR) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiR )  ! PhiR 
  IF ( ALLOCATED(InData%OmegaL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%OmegaL )  ! OmegaL 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DOFM )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%TI2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TI2))-1 ) =  PACK(InData%TI2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TI2)
  ENDIF
  IF ( ALLOCATED(InData%MBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBB))-1 ) =  PACK(InData%MBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBB)
  ENDIF
  IF ( ALLOCATED(InData%MBM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBM))-1 ) =  PACK(InData%MBM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBM)
  ENDIF
  IF ( ALLOCATED(InData%KBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%KBB))-1 ) =  PACK(InData%KBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%KBB)
  ENDIF
  IF ( ALLOCATED(InData%PhiL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiL))-1 ) =  PACK(InData%PhiL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiL)
  ENDIF
  IF ( ALLOCATED(InData%PhiR) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiR))-1 ) =  PACK(InData%PhiR ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiR)
  ENDIF
  IF ( ALLOCATED(InData%OmegaL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OmegaL))-1 ) =  PACK(InData%OmegaL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%OmegaL)
  ENDIF
 END SUBROUTINE SD_PackCB_MatArrays

 SUBROUTINE SD_UnPackCB_MatArrays( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(CB_MatArrays), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DOFM = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%TI2) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TI2,1),SIZE(OutData%TI2,2)))
  mask2 = .TRUE.
    OutData%TI2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TI2))-1 ),mask2,OutData%TI2)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TI2)
  ENDIF
  IF ( ALLOCATED(OutData%MBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBB,1),SIZE(OutData%MBB,2)))
  mask2 = .TRUE.
    OutData%MBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBB))-1 ),mask2,OutData%MBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBB)
  ENDIF
  IF ( ALLOCATED(OutData%MBM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBM,1),SIZE(OutData%MBM,2)))
  mask2 = .TRUE.
    OutData%MBM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBM))-1 ),mask2,OutData%MBM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBM)
  ENDIF
  IF ( ALLOCATED(OutData%KBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%KBB,1),SIZE(OutData%KBB,2)))
  mask2 = .TRUE.
    OutData%KBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%KBB))-1 ),mask2,OutData%KBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%KBB)
  ENDIF
  IF ( ALLOCATED(OutData%PhiL) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiL,1),SIZE(OutData%PhiL,2)))
  mask2 = .TRUE.
    OutData%PhiL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiL))-1 ),mask2,OutData%PhiL)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiL)
  ENDIF
  IF ( ALLOCATED(OutData%PhiR) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiR,1),SIZE(OutData%PhiR,2)))
  mask2 = .TRUE.
    OutData%PhiR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiR))-1 ),mask2,OutData%PhiR)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiR)
  ENDIF
  IF ( ALLOCATED(OutData%OmegaL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%OmegaL,1)))
  mask1 = .TRUE.
    OutData%OmegaL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OmegaL))-1 ),mask1,OutData%OmegaL)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%OmegaL)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackCB_MatArrays

 SUBROUTINE SD_CopyFEM_MatArrays( SrcFEM_MatArraysData, DstFEM_MatArraysData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEM_MatArrays), INTENT(IN) :: SrcFEM_MatArraysData
   TYPE(FEM_MatArrays), INTENT(INOUT) :: DstFEM_MatArraysData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcFEM_MatArraysData%Omega)) THEN
   i1_l = LBOUND(SrcFEM_MatArraysData%Omega,1)
   i1_u = UBOUND(SrcFEM_MatArraysData%Omega,1)
   IF (.NOT. ALLOCATED(DstFEM_MatArraysData%Omega)) THEN 
      ALLOCATE(DstFEM_MatArraysData%Omega(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFEM_MatArraysData%Omega.', ErrStat, ErrMsg,'SD_CopyFEM_MatArrays')
         RETURN
      END IF
   END IF
   DstFEM_MatArraysData%Omega = SrcFEM_MatArraysData%Omega
ENDIF
   DstFEM_MatArraysData%NOmega = SrcFEM_MatArraysData%NOmega
IF (ALLOCATED(SrcFEM_MatArraysData%Modes)) THEN
   i1_l = LBOUND(SrcFEM_MatArraysData%Modes,1)
   i1_u = UBOUND(SrcFEM_MatArraysData%Modes,1)
   i2_l = LBOUND(SrcFEM_MatArraysData%Modes,2)
   i2_u = UBOUND(SrcFEM_MatArraysData%Modes,2)
   IF (.NOT. ALLOCATED(DstFEM_MatArraysData%Modes)) THEN 
      ALLOCATE(DstFEM_MatArraysData%Modes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFEM_MatArraysData%Modes.', ErrStat, ErrMsg,'SD_CopyFEM_MatArrays')
         RETURN
      END IF
   END IF
   DstFEM_MatArraysData%Modes = SrcFEM_MatArraysData%Modes
ENDIF
 END SUBROUTINE SD_CopyFEM_MatArrays

 SUBROUTINE SD_DestroyFEM_MatArrays( FEM_MatArraysData, ErrStat, ErrMsg )
  TYPE(FEM_MatArrays), INTENT(INOUT) :: FEM_MatArraysData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(FEM_MatArraysData%Omega)) THEN
   DEALLOCATE(FEM_MatArraysData%Omega)
ENDIF
IF (ALLOCATED(FEM_MatArraysData%Modes)) THEN
   DEALLOCATE(FEM_MatArraysData%Modes)
ENDIF
 END SUBROUTINE SD_DestroyFEM_MatArrays

 SUBROUTINE SD_PackFEM_MatArrays( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEM_MatArrays),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%Omega) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Omega )  ! Omega 
  Int_BufSz  = Int_BufSz  + 1  ! NOmega
  IF ( ALLOCATED(InData%Modes) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Modes )  ! Modes 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%Omega) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Omega))-1 ) =  PACK(InData%Omega ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Omega)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NOmega )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Modes) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Modes))-1 ) =  PACK(InData%Modes ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Modes)
  ENDIF
 END SUBROUTINE SD_PackFEM_MatArrays

 SUBROUTINE SD_UnPackFEM_MatArrays( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEM_MatArrays), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%Omega) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Omega,1)))
  mask1 = .TRUE.
    OutData%Omega = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Omega))-1 ),mask1,OutData%Omega)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Omega)
  ENDIF
  OutData%NOmega = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Modes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Modes,1),SIZE(OutData%Modes,2)))
  mask2 = .TRUE.
    OutData%Modes = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Modes))-1 ),mask2,OutData%Modes)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Modes)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackFEM_MatArrays

 SUBROUTINE SD_CopyElemPropType( SrcElemPropTypeData, DstElemPropTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ElemPropType), INTENT(IN) :: SrcElemPropTypeData
   TYPE(ElemPropType), INTENT(INOUT) :: DstElemPropTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstElemPropTypeData%Area = SrcElemPropTypeData%Area
   DstElemPropTypeData%Length = SrcElemPropTypeData%Length
   DstElemPropTypeData%Ixx = SrcElemPropTypeData%Ixx
   DstElemPropTypeData%Iyy = SrcElemPropTypeData%Iyy
   DstElemPropTypeData%Jzz = SrcElemPropTypeData%Jzz
   DstElemPropTypeData%Shear = SrcElemPropTypeData%Shear
   DstElemPropTypeData%Kappa = SrcElemPropTypeData%Kappa
   DstElemPropTypeData%YoungE = SrcElemPropTypeData%YoungE
   DstElemPropTypeData%ShearG = SrcElemPropTypeData%ShearG
   DstElemPropTypeData%Rho = SrcElemPropTypeData%Rho
   DstElemPropTypeData%DirCos = SrcElemPropTypeData%DirCos
 END SUBROUTINE SD_CopyElemPropType

 SUBROUTINE SD_DestroyElemPropType( ElemPropTypeData, ErrStat, ErrMsg )
  TYPE(ElemPropType), INTENT(INOUT) :: ElemPropTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyElemPropType

 SUBROUTINE SD_PackElemPropType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ElemPropType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! Area
  Re_BufSz   = Re_BufSz   + 1  ! Length
  Re_BufSz   = Re_BufSz   + 1  ! Ixx
  Re_BufSz   = Re_BufSz   + 1  ! Iyy
  Re_BufSz   = Re_BufSz   + 1  ! Jzz
  Int_BufSz  = Int_BufSz  + 1  ! Shear
  Re_BufSz   = Re_BufSz   + 1  ! Kappa
  Re_BufSz   = Re_BufSz   + 1  ! YoungE
  Re_BufSz   = Re_BufSz   + 1  ! ShearG
  Re_BufSz   = Re_BufSz   + 1  ! Rho
  Re_BufSz    = Re_BufSz    + SIZE( InData%DirCos )  ! DirCos 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Area )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Length )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ixx )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Iyy )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Jzz )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%Shear ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Kappa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YoungE )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ShearG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Rho )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DirCos))-1 ) =  PACK(InData%DirCos ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DirCos)
 END SUBROUTINE SD_PackElemPropType

 SUBROUTINE SD_UnPackElemPropType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ElemPropType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Area = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Length = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ixx = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Iyy = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Jzz = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Kappa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YoungE = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ShearG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Rho = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%DirCos,1),SIZE(OutData%DirCos,2)))
  mask2 = .TRUE.
  OutData%DirCos = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DirCos))-1 ),mask2,OutData%DirCos)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DirCos)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackElemPropType

 SUBROUTINE SD_CopyInitType( SrcInitTypeData, DstInitTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_InitType), INTENT(IN) :: SrcInitTypeData
   TYPE(SD_InitType), INTENT(INOUT) :: DstInitTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitTypeData%RootName = SrcInitTypeData%RootName
   DstInitTypeData%TP_RefPoint = SrcInitTypeData%TP_RefPoint
   DstInitTypeData%SubRotateZ = SrcInitTypeData%SubRotateZ
   DstInitTypeData%g = SrcInitTypeData%g
   DstInitTypeData%DT = SrcInitTypeData%DT
   DstInitTypeData%NJoints = SrcInitTypeData%NJoints
   DstInitTypeData%NPropSets = SrcInitTypeData%NPropSets
   DstInitTypeData%NXPropSets = SrcInitTypeData%NXPropSets
   DstInitTypeData%NInterf = SrcInitTypeData%NInterf
   DstInitTypeData%NCMass = SrcInitTypeData%NCMass
   DstInitTypeData%NCOSMs = SrcInitTypeData%NCOSMs
   DstInitTypeData%FEMMod = SrcInitTypeData%FEMMod
   DstInitTypeData%NDiv = SrcInitTypeData%NDiv
   DstInitTypeData%CBMod = SrcInitTypeData%CBMod
IF (ALLOCATED(SrcInitTypeData%Joints)) THEN
   i1_l = LBOUND(SrcInitTypeData%Joints,1)
   i1_u = UBOUND(SrcInitTypeData%Joints,1)
   i2_l = LBOUND(SrcInitTypeData%Joints,2)
   i2_u = UBOUND(SrcInitTypeData%Joints,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%Joints)) THEN 
      ALLOCATE(DstInitTypeData%Joints(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Joints.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%Joints = SrcInitTypeData%Joints
ENDIF
IF (ALLOCATED(SrcInitTypeData%PropSets)) THEN
   i1_l = LBOUND(SrcInitTypeData%PropSets,1)
   i1_u = UBOUND(SrcInitTypeData%PropSets,1)
   i2_l = LBOUND(SrcInitTypeData%PropSets,2)
   i2_u = UBOUND(SrcInitTypeData%PropSets,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%PropSets)) THEN 
      ALLOCATE(DstInitTypeData%PropSets(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%PropSets.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%PropSets = SrcInitTypeData%PropSets
ENDIF
IF (ALLOCATED(SrcInitTypeData%XPropSets)) THEN
   i1_l = LBOUND(SrcInitTypeData%XPropSets,1)
   i1_u = UBOUND(SrcInitTypeData%XPropSets,1)
   i2_l = LBOUND(SrcInitTypeData%XPropSets,2)
   i2_u = UBOUND(SrcInitTypeData%XPropSets,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%XPropSets)) THEN 
      ALLOCATE(DstInitTypeData%XPropSets(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%XPropSets.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%XPropSets = SrcInitTypeData%XPropSets
ENDIF
IF (ALLOCATED(SrcInitTypeData%COSMs)) THEN
   i1_l = LBOUND(SrcInitTypeData%COSMs,1)
   i1_u = UBOUND(SrcInitTypeData%COSMs,1)
   i2_l = LBOUND(SrcInitTypeData%COSMs,2)
   i2_u = UBOUND(SrcInitTypeData%COSMs,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%COSMs)) THEN 
      ALLOCATE(DstInitTypeData%COSMs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%COSMs.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%COSMs = SrcInitTypeData%COSMs
ENDIF
IF (ALLOCATED(SrcInitTypeData%CMass)) THEN
   i1_l = LBOUND(SrcInitTypeData%CMass,1)
   i1_u = UBOUND(SrcInitTypeData%CMass,1)
   i2_l = LBOUND(SrcInitTypeData%CMass,2)
   i2_u = UBOUND(SrcInitTypeData%CMass,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%CMass)) THEN 
      ALLOCATE(DstInitTypeData%CMass(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%CMass.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%CMass = SrcInitTypeData%CMass
ENDIF
IF (ALLOCATED(SrcInitTypeData%JDampings)) THEN
   i1_l = LBOUND(SrcInitTypeData%JDampings,1)
   i1_u = UBOUND(SrcInitTypeData%JDampings,1)
   IF (.NOT. ALLOCATED(DstInitTypeData%JDampings)) THEN 
      ALLOCATE(DstInitTypeData%JDampings(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%JDampings.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%JDampings = SrcInitTypeData%JDampings
ENDIF
IF (ALLOCATED(SrcInitTypeData%Members)) THEN
   i1_l = LBOUND(SrcInitTypeData%Members,1)
   i1_u = UBOUND(SrcInitTypeData%Members,1)
   i2_l = LBOUND(SrcInitTypeData%Members,2)
   i2_u = UBOUND(SrcInitTypeData%Members,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%Members)) THEN 
      ALLOCATE(DstInitTypeData%Members(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Members.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%Members = SrcInitTypeData%Members
ENDIF
IF (ALLOCATED(SrcInitTypeData%Interf)) THEN
   i1_l = LBOUND(SrcInitTypeData%Interf,1)
   i1_u = UBOUND(SrcInitTypeData%Interf,1)
   i2_l = LBOUND(SrcInitTypeData%Interf,2)
   i2_u = UBOUND(SrcInitTypeData%Interf,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%Interf)) THEN 
      ALLOCATE(DstInitTypeData%Interf(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Interf.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%Interf = SrcInitTypeData%Interf
ENDIF
IF (ALLOCATED(SrcInitTypeData%SSOutList)) THEN
   i1_l = LBOUND(SrcInitTypeData%SSOutList,1)
   i1_u = UBOUND(SrcInitTypeData%SSOutList,1)
   IF (.NOT. ALLOCATED(DstInitTypeData%SSOutList)) THEN 
      ALLOCATE(DstInitTypeData%SSOutList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%SSOutList.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%SSOutList = SrcInitTypeData%SSOutList
ENDIF
   DstInitTypeData%OutCOSM = SrcInitTypeData%OutCOSM
   DstInitTypeData%TabDelim = SrcInitTypeData%TabDelim
   DstInitTypeData%NNode = SrcInitTypeData%NNode
   DstInitTypeData%NElem = SrcInitTypeData%NElem
   DstInitTypeData%NProp = SrcInitTypeData%NProp
   DstInitTypeData%TDOF = SrcInitTypeData%TDOF
IF (ALLOCATED(SrcInitTypeData%Nodes)) THEN
   i1_l = LBOUND(SrcInitTypeData%Nodes,1)
   i1_u = UBOUND(SrcInitTypeData%Nodes,1)
   i2_l = LBOUND(SrcInitTypeData%Nodes,2)
   i2_u = UBOUND(SrcInitTypeData%Nodes,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%Nodes)) THEN 
      ALLOCATE(DstInitTypeData%Nodes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Nodes.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%Nodes = SrcInitTypeData%Nodes
ENDIF
IF (ALLOCATED(SrcInitTypeData%Props)) THEN
   i1_l = LBOUND(SrcInitTypeData%Props,1)
   i1_u = UBOUND(SrcInitTypeData%Props,1)
   i2_l = LBOUND(SrcInitTypeData%Props,2)
   i2_u = UBOUND(SrcInitTypeData%Props,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%Props)) THEN 
      ALLOCATE(DstInitTypeData%Props(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Props.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%Props = SrcInitTypeData%Props
ENDIF
IF (ALLOCATED(SrcInitTypeData%K)) THEN
   i1_l = LBOUND(SrcInitTypeData%K,1)
   i1_u = UBOUND(SrcInitTypeData%K,1)
   i2_l = LBOUND(SrcInitTypeData%K,2)
   i2_u = UBOUND(SrcInitTypeData%K,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%K)) THEN 
      ALLOCATE(DstInitTypeData%K(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%K.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%K = SrcInitTypeData%K
ENDIF
IF (ALLOCATED(SrcInitTypeData%M)) THEN
   i1_l = LBOUND(SrcInitTypeData%M,1)
   i1_u = UBOUND(SrcInitTypeData%M,1)
   i2_l = LBOUND(SrcInitTypeData%M,2)
   i2_u = UBOUND(SrcInitTypeData%M,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%M)) THEN 
      ALLOCATE(DstInitTypeData%M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%M.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%M = SrcInitTypeData%M
ENDIF
IF (ALLOCATED(SrcInitTypeData%F)) THEN
   i1_l = LBOUND(SrcInitTypeData%F,1)
   i1_u = UBOUND(SrcInitTypeData%F,1)
   IF (.NOT. ALLOCATED(DstInitTypeData%F)) THEN 
      ALLOCATE(DstInitTypeData%F(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%F.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%F = SrcInitTypeData%F
ENDIF
IF (ALLOCATED(SrcInitTypeData%FG)) THEN
   i1_l = LBOUND(SrcInitTypeData%FG,1)
   i1_u = UBOUND(SrcInitTypeData%FG,1)
   IF (.NOT. ALLOCATED(DstInitTypeData%FG)) THEN 
      ALLOCATE(DstInitTypeData%FG(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%FG.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%FG = SrcInitTypeData%FG
ENDIF
IF (ALLOCATED(SrcInitTypeData%ElemProps)) THEN
   i1_l = LBOUND(SrcInitTypeData%ElemProps,1)
   i1_u = UBOUND(SrcInitTypeData%ElemProps,1)
   i2_l = LBOUND(SrcInitTypeData%ElemProps,2)
   i2_u = UBOUND(SrcInitTypeData%ElemProps,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%ElemProps)) THEN 
      ALLOCATE(DstInitTypeData%ElemProps(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%ElemProps.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%ElemProps = SrcInitTypeData%ElemProps
ENDIF
IF (ALLOCATED(SrcInitTypeData%BCs)) THEN
   i1_l = LBOUND(SrcInitTypeData%BCs,1)
   i1_u = UBOUND(SrcInitTypeData%BCs,1)
   i2_l = LBOUND(SrcInitTypeData%BCs,2)
   i2_u = UBOUND(SrcInitTypeData%BCs,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%BCs)) THEN 
      ALLOCATE(DstInitTypeData%BCs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%BCs.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%BCs = SrcInitTypeData%BCs
ENDIF
IF (ALLOCATED(SrcInitTypeData%IntFc)) THEN
   i1_l = LBOUND(SrcInitTypeData%IntFc,1)
   i1_u = UBOUND(SrcInitTypeData%IntFc,1)
   i2_l = LBOUND(SrcInitTypeData%IntFc,2)
   i2_u = UBOUND(SrcInitTypeData%IntFc,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%IntFc)) THEN 
      ALLOCATE(DstInitTypeData%IntFc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%IntFc.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%IntFc = SrcInitTypeData%IntFc
ENDIF
IF (ALLOCATED(SrcInitTypeData%MemberNodes)) THEN
   i1_l = LBOUND(SrcInitTypeData%MemberNodes,1)
   i1_u = UBOUND(SrcInitTypeData%MemberNodes,1)
   i2_l = LBOUND(SrcInitTypeData%MemberNodes,2)
   i2_u = UBOUND(SrcInitTypeData%MemberNodes,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%MemberNodes)) THEN 
      ALLOCATE(DstInitTypeData%MemberNodes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%MemberNodes.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%MemberNodes = SrcInitTypeData%MemberNodes
ENDIF
IF (ALLOCATED(SrcInitTypeData%NodesConnN)) THEN
   i1_l = LBOUND(SrcInitTypeData%NodesConnN,1)
   i1_u = UBOUND(SrcInitTypeData%NodesConnN,1)
   i2_l = LBOUND(SrcInitTypeData%NodesConnN,2)
   i2_u = UBOUND(SrcInitTypeData%NodesConnN,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%NodesConnN)) THEN 
      ALLOCATE(DstInitTypeData%NodesConnN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%NodesConnN.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%NodesConnN = SrcInitTypeData%NodesConnN
ENDIF
IF (ALLOCATED(SrcInitTypeData%NodesConnE)) THEN
   i1_l = LBOUND(SrcInitTypeData%NodesConnE,1)
   i1_u = UBOUND(SrcInitTypeData%NodesConnE,1)
   i2_l = LBOUND(SrcInitTypeData%NodesConnE,2)
   i2_u = UBOUND(SrcInitTypeData%NodesConnE,2)
   IF (.NOT. ALLOCATED(DstInitTypeData%NodesConnE)) THEN 
      ALLOCATE(DstInitTypeData%NodesConnE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%NodesConnE.', ErrStat, ErrMsg,'SD_CopyInitType')
         RETURN
      END IF
   END IF
   DstInitTypeData%NodesConnE = SrcInitTypeData%NodesConnE
ENDIF
   DstInitTypeData%SSSum = SrcInitTypeData%SSSum
 END SUBROUTINE SD_CopyInitType

 SUBROUTINE SD_DestroyInitType( InitTypeData, ErrStat, ErrMsg )
  TYPE(SD_InitType), INTENT(INOUT) :: InitTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitTypeData%Joints)) THEN
   DEALLOCATE(InitTypeData%Joints)
ENDIF
IF (ALLOCATED(InitTypeData%PropSets)) THEN
   DEALLOCATE(InitTypeData%PropSets)
ENDIF
IF (ALLOCATED(InitTypeData%XPropSets)) THEN
   DEALLOCATE(InitTypeData%XPropSets)
ENDIF
IF (ALLOCATED(InitTypeData%COSMs)) THEN
   DEALLOCATE(InitTypeData%COSMs)
ENDIF
IF (ALLOCATED(InitTypeData%CMass)) THEN
   DEALLOCATE(InitTypeData%CMass)
ENDIF
IF (ALLOCATED(InitTypeData%JDampings)) THEN
   DEALLOCATE(InitTypeData%JDampings)
ENDIF
IF (ALLOCATED(InitTypeData%Members)) THEN
   DEALLOCATE(InitTypeData%Members)
ENDIF
IF (ALLOCATED(InitTypeData%Interf)) THEN
   DEALLOCATE(InitTypeData%Interf)
ENDIF
IF (ALLOCATED(InitTypeData%SSOutList)) THEN
   DEALLOCATE(InitTypeData%SSOutList)
ENDIF
IF (ALLOCATED(InitTypeData%Nodes)) THEN
   DEALLOCATE(InitTypeData%Nodes)
ENDIF
IF (ALLOCATED(InitTypeData%Props)) THEN
   DEALLOCATE(InitTypeData%Props)
ENDIF
IF (ALLOCATED(InitTypeData%K)) THEN
   DEALLOCATE(InitTypeData%K)
ENDIF
IF (ALLOCATED(InitTypeData%M)) THEN
   DEALLOCATE(InitTypeData%M)
ENDIF
IF (ALLOCATED(InitTypeData%F)) THEN
   DEALLOCATE(InitTypeData%F)
ENDIF
IF (ALLOCATED(InitTypeData%FG)) THEN
   DEALLOCATE(InitTypeData%FG)
ENDIF
IF (ALLOCATED(InitTypeData%ElemProps)) THEN
   DEALLOCATE(InitTypeData%ElemProps)
ENDIF
IF (ALLOCATED(InitTypeData%BCs)) THEN
   DEALLOCATE(InitTypeData%BCs)
ENDIF
IF (ALLOCATED(InitTypeData%IntFc)) THEN
   DEALLOCATE(InitTypeData%IntFc)
ENDIF
IF (ALLOCATED(InitTypeData%MemberNodes)) THEN
   DEALLOCATE(InitTypeData%MemberNodes)
ENDIF
IF (ALLOCATED(InitTypeData%NodesConnN)) THEN
   DEALLOCATE(InitTypeData%NodesConnN)
ENDIF
IF (ALLOCATED(InitTypeData%NodesConnE)) THEN
   DEALLOCATE(InitTypeData%NodesConnE)
ENDIF
 END SUBROUTINE SD_DestroyInitType

 SUBROUTINE SD_PackInitType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_InitType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for RootName
  Re_BufSz    = Re_BufSz    + SIZE( InData%TP_RefPoint )  ! TP_RefPoint 
  Re_BufSz   = Re_BufSz   + 1  ! SubRotateZ
  Re_BufSz   = Re_BufSz   + 1  ! g
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Int_BufSz  = Int_BufSz  + 1  ! NJoints
  Int_BufSz  = Int_BufSz  + 1  ! NPropSets
  Int_BufSz  = Int_BufSz  + 1  ! NXPropSets
  Int_BufSz  = Int_BufSz  + 1  ! NInterf
  Int_BufSz  = Int_BufSz  + 1  ! NCMass
  Int_BufSz  = Int_BufSz  + 1  ! NCOSMs
  Int_BufSz  = Int_BufSz  + 1  ! FEMMod
  Int_BufSz  = Int_BufSz  + 1  ! NDiv
  Int_BufSz  = Int_BufSz  + 1  ! CBMod
  IF ( ALLOCATED(InData%Joints) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Joints )  ! Joints 
  IF ( ALLOCATED(InData%PropSets) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PropSets )  ! PropSets 
  IF ( ALLOCATED(InData%XPropSets) )   Re_BufSz    = Re_BufSz    + SIZE( InData%XPropSets )  ! XPropSets 
  IF ( ALLOCATED(InData%COSMs) )   Re_BufSz    = Re_BufSz    + SIZE( InData%COSMs )  ! COSMs 
  IF ( ALLOCATED(InData%CMass) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CMass )  ! CMass 
  IF ( ALLOCATED(InData%JDampings) )   Re_BufSz    = Re_BufSz    + SIZE( InData%JDampings )  ! JDampings 
  IF ( ALLOCATED(InData%Members) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Members )  ! Members 
  IF ( ALLOCATED(InData%Interf) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Interf )  ! Interf 
!  missing buffer for SSOutList
  Int_BufSz  = Int_BufSz  + 1  ! OutCOSM
  Int_BufSz  = Int_BufSz  + 1  ! TabDelim
  Int_BufSz  = Int_BufSz  + 1  ! NNode
  Int_BufSz  = Int_BufSz  + 1  ! NElem
  Int_BufSz  = Int_BufSz  + 1  ! NProp
  Int_BufSz  = Int_BufSz  + 1  ! TDOF
  IF ( ALLOCATED(InData%Nodes) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Nodes )  ! Nodes 
  IF ( ALLOCATED(InData%Props) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Props )  ! Props 
  IF ( ALLOCATED(InData%K) )   Re_BufSz    = Re_BufSz    + SIZE( InData%K )  ! K 
  IF ( ALLOCATED(InData%M) )   Re_BufSz    = Re_BufSz    + SIZE( InData%M )  ! M 
  IF ( ALLOCATED(InData%F) )   Re_BufSz    = Re_BufSz    + SIZE( InData%F )  ! F 
  IF ( ALLOCATED(InData%FG) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FG )  ! FG 
  IF ( ALLOCATED(InData%ElemProps) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ElemProps )  ! ElemProps 
  IF ( ALLOCATED(InData%BCs) )   Int_BufSz   = Int_BufSz   + SIZE( InData%BCs )  ! BCs 
  IF ( ALLOCATED(InData%IntFc) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IntFc )  ! IntFc 
  IF ( ALLOCATED(InData%MemberNodes) )   Int_BufSz   = Int_BufSz   + SIZE( InData%MemberNodes )  ! MemberNodes 
  IF ( ALLOCATED(InData%NodesConnN) )   Int_BufSz   = Int_BufSz   + SIZE( InData%NodesConnN )  ! NodesConnN 
  IF ( ALLOCATED(InData%NodesConnE) )   Int_BufSz   = Int_BufSz   + SIZE( InData%NodesConnE )  ! NodesConnE 
  Int_BufSz  = Int_BufSz  + 1  ! SSSum
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TP_RefPoint))-1 ) =  PACK(InData%TP_RefPoint ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TP_RefPoint)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SubRotateZ )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NJoints )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NPropSets )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NXPropSets )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NInterf )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCMass )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCOSMs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%FEMMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NDiv )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%CBMod ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Joints) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Joints))-1 ) =  PACK(InData%Joints ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Joints)
  ENDIF
  IF ( ALLOCATED(InData%PropSets) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PropSets))-1 ) =  PACK(InData%PropSets ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PropSets)
  ENDIF
  IF ( ALLOCATED(InData%XPropSets) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%XPropSets))-1 ) =  PACK(InData%XPropSets ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%XPropSets)
  ENDIF
  IF ( ALLOCATED(InData%COSMs) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%COSMs))-1 ) =  PACK(InData%COSMs ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%COSMs)
  ENDIF
  IF ( ALLOCATED(InData%CMass) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CMass))-1 ) =  PACK(InData%CMass ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CMass)
  ENDIF
  IF ( ALLOCATED(InData%JDampings) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%JDampings))-1 ) =  PACK(InData%JDampings ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%JDampings)
  ENDIF
  IF ( ALLOCATED(InData%Members) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Members))-1 ) = PACK(InData%Members ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Members)
  ENDIF
  IF ( ALLOCATED(InData%Interf) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Interf))-1 ) = PACK(InData%Interf ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Interf)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%OutCOSM ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%TabDelim ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NElem )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NProp )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TDOF )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Nodes) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Nodes))-1 ) =  PACK(InData%Nodes ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Nodes)
  ENDIF
  IF ( ALLOCATED(InData%Props) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Props))-1 ) =  PACK(InData%Props ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Props)
  ENDIF
  IF ( ALLOCATED(InData%K) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%K))-1 ) =  PACK(InData%K ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%K)
  ENDIF
  IF ( ALLOCATED(InData%M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%M))-1 ) =  PACK(InData%M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%M)
  ENDIF
  IF ( ALLOCATED(InData%F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F))-1 ) =  PACK(InData%F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F)
  ENDIF
  IF ( ALLOCATED(InData%FG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FG))-1 ) =  PACK(InData%FG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FG)
  ENDIF
  IF ( ALLOCATED(InData%ElemProps) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ElemProps))-1 ) =  PACK(InData%ElemProps ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ElemProps)
  ENDIF
  IF ( ALLOCATED(InData%BCs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%BCs))-1 ) = PACK(InData%BCs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%BCs)
  ENDIF
  IF ( ALLOCATED(InData%IntFc) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IntFc))-1 ) = PACK(InData%IntFc ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IntFc)
  ENDIF
  IF ( ALLOCATED(InData%MemberNodes) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%MemberNodes))-1 ) = PACK(InData%MemberNodes ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%MemberNodes)
  ENDIF
  IF ( ALLOCATED(InData%NodesConnN) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodesConnN))-1 ) = PACK(InData%NodesConnN ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodesConnN)
  ENDIF
  IF ( ALLOCATED(InData%NodesConnE) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodesConnE))-1 ) = PACK(InData%NodesConnE ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodesConnE)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%SSSum ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_PackInitType

 SUBROUTINE SD_UnPackInitType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_InitType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  ALLOCATE(mask1(SIZE(OutData%TP_RefPoint,1)))
  mask1 = .TRUE.
  OutData%TP_RefPoint = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TP_RefPoint))-1 ),mask1,OutData%TP_RefPoint)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TP_RefPoint)
  OutData%SubRotateZ = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%NJoints = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NPropSets = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NXPropSets = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NInterf = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NCMass = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NCOSMs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%FEMMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NDiv = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Joints) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Joints,1),SIZE(OutData%Joints,2)))
  mask2 = .TRUE.
    OutData%Joints = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Joints))-1 ),mask2,OutData%Joints)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Joints)
  ENDIF
  IF ( ALLOCATED(OutData%PropSets) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PropSets,1),SIZE(OutData%PropSets,2)))
  mask2 = .TRUE.
    OutData%PropSets = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PropSets))-1 ),mask2,OutData%PropSets)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PropSets)
  ENDIF
  IF ( ALLOCATED(OutData%XPropSets) ) THEN
  ALLOCATE(mask2(SIZE(OutData%XPropSets,1),SIZE(OutData%XPropSets,2)))
  mask2 = .TRUE.
    OutData%XPropSets = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%XPropSets))-1 ),mask2,OutData%XPropSets)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%XPropSets)
  ENDIF
  IF ( ALLOCATED(OutData%COSMs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%COSMs,1),SIZE(OutData%COSMs,2)))
  mask2 = .TRUE.
    OutData%COSMs = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%COSMs))-1 ),mask2,OutData%COSMs)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%COSMs)
  ENDIF
  IF ( ALLOCATED(OutData%CMass) ) THEN
  ALLOCATE(mask2(SIZE(OutData%CMass,1),SIZE(OutData%CMass,2)))
  mask2 = .TRUE.
    OutData%CMass = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CMass))-1 ),mask2,OutData%CMass)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CMass)
  ENDIF
  IF ( ALLOCATED(OutData%JDampings) ) THEN
  ALLOCATE(mask1(SIZE(OutData%JDampings,1)))
  mask1 = .TRUE.
    OutData%JDampings = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%JDampings))-1 ),mask1,OutData%JDampings)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%JDampings)
  ENDIF
  IF ( ALLOCATED(OutData%Members) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Members,1),SIZE(OutData%Members,2)))
  mask2 = .TRUE.
    OutData%Members = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Members))-1 ),mask2,OutData%Members)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Members)
  ENDIF
  IF ( ALLOCATED(OutData%Interf) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Interf,1),SIZE(OutData%Interf,2)))
  mask2 = .TRUE.
    OutData%Interf = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Interf))-1 ),mask2,OutData%Interf)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Interf)
  ENDIF
  OutData%NNode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NElem = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NProp = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TDOF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Nodes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Nodes,1),SIZE(OutData%Nodes,2)))
  mask2 = .TRUE.
    OutData%Nodes = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Nodes))-1 ),mask2,OutData%Nodes)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Nodes)
  ENDIF
  IF ( ALLOCATED(OutData%Props) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Props,1),SIZE(OutData%Props,2)))
  mask2 = .TRUE.
    OutData%Props = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Props))-1 ),mask2,OutData%Props)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Props)
  ENDIF
  IF ( ALLOCATED(OutData%K) ) THEN
  ALLOCATE(mask2(SIZE(OutData%K,1),SIZE(OutData%K,2)))
  mask2 = .TRUE.
    OutData%K = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%K))-1 ),mask2,OutData%K)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%K)
  ENDIF
  IF ( ALLOCATED(OutData%M) ) THEN
  ALLOCATE(mask2(SIZE(OutData%M,1),SIZE(OutData%M,2)))
  mask2 = .TRUE.
    OutData%M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%M))-1 ),mask2,OutData%M)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%M)
  ENDIF
  IF ( ALLOCATED(OutData%F) ) THEN
  ALLOCATE(mask1(SIZE(OutData%F,1)))
  mask1 = .TRUE.
    OutData%F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F))-1 ),mask1,OutData%F)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F)
  ENDIF
  IF ( ALLOCATED(OutData%FG) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FG,1)))
  mask1 = .TRUE.
    OutData%FG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FG))-1 ),mask1,OutData%FG)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FG)
  ENDIF
  IF ( ALLOCATED(OutData%ElemProps) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElemProps,1),SIZE(OutData%ElemProps,2)))
  mask2 = .TRUE.
    OutData%ElemProps = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ElemProps))-1 ),mask2,OutData%ElemProps)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ElemProps)
  ENDIF
  IF ( ALLOCATED(OutData%BCs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%BCs,1),SIZE(OutData%BCs,2)))
  mask2 = .TRUE.
    OutData%BCs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%BCs))-1 ),mask2,OutData%BCs)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%BCs)
  ENDIF
  IF ( ALLOCATED(OutData%IntFc) ) THEN
  ALLOCATE(mask2(SIZE(OutData%IntFc,1),SIZE(OutData%IntFc,2)))
  mask2 = .TRUE.
    OutData%IntFc = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IntFc))-1 ),mask2,OutData%IntFc)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IntFc)
  ENDIF
  IF ( ALLOCATED(OutData%MemberNodes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MemberNodes,1),SIZE(OutData%MemberNodes,2)))
  mask2 = .TRUE.
    OutData%MemberNodes = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%MemberNodes))-1 ),mask2,OutData%MemberNodes)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%MemberNodes)
  ENDIF
  IF ( ALLOCATED(OutData%NodesConnN) ) THEN
  ALLOCATE(mask2(SIZE(OutData%NodesConnN,1),SIZE(OutData%NodesConnN,2)))
  mask2 = .TRUE.
    OutData%NodesConnN = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodesConnN))-1 ),mask2,OutData%NodesConnN)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodesConnN)
  ENDIF
  IF ( ALLOCATED(OutData%NodesConnE) ) THEN
  ALLOCATE(mask2(SIZE(OutData%NodesConnE,1),SIZE(OutData%NodesConnE,2)))
  mask2 = .TRUE.
    OutData%NodesConnE = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodesConnE))-1 ),mask2,OutData%NodesConnE)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodesConnE)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInitType

 SUBROUTINE SD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(SD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%qm)) THEN
   i1_l = LBOUND(SrcContStateData%qm,1)
   i1_u = UBOUND(SrcContStateData%qm,1)
   IF (.NOT. ALLOCATED(DstContStateData%qm)) THEN 
      ALLOCATE(DstContStateData%qm(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%qm.', ErrStat, ErrMsg,'SD_CopyContState')
         RETURN
      END IF
   END IF
   DstContStateData%qm = SrcContStateData%qm
ENDIF
IF (ALLOCATED(SrcContStateData%qmdot)) THEN
   i1_l = LBOUND(SrcContStateData%qmdot,1)
   i1_u = UBOUND(SrcContStateData%qmdot,1)
   IF (.NOT. ALLOCATED(DstContStateData%qmdot)) THEN 
      ALLOCATE(DstContStateData%qmdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%qmdot.', ErrStat, ErrMsg,'SD_CopyContState')
         RETURN
      END IF
   END IF
   DstContStateData%qmdot = SrcContStateData%qmdot
ENDIF
 END SUBROUTINE SD_CopyContState

 SUBROUTINE SD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(SD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ContStateData%qm)) THEN
   DEALLOCATE(ContStateData%qm)
ENDIF
IF (ALLOCATED(ContStateData%qmdot)) THEN
   DEALLOCATE(ContStateData%qmdot)
ENDIF
 END SUBROUTINE SD_DestroyContState

 SUBROUTINE SD_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%qm) )   Re_BufSz    = Re_BufSz    + SIZE( InData%qm )  ! qm 
  IF ( ALLOCATED(InData%qmdot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%qmdot )  ! qmdot 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%qm) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qm))-1 ) =  PACK(InData%qm ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qm)
  ENDIF
  IF ( ALLOCATED(InData%qmdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qmdot))-1 ) =  PACK(InData%qmdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qmdot)
  ENDIF
 END SUBROUTINE SD_PackContState

 SUBROUTINE SD_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%qm) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qm,1)))
  mask1 = .TRUE.
    OutData%qm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qm))-1 ),mask1,OutData%qm)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qm)
  ENDIF
  IF ( ALLOCATED(OutData%qmdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qmdot,1)))
  mask1 = .TRUE.
    OutData%qmdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qmdot))-1 ),mask1,OutData%qmdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qmdot)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackContState

 SUBROUTINE SD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(SD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE SD_CopyDiscState

 SUBROUTINE SD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(SD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyDiscState

 SUBROUTINE SD_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackDiscState

 SUBROUTINE SD_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackDiscState

 SUBROUTINE SD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(SD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE SD_CopyConstrState

 SUBROUTINE SD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(SD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyConstrState

 SUBROUTINE SD_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackConstrState

 SUBROUTINE SD_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackConstrState

 SUBROUTINE SD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(SD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%xdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%xdot,1)
   i1_u = UBOUND(SrcOtherStateData%xdot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%xdot)) THEN 
      ALLOCATE(DstOtherStateData%xdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%xdot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%xdot,1), UBOUND(SrcOtherStateData%xdot,1)
      CALL SD_CopyContState( SrcOtherStateData%xdot(i1), DstOtherStateData%xdot(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyOtherState:xdot(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstOtherStateData%n = SrcOtherStateData%n
IF (ALLOCATED(SrcOtherStateData%SDWrOutput)) THEN
   i1_l = LBOUND(SrcOtherStateData%SDWrOutput,1)
   i1_u = UBOUND(SrcOtherStateData%SDWrOutput,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%SDWrOutput)) THEN 
      ALLOCATE(DstOtherStateData%SDWrOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%SDWrOutput.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%SDWrOutput = SrcOtherStateData%SDWrOutput
ENDIF
   DstOtherStateData%LastOutTime = SrcOtherStateData%LastOutTime
   DstOtherStateData%Decimat = SrcOtherStateData%Decimat
IF (ALLOCATED(SrcOtherStateData%qmdotdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%qmdotdot,1)
   i1_u = UBOUND(SrcOtherStateData%qmdotdot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%qmdotdot)) THEN 
      ALLOCATE(DstOtherStateData%qmdotdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%qmdotdot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%qmdotdot = SrcOtherStateData%qmdotdot
ENDIF
   DstOtherStateData%u_TP = SrcOtherStateData%u_TP
   DstOtherStateData%udot_TP = SrcOtherStateData%udot_TP
   DstOtherStateData%udotdot_TP = SrcOtherStateData%udotdot_TP
IF (ALLOCATED(SrcOtherStateData%UFL)) THEN
   i1_l = LBOUND(SrcOtherStateData%UFL,1)
   i1_u = UBOUND(SrcOtherStateData%UFL,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UFL)) THEN 
      ALLOCATE(DstOtherStateData%UFL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UFL.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UFL = SrcOtherStateData%UFL
ENDIF
IF (ALLOCATED(SrcOtherStateData%UR_bar)) THEN
   i1_l = LBOUND(SrcOtherStateData%UR_bar,1)
   i1_u = UBOUND(SrcOtherStateData%UR_bar,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UR_bar)) THEN 
      ALLOCATE(DstOtherStateData%UR_bar(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UR_bar.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UR_bar = SrcOtherStateData%UR_bar
ENDIF
IF (ALLOCATED(SrcOtherStateData%UR_bar_dot)) THEN
   i1_l = LBOUND(SrcOtherStateData%UR_bar_dot,1)
   i1_u = UBOUND(SrcOtherStateData%UR_bar_dot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UR_bar_dot)) THEN 
      ALLOCATE(DstOtherStateData%UR_bar_dot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UR_bar_dot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UR_bar_dot = SrcOtherStateData%UR_bar_dot
ENDIF
IF (ALLOCATED(SrcOtherStateData%UR_bar_dotdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%UR_bar_dotdot,1)
   i1_u = UBOUND(SrcOtherStateData%UR_bar_dotdot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UR_bar_dotdot)) THEN 
      ALLOCATE(DstOtherStateData%UR_bar_dotdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UR_bar_dotdot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UR_bar_dotdot = SrcOtherStateData%UR_bar_dotdot
ENDIF
IF (ALLOCATED(SrcOtherStateData%UL)) THEN
   i1_l = LBOUND(SrcOtherStateData%UL,1)
   i1_u = UBOUND(SrcOtherStateData%UL,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UL)) THEN 
      ALLOCATE(DstOtherStateData%UL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UL.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UL = SrcOtherStateData%UL
ENDIF
IF (ALLOCATED(SrcOtherStateData%UL_dot)) THEN
   i1_l = LBOUND(SrcOtherStateData%UL_dot,1)
   i1_u = UBOUND(SrcOtherStateData%UL_dot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UL_dot)) THEN 
      ALLOCATE(DstOtherStateData%UL_dot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UL_dot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UL_dot = SrcOtherStateData%UL_dot
ENDIF
IF (ALLOCATED(SrcOtherStateData%UL_dotdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%UL_dotdot,1)
   i1_u = UBOUND(SrcOtherStateData%UL_dotdot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UL_dotdot)) THEN 
      ALLOCATE(DstOtherStateData%UL_dotdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UL_dotdot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UL_dotdot = SrcOtherStateData%UL_dotdot
ENDIF
 END SUBROUTINE SD_CopyOtherState

 SUBROUTINE SD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(SD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%xdot)) THEN
DO i1 = LBOUND(OtherStateData%xdot,1), UBOUND(OtherStateData%xdot,1)
  CALL SD_DestroyContState( OtherStateData%xdot(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%xdot)
ENDIF
IF (ALLOCATED(OtherStateData%SDWrOutput)) THEN
   DEALLOCATE(OtherStateData%SDWrOutput)
ENDIF
IF (ALLOCATED(OtherStateData%qmdotdot)) THEN
   DEALLOCATE(OtherStateData%qmdotdot)
ENDIF
IF (ALLOCATED(OtherStateData%UFL)) THEN
   DEALLOCATE(OtherStateData%UFL)
ENDIF
IF (ALLOCATED(OtherStateData%UR_bar)) THEN
   DEALLOCATE(OtherStateData%UR_bar)
ENDIF
IF (ALLOCATED(OtherStateData%UR_bar_dot)) THEN
   DEALLOCATE(OtherStateData%UR_bar_dot)
ENDIF
IF (ALLOCATED(OtherStateData%UR_bar_dotdot)) THEN
   DEALLOCATE(OtherStateData%UR_bar_dotdot)
ENDIF
IF (ALLOCATED(OtherStateData%UL)) THEN
   DEALLOCATE(OtherStateData%UL)
ENDIF
IF (ALLOCATED(OtherStateData%UL_dot)) THEN
   DEALLOCATE(OtherStateData%UL_dot)
ENDIF
IF (ALLOCATED(OtherStateData%UL_dotdot)) THEN
   DEALLOCATE(OtherStateData%UL_dotdot)
ENDIF
 END SUBROUTINE SD_DestroyOtherState

 SUBROUTINE SD_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_xdot_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(InData%xdot,1), UBOUND(InData%xdot,1)
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Db_xdot_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Int_xdot_Buf))Int_BufSz = Int_BufSz + SIZE( Int_xdot_Buf ) ! xdot
  IF(ALLOCATED(Re_xdot_Buf))  DEALLOCATE(Re_xdot_Buf)
  IF(ALLOCATED(Db_xdot_Buf))  DEALLOCATE(Db_xdot_Buf)
  IF(ALLOCATED(Int_xdot_Buf)) DEALLOCATE(Int_xdot_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! n
  IF ( ALLOCATED(InData%SDWrOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%SDWrOutput )  ! SDWrOutput 
  Db_BufSz   = Db_BufSz   + 1  ! LastOutTime
  Int_BufSz  = Int_BufSz  + 1  ! Decimat
  IF ( ALLOCATED(InData%qmdotdot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%qmdotdot )  ! qmdotdot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%u_TP )  ! u_TP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%udot_TP )  ! udot_TP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%udotdot_TP )  ! udotdot_TP 
  IF ( ALLOCATED(InData%UFL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UFL )  ! UFL 
  IF ( ALLOCATED(InData%UR_bar) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UR_bar )  ! UR_bar 
  IF ( ALLOCATED(InData%UR_bar_dot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UR_bar_dot )  ! UR_bar_dot 
  IF ( ALLOCATED(InData%UR_bar_dotdot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UR_bar_dotdot )  ! UR_bar_dotdot 
  IF ( ALLOCATED(InData%UL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UL )  ! UL 
  IF ( ALLOCATED(InData%UL_dot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UL_dot )  ! UL_dot 
  IF ( ALLOCATED(InData%UL_dotdot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UL_dotdot )  ! UL_dotdot 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
DO i1 = LBOUND(InData%xdot,1), UBOUND(InData%xdot,1)
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, OnlySize ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 ) = Re_xdot_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 ) = Db_xdot_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 ) = Int_xdot_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  IF( ALLOCATED(Re_xdot_Buf) )  DEALLOCATE(Re_xdot_Buf)
  IF( ALLOCATED(Db_xdot_Buf) )  DEALLOCATE(Db_xdot_Buf)
  IF( ALLOCATED(Int_xdot_Buf) ) DEALLOCATE(Int_xdot_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%n )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%SDWrOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SDWrOutput))-1 ) =  PACK(InData%SDWrOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%SDWrOutput)
  ENDIF
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%LastOutTime )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Decimat )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%qmdotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qmdotdot))-1 ) =  PACK(InData%qmdotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qmdotdot)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%u_TP))-1 ) =  PACK(InData%u_TP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%u_TP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%udot_TP))-1 ) =  PACK(InData%udot_TP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%udot_TP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%udotdot_TP))-1 ) =  PACK(InData%udotdot_TP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%udotdot_TP)
  IF ( ALLOCATED(InData%UFL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UFL))-1 ) =  PACK(InData%UFL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UFL)
  ENDIF
  IF ( ALLOCATED(InData%UR_bar) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UR_bar))-1 ) =  PACK(InData%UR_bar ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UR_bar)
  ENDIF
  IF ( ALLOCATED(InData%UR_bar_dot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UR_bar_dot))-1 ) =  PACK(InData%UR_bar_dot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UR_bar_dot)
  ENDIF
  IF ( ALLOCATED(InData%UR_bar_dotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UR_bar_dotdot))-1 ) =  PACK(InData%UR_bar_dotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UR_bar_dotdot)
  ENDIF
  IF ( ALLOCATED(InData%UL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UL))-1 ) =  PACK(InData%UL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UL)
  ENDIF
  IF ( ALLOCATED(InData%UL_dot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UL_dot))-1 ) =  PACK(InData%UL_dot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UL_dot)
  ENDIF
  IF ( ALLOCATED(InData%UL_dotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UL_dotdot))-1 ) =  PACK(InData%UL_dotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UL_dotdot)
  ENDIF
 END SUBROUTINE SD_PackOtherState

 SUBROUTINE SD_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_xdot_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(OutData%xdot,1), UBOUND(OutData%xdot,1)
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    Re_xdot_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    Db_xdot_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    Int_xdot_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg ) ! xdot 
ENDDO
  OutData%n = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%SDWrOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%SDWrOutput,1)))
  mask1 = .TRUE.
    OutData%SDWrOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SDWrOutput))-1 ),mask1,OutData%SDWrOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%SDWrOutput)
  ENDIF
  OutData%LastOutTime = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%Decimat = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%qmdotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qmdotdot,1)))
  mask1 = .TRUE.
    OutData%qmdotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qmdotdot))-1 ),mask1,OutData%qmdotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qmdotdot)
  ENDIF
  ALLOCATE(mask1(SIZE(OutData%u_TP,1)))
  mask1 = .TRUE.
  OutData%u_TP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%u_TP))-1 ),mask1,OutData%u_TP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%u_TP)
  ALLOCATE(mask1(SIZE(OutData%udot_TP,1)))
  mask1 = .TRUE.
  OutData%udot_TP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%udot_TP))-1 ),mask1,OutData%udot_TP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%udot_TP)
  ALLOCATE(mask1(SIZE(OutData%udotdot_TP,1)))
  mask1 = .TRUE.
  OutData%udotdot_TP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%udotdot_TP))-1 ),mask1,OutData%udotdot_TP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%udotdot_TP)
  IF ( ALLOCATED(OutData%UFL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UFL,1)))
  mask1 = .TRUE.
    OutData%UFL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UFL))-1 ),mask1,OutData%UFL)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UFL)
  ENDIF
  IF ( ALLOCATED(OutData%UR_bar) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UR_bar,1)))
  mask1 = .TRUE.
    OutData%UR_bar = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UR_bar))-1 ),mask1,OutData%UR_bar)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UR_bar)
  ENDIF
  IF ( ALLOCATED(OutData%UR_bar_dot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UR_bar_dot,1)))
  mask1 = .TRUE.
    OutData%UR_bar_dot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UR_bar_dot))-1 ),mask1,OutData%UR_bar_dot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UR_bar_dot)
  ENDIF
  IF ( ALLOCATED(OutData%UR_bar_dotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UR_bar_dotdot,1)))
  mask1 = .TRUE.
    OutData%UR_bar_dotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UR_bar_dotdot))-1 ),mask1,OutData%UR_bar_dotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UR_bar_dotdot)
  ENDIF
  IF ( ALLOCATED(OutData%UL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UL,1)))
  mask1 = .TRUE.
    OutData%UL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UL))-1 ),mask1,OutData%UL)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UL)
  ENDIF
  IF ( ALLOCATED(OutData%UL_dot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UL_dot,1)))
  mask1 = .TRUE.
    OutData%UL_dot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UL_dot))-1 ),mask1,OutData%UL_dot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UL_dot)
  ENDIF
  IF ( ALLOCATED(OutData%UL_dotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UL_dotdot,1)))
  mask1 = .TRUE.
    OutData%UL_dotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UL_dotdot))-1 ),mask1,OutData%UL_dotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UL_dotdot)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackOtherState

 SUBROUTINE SD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(SD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%SDDeltaT = SrcParamData%SDDeltaT
   DstParamData%SttcSolve = SrcParamData%SttcSolve
IF (ALLOCATED(SrcParamData%NOmegaM2)) THEN
   i1_l = LBOUND(SrcParamData%NOmegaM2,1)
   i1_u = UBOUND(SrcParamData%NOmegaM2,1)
   IF (.NOT. ALLOCATED(DstParamData%NOmegaM2)) THEN 
      ALLOCATE(DstParamData%NOmegaM2(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%NOmegaM2.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%NOmegaM2 = SrcParamData%NOmegaM2
ENDIF
IF (ALLOCATED(SrcParamData%N2OmegaMJDamp)) THEN
   i1_l = LBOUND(SrcParamData%N2OmegaMJDamp,1)
   i1_u = UBOUND(SrcParamData%N2OmegaMJDamp,1)
   IF (.NOT. ALLOCATED(DstParamData%N2OmegaMJDamp)) THEN 
      ALLOCATE(DstParamData%N2OmegaMJDamp(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%N2OmegaMJDamp.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%N2OmegaMJDamp = SrcParamData%N2OmegaMJDamp
ENDIF
IF (ALLOCATED(SrcParamData%MMB)) THEN
   i1_l = LBOUND(SrcParamData%MMB,1)
   i1_u = UBOUND(SrcParamData%MMB,1)
   i2_l = LBOUND(SrcParamData%MMB,2)
   i2_u = UBOUND(SrcParamData%MMB,2)
   IF (.NOT. ALLOCATED(DstParamData%MMB)) THEN 
      ALLOCATE(DstParamData%MMB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MMB.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%MMB = SrcParamData%MMB
ENDIF
IF (ALLOCATED(SrcParamData%FX)) THEN
   i1_l = LBOUND(SrcParamData%FX,1)
   i1_u = UBOUND(SrcParamData%FX,1)
   IF (.NOT. ALLOCATED(DstParamData%FX)) THEN 
      ALLOCATE(DstParamData%FX(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FX.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%FX = SrcParamData%FX
ENDIF
IF (ALLOCATED(SrcParamData%C1_11)) THEN
   i1_l = LBOUND(SrcParamData%C1_11,1)
   i1_u = UBOUND(SrcParamData%C1_11,1)
   i2_l = LBOUND(SrcParamData%C1_11,2)
   i2_u = UBOUND(SrcParamData%C1_11,2)
   IF (.NOT. ALLOCATED(DstParamData%C1_11)) THEN 
      ALLOCATE(DstParamData%C1_11(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C1_11.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%C1_11 = SrcParamData%C1_11
ENDIF
IF (ALLOCATED(SrcParamData%C1_12)) THEN
   i1_l = LBOUND(SrcParamData%C1_12,1)
   i1_u = UBOUND(SrcParamData%C1_12,1)
   i2_l = LBOUND(SrcParamData%C1_12,2)
   i2_u = UBOUND(SrcParamData%C1_12,2)
   IF (.NOT. ALLOCATED(DstParamData%C1_12)) THEN 
      ALLOCATE(DstParamData%C1_12(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C1_12.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%C1_12 = SrcParamData%C1_12
ENDIF
IF (ALLOCATED(SrcParamData%D1_13)) THEN
   i1_l = LBOUND(SrcParamData%D1_13,1)
   i1_u = UBOUND(SrcParamData%D1_13,1)
   i2_l = LBOUND(SrcParamData%D1_13,2)
   i2_u = UBOUND(SrcParamData%D1_13,2)
   IF (.NOT. ALLOCATED(DstParamData%D1_13)) THEN 
      ALLOCATE(DstParamData%D1_13(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D1_13.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D1_13 = SrcParamData%D1_13
ENDIF
IF (ALLOCATED(SrcParamData%D1_14)) THEN
   i1_l = LBOUND(SrcParamData%D1_14,1)
   i1_u = UBOUND(SrcParamData%D1_14,1)
   i2_l = LBOUND(SrcParamData%D1_14,2)
   i2_u = UBOUND(SrcParamData%D1_14,2)
   IF (.NOT. ALLOCATED(DstParamData%D1_14)) THEN 
      ALLOCATE(DstParamData%D1_14(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D1_14.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D1_14 = SrcParamData%D1_14
ENDIF
IF (ALLOCATED(SrcParamData%FY)) THEN
   i1_l = LBOUND(SrcParamData%FY,1)
   i1_u = UBOUND(SrcParamData%FY,1)
   IF (.NOT. ALLOCATED(DstParamData%FY)) THEN 
      ALLOCATE(DstParamData%FY(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FY.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%FY = SrcParamData%FY
ENDIF
IF (ALLOCATED(SrcParamData%PhiM)) THEN
   i1_l = LBOUND(SrcParamData%PhiM,1)
   i1_u = UBOUND(SrcParamData%PhiM,1)
   i2_l = LBOUND(SrcParamData%PhiM,2)
   i2_u = UBOUND(SrcParamData%PhiM,2)
   IF (.NOT. ALLOCATED(DstParamData%PhiM)) THEN 
      ALLOCATE(DstParamData%PhiM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiM.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%PhiM = SrcParamData%PhiM
ENDIF
IF (ALLOCATED(SrcParamData%C2_61)) THEN
   i1_l = LBOUND(SrcParamData%C2_61,1)
   i1_u = UBOUND(SrcParamData%C2_61,1)
   i2_l = LBOUND(SrcParamData%C2_61,2)
   i2_u = UBOUND(SrcParamData%C2_61,2)
   IF (.NOT. ALLOCATED(DstParamData%C2_61)) THEN 
      ALLOCATE(DstParamData%C2_61(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C2_61.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%C2_61 = SrcParamData%C2_61
ENDIF
IF (ALLOCATED(SrcParamData%C2_62)) THEN
   i1_l = LBOUND(SrcParamData%C2_62,1)
   i1_u = UBOUND(SrcParamData%C2_62,1)
   i2_l = LBOUND(SrcParamData%C2_62,2)
   i2_u = UBOUND(SrcParamData%C2_62,2)
   IF (.NOT. ALLOCATED(DstParamData%C2_62)) THEN 
      ALLOCATE(DstParamData%C2_62(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C2_62.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%C2_62 = SrcParamData%C2_62
ENDIF
IF (ALLOCATED(SrcParamData%PhiRb_TI)) THEN
   i1_l = LBOUND(SrcParamData%PhiRb_TI,1)
   i1_u = UBOUND(SrcParamData%PhiRb_TI,1)
   i2_l = LBOUND(SrcParamData%PhiRb_TI,2)
   i2_u = UBOUND(SrcParamData%PhiRb_TI,2)
   IF (.NOT. ALLOCATED(DstParamData%PhiRb_TI)) THEN 
      ALLOCATE(DstParamData%PhiRb_TI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiRb_TI.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%PhiRb_TI = SrcParamData%PhiRb_TI
ENDIF
IF (ALLOCATED(SrcParamData%D2_63)) THEN
   i1_l = LBOUND(SrcParamData%D2_63,1)
   i1_u = UBOUND(SrcParamData%D2_63,1)
   i2_l = LBOUND(SrcParamData%D2_63,2)
   i2_u = UBOUND(SrcParamData%D2_63,2)
   IF (.NOT. ALLOCATED(DstParamData%D2_63)) THEN 
      ALLOCATE(DstParamData%D2_63(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D2_63.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D2_63 = SrcParamData%D2_63
ENDIF
IF (ALLOCATED(SrcParamData%D2_64)) THEN
   i1_l = LBOUND(SrcParamData%D2_64,1)
   i1_u = UBOUND(SrcParamData%D2_64,1)
   i2_l = LBOUND(SrcParamData%D2_64,2)
   i2_u = UBOUND(SrcParamData%D2_64,2)
   IF (.NOT. ALLOCATED(DstParamData%D2_64)) THEN 
      ALLOCATE(DstParamData%D2_64(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D2_64.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D2_64 = SrcParamData%D2_64
ENDIF
IF (ALLOCATED(SrcParamData%F2_61)) THEN
   i1_l = LBOUND(SrcParamData%F2_61,1)
   i1_u = UBOUND(SrcParamData%F2_61,1)
   IF (.NOT. ALLOCATED(DstParamData%F2_61)) THEN 
      ALLOCATE(DstParamData%F2_61(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%F2_61.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%F2_61 = SrcParamData%F2_61
ENDIF
IF (ALLOCATED(SrcParamData%MBB)) THEN
   i1_l = LBOUND(SrcParamData%MBB,1)
   i1_u = UBOUND(SrcParamData%MBB,1)
   i2_l = LBOUND(SrcParamData%MBB,2)
   i2_u = UBOUND(SrcParamData%MBB,2)
   IF (.NOT. ALLOCATED(DstParamData%MBB)) THEN 
      ALLOCATE(DstParamData%MBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MBB.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%MBB = SrcParamData%MBB
ENDIF
IF (ALLOCATED(SrcParamData%KBB)) THEN
   i1_l = LBOUND(SrcParamData%KBB,1)
   i1_u = UBOUND(SrcParamData%KBB,1)
   i2_l = LBOUND(SrcParamData%KBB,2)
   i2_u = UBOUND(SrcParamData%KBB,2)
   IF (.NOT. ALLOCATED(DstParamData%KBB)) THEN 
      ALLOCATE(DstParamData%KBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%KBB.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%KBB = SrcParamData%KBB
ENDIF
IF (ALLOCATED(SrcParamData%MBM)) THEN
   i1_l = LBOUND(SrcParamData%MBM,1)
   i1_u = UBOUND(SrcParamData%MBM,1)
   i2_l = LBOUND(SrcParamData%MBM,2)
   i2_u = UBOUND(SrcParamData%MBM,2)
   IF (.NOT. ALLOCATED(DstParamData%MBM)) THEN 
      ALLOCATE(DstParamData%MBM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MBM.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%MBM = SrcParamData%MBM
ENDIF
IF (ALLOCATED(SrcParamData%PhiL_T)) THEN
   i1_l = LBOUND(SrcParamData%PhiL_T,1)
   i1_u = UBOUND(SrcParamData%PhiL_T,1)
   i2_l = LBOUND(SrcParamData%PhiL_T,2)
   i2_u = UBOUND(SrcParamData%PhiL_T,2)
   IF (.NOT. ALLOCATED(DstParamData%PhiL_T)) THEN 
      ALLOCATE(DstParamData%PhiL_T(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiL_T.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%PhiL_T = SrcParamData%PhiL_T
ENDIF
IF (ALLOCATED(SrcParamData%PhiLInvOmgL2)) THEN
   i1_l = LBOUND(SrcParamData%PhiLInvOmgL2,1)
   i1_u = UBOUND(SrcParamData%PhiLInvOmgL2,1)
   i2_l = LBOUND(SrcParamData%PhiLInvOmgL2,2)
   i2_u = UBOUND(SrcParamData%PhiLInvOmgL2,2)
   IF (.NOT. ALLOCATED(DstParamData%PhiLInvOmgL2)) THEN 
      ALLOCATE(DstParamData%PhiLInvOmgL2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiLInvOmgL2.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%PhiLInvOmgL2 = SrcParamData%PhiLInvOmgL2
ENDIF
IF (ALLOCATED(SrcParamData%FGL)) THEN
   i1_l = LBOUND(SrcParamData%FGL,1)
   i1_u = UBOUND(SrcParamData%FGL,1)
   IF (.NOT. ALLOCATED(DstParamData%FGL)) THEN 
      ALLOCATE(DstParamData%FGL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FGL.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%FGL = SrcParamData%FGL
ENDIF
IF (ALLOCATED(SrcParamData%AM2Jac)) THEN
   i1_l = LBOUND(SrcParamData%AM2Jac,1)
   i1_u = UBOUND(SrcParamData%AM2Jac,1)
   i2_l = LBOUND(SrcParamData%AM2Jac,2)
   i2_u = UBOUND(SrcParamData%AM2Jac,2)
   IF (.NOT. ALLOCATED(DstParamData%AM2Jac)) THEN 
      ALLOCATE(DstParamData%AM2Jac(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AM2Jac.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%AM2Jac = SrcParamData%AM2Jac
ENDIF
IF (ALLOCATED(SrcParamData%AM2JacPiv)) THEN
   i1_l = LBOUND(SrcParamData%AM2JacPiv,1)
   i1_u = UBOUND(SrcParamData%AM2JacPiv,1)
   IF (.NOT. ALLOCATED(DstParamData%AM2JacPiv)) THEN 
      ALLOCATE(DstParamData%AM2JacPiv(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AM2JacPiv.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%AM2JacPiv = SrcParamData%AM2JacPiv
ENDIF
IF (ALLOCATED(SrcParamData%TI)) THEN
   i1_l = LBOUND(SrcParamData%TI,1)
   i1_u = UBOUND(SrcParamData%TI,1)
   i2_l = LBOUND(SrcParamData%TI,2)
   i2_u = UBOUND(SrcParamData%TI,2)
   IF (.NOT. ALLOCATED(DstParamData%TI)) THEN 
      ALLOCATE(DstParamData%TI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TI.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%TI = SrcParamData%TI
ENDIF
IF (ALLOCATED(SrcParamData%TIreact)) THEN
   i1_l = LBOUND(SrcParamData%TIreact,1)
   i1_u = UBOUND(SrcParamData%TIreact,1)
   i2_l = LBOUND(SrcParamData%TIreact,2)
   i2_u = UBOUND(SrcParamData%TIreact,2)
   IF (.NOT. ALLOCATED(DstParamData%TIreact)) THEN 
      ALLOCATE(DstParamData%TIreact(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TIreact.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%TIreact = SrcParamData%TIreact
ENDIF
   DstParamData%NModes = SrcParamData%NModes
IF (ALLOCATED(SrcParamData%Elems)) THEN
   i1_l = LBOUND(SrcParamData%Elems,1)
   i1_u = UBOUND(SrcParamData%Elems,1)
   i2_l = LBOUND(SrcParamData%Elems,2)
   i2_u = UBOUND(SrcParamData%Elems,2)
   IF (.NOT. ALLOCATED(DstParamData%Elems)) THEN 
      ALLOCATE(DstParamData%Elems(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Elems.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%Elems = SrcParamData%Elems
ENDIF
   DstParamData%qmL = SrcParamData%qmL
   DstParamData%DofL = SrcParamData%DofL
   DstParamData%NNodes_I = SrcParamData%NNodes_I
   DstParamData%NNodes_L = SrcParamData%NNodes_L
   DstParamData%NNodes_RbarL = SrcParamData%NNodes_RbarL
   DstParamData%DofI = SrcParamData%DofI
   DstParamData%DofR = SrcParamData%DofR
   DstParamData%DofC = SrcParamData%DofC
   DstParamData%NReact = SrcParamData%NReact
IF (ALLOCATED(SrcParamData%Reacts)) THEN
   i1_l = LBOUND(SrcParamData%Reacts,1)
   i1_u = UBOUND(SrcParamData%Reacts,1)
   i2_l = LBOUND(SrcParamData%Reacts,2)
   i2_u = UBOUND(SrcParamData%Reacts,2)
   IF (.NOT. ALLOCATED(DstParamData%Reacts)) THEN 
      ALLOCATE(DstParamData%Reacts(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Reacts.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%Reacts = SrcParamData%Reacts
ENDIF
   DstParamData%Nmembers = SrcParamData%Nmembers
   DstParamData%URbarL = SrcParamData%URbarL
   DstParamData%IntMethod = SrcParamData%IntMethod
   DstParamData%NAvgEls = SrcParamData%NAvgEls
IF (ALLOCATED(SrcParamData%IDI)) THEN
   i1_l = LBOUND(SrcParamData%IDI,1)
   i1_u = UBOUND(SrcParamData%IDI,1)
   IF (.NOT. ALLOCATED(DstParamData%IDI)) THEN 
      ALLOCATE(DstParamData%IDI(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDI.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDI = SrcParamData%IDI
ENDIF
IF (ALLOCATED(SrcParamData%IDR)) THEN
   i1_l = LBOUND(SrcParamData%IDR,1)
   i1_u = UBOUND(SrcParamData%IDR,1)
   IF (.NOT. ALLOCATED(DstParamData%IDR)) THEN 
      ALLOCATE(DstParamData%IDR(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDR.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDR = SrcParamData%IDR
ENDIF
IF (ALLOCATED(SrcParamData%IDL)) THEN
   i1_l = LBOUND(SrcParamData%IDL,1)
   i1_u = UBOUND(SrcParamData%IDL,1)
   IF (.NOT. ALLOCATED(DstParamData%IDL)) THEN 
      ALLOCATE(DstParamData%IDL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDL.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDL = SrcParamData%IDL
ENDIF
IF (ALLOCATED(SrcParamData%IDC)) THEN
   i1_l = LBOUND(SrcParamData%IDC,1)
   i1_u = UBOUND(SrcParamData%IDC,1)
   IF (.NOT. ALLOCATED(DstParamData%IDC)) THEN 
      ALLOCATE(DstParamData%IDC(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDC.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDC = SrcParamData%IDC
ENDIF
IF (ALLOCATED(SrcParamData%IDY)) THEN
   i1_l = LBOUND(SrcParamData%IDY,1)
   i1_u = UBOUND(SrcParamData%IDY,1)
   IF (.NOT. ALLOCATED(DstParamData%IDY)) THEN 
      ALLOCATE(DstParamData%IDY(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDY.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDY = SrcParamData%IDY
ENDIF
   DstParamData%NMOutputs = SrcParamData%NMOutputs
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%OutSwtch = SrcParamData%OutSwtch
   DstParamData%UnJckF = SrcParamData%UnJckF
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%OutFmt = SrcParamData%OutFmt
   DstParamData%OutSFmt = SrcParamData%OutSFmt
IF (ALLOCATED(SrcParamData%MoutLst)) THEN
   i1_l = LBOUND(SrcParamData%MoutLst,1)
   i1_u = UBOUND(SrcParamData%MoutLst,1)
   IF (.NOT. ALLOCATED(DstParamData%MoutLst)) THEN 
      ALLOCATE(DstParamData%MoutLst(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MoutLst.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MoutLst,1), UBOUND(SrcParamData%MoutLst,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst(i1), DstParamData%MoutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:MoutLst(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%MoutLst2)) THEN
   i1_l = LBOUND(SrcParamData%MoutLst2,1)
   i1_u = UBOUND(SrcParamData%MoutLst2,1)
   IF (.NOT. ALLOCATED(DstParamData%MoutLst2)) THEN 
      ALLOCATE(DstParamData%MoutLst2(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MoutLst2.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MoutLst2,1), UBOUND(SrcParamData%MoutLst2,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst2(i1), DstParamData%MoutLst2(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:MoutLst2(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%MoutLst3)) THEN
   i1_l = LBOUND(SrcParamData%MoutLst3,1)
   i1_u = UBOUND(SrcParamData%MoutLst3,1)
   IF (.NOT. ALLOCATED(DstParamData%MoutLst3)) THEN 
      ALLOCATE(DstParamData%MoutLst3(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MoutLst3.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MoutLst3,1), UBOUND(SrcParamData%MoutLst3,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst3(i1), DstParamData%MoutLst3(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:MoutLst3(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%ElemProps)) THEN
   i1_l = LBOUND(SrcParamData%ElemProps,1)
   i1_u = UBOUND(SrcParamData%ElemProps,1)
   IF (.NOT. ALLOCATED(DstParamData%ElemProps)) THEN 
      ALLOCATE(DstParamData%ElemProps(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ElemProps.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%ElemProps,1), UBOUND(SrcParamData%ElemProps,1)
      CALL SD_Copyelemproptype( SrcParamData%ElemProps(i1), DstParamData%ElemProps(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:ElemProps(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:OutParam(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstParamData%OutAll = SrcParamData%OutAll
   DstParamData%OutReact = SrcParamData%OutReact
   DstParamData%OutAllInt = SrcParamData%OutAllInt
   DstParamData%OutAllDims = SrcParamData%OutAllDims
   DstParamData%OutDec = SrcParamData%OutDec
 END SUBROUTINE SD_CopyParam

 SUBROUTINE SD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%NOmegaM2)) THEN
   DEALLOCATE(ParamData%NOmegaM2)
ENDIF
IF (ALLOCATED(ParamData%N2OmegaMJDamp)) THEN
   DEALLOCATE(ParamData%N2OmegaMJDamp)
ENDIF
IF (ALLOCATED(ParamData%MMB)) THEN
   DEALLOCATE(ParamData%MMB)
ENDIF
IF (ALLOCATED(ParamData%FX)) THEN
   DEALLOCATE(ParamData%FX)
ENDIF
IF (ALLOCATED(ParamData%C1_11)) THEN
   DEALLOCATE(ParamData%C1_11)
ENDIF
IF (ALLOCATED(ParamData%C1_12)) THEN
   DEALLOCATE(ParamData%C1_12)
ENDIF
IF (ALLOCATED(ParamData%D1_13)) THEN
   DEALLOCATE(ParamData%D1_13)
ENDIF
IF (ALLOCATED(ParamData%D1_14)) THEN
   DEALLOCATE(ParamData%D1_14)
ENDIF
IF (ALLOCATED(ParamData%FY)) THEN
   DEALLOCATE(ParamData%FY)
ENDIF
IF (ALLOCATED(ParamData%PhiM)) THEN
   DEALLOCATE(ParamData%PhiM)
ENDIF
IF (ALLOCATED(ParamData%C2_61)) THEN
   DEALLOCATE(ParamData%C2_61)
ENDIF
IF (ALLOCATED(ParamData%C2_62)) THEN
   DEALLOCATE(ParamData%C2_62)
ENDIF
IF (ALLOCATED(ParamData%PhiRb_TI)) THEN
   DEALLOCATE(ParamData%PhiRb_TI)
ENDIF
IF (ALLOCATED(ParamData%D2_63)) THEN
   DEALLOCATE(ParamData%D2_63)
ENDIF
IF (ALLOCATED(ParamData%D2_64)) THEN
   DEALLOCATE(ParamData%D2_64)
ENDIF
IF (ALLOCATED(ParamData%F2_61)) THEN
   DEALLOCATE(ParamData%F2_61)
ENDIF
IF (ALLOCATED(ParamData%MBB)) THEN
   DEALLOCATE(ParamData%MBB)
ENDIF
IF (ALLOCATED(ParamData%KBB)) THEN
   DEALLOCATE(ParamData%KBB)
ENDIF
IF (ALLOCATED(ParamData%MBM)) THEN
   DEALLOCATE(ParamData%MBM)
ENDIF
IF (ALLOCATED(ParamData%PhiL_T)) THEN
   DEALLOCATE(ParamData%PhiL_T)
ENDIF
IF (ALLOCATED(ParamData%PhiLInvOmgL2)) THEN
   DEALLOCATE(ParamData%PhiLInvOmgL2)
ENDIF
IF (ALLOCATED(ParamData%FGL)) THEN
   DEALLOCATE(ParamData%FGL)
ENDIF
IF (ALLOCATED(ParamData%AM2Jac)) THEN
   DEALLOCATE(ParamData%AM2Jac)
ENDIF
IF (ALLOCATED(ParamData%AM2JacPiv)) THEN
   DEALLOCATE(ParamData%AM2JacPiv)
ENDIF
IF (ALLOCATED(ParamData%TI)) THEN
   DEALLOCATE(ParamData%TI)
ENDIF
IF (ALLOCATED(ParamData%TIreact)) THEN
   DEALLOCATE(ParamData%TIreact)
ENDIF
IF (ALLOCATED(ParamData%Elems)) THEN
   DEALLOCATE(ParamData%Elems)
ENDIF
IF (ALLOCATED(ParamData%Reacts)) THEN
   DEALLOCATE(ParamData%Reacts)
ENDIF
IF (ALLOCATED(ParamData%IDI)) THEN
   DEALLOCATE(ParamData%IDI)
ENDIF
IF (ALLOCATED(ParamData%IDR)) THEN
   DEALLOCATE(ParamData%IDR)
ENDIF
IF (ALLOCATED(ParamData%IDL)) THEN
   DEALLOCATE(ParamData%IDL)
ENDIF
IF (ALLOCATED(ParamData%IDC)) THEN
   DEALLOCATE(ParamData%IDC)
ENDIF
IF (ALLOCATED(ParamData%IDY)) THEN
   DEALLOCATE(ParamData%IDY)
ENDIF
IF (ALLOCATED(ParamData%MoutLst)) THEN
DO i1 = LBOUND(ParamData%MoutLst,1), UBOUND(ParamData%MoutLst,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MoutLst)
ENDIF
IF (ALLOCATED(ParamData%MoutLst2)) THEN
DO i1 = LBOUND(ParamData%MoutLst2,1), UBOUND(ParamData%MoutLst2,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst2(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MoutLst2)
ENDIF
IF (ALLOCATED(ParamData%MoutLst3)) THEN
DO i1 = LBOUND(ParamData%MoutLst3,1), UBOUND(ParamData%MoutLst3,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst3(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MoutLst3)
ENDIF
IF (ALLOCATED(ParamData%ElemProps)) THEN
DO i1 = LBOUND(ParamData%ElemProps,1), UBOUND(ParamData%ElemProps,1)
  CALL SD_Destroyelemproptype( ParamData%ElemProps(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%ElemProps)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE SD_DestroyParam

 SUBROUTINE SD_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst2_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst2_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst2_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst3_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst3_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst3_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_ElemProps_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_ElemProps_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_ElemProps_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! SDDeltaT
  Int_BufSz  = Int_BufSz  + 1  ! SttcSolve
  IF ( ALLOCATED(InData%NOmegaM2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%NOmegaM2 )  ! NOmegaM2 
  IF ( ALLOCATED(InData%N2OmegaMJDamp) )   Re_BufSz    = Re_BufSz    + SIZE( InData%N2OmegaMJDamp )  ! N2OmegaMJDamp 
  IF ( ALLOCATED(InData%MMB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MMB )  ! MMB 
  IF ( ALLOCATED(InData%FX) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FX )  ! FX 
  IF ( ALLOCATED(InData%C1_11) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C1_11 )  ! C1_11 
  IF ( ALLOCATED(InData%C1_12) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C1_12 )  ! C1_12 
  IF ( ALLOCATED(InData%D1_13) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D1_13 )  ! D1_13 
  IF ( ALLOCATED(InData%D1_14) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D1_14 )  ! D1_14 
  IF ( ALLOCATED(InData%FY) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FY )  ! FY 
  IF ( ALLOCATED(InData%PhiM) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiM )  ! PhiM 
  IF ( ALLOCATED(InData%C2_61) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C2_61 )  ! C2_61 
  IF ( ALLOCATED(InData%C2_62) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C2_62 )  ! C2_62 
  IF ( ALLOCATED(InData%PhiRb_TI) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiRb_TI )  ! PhiRb_TI 
  IF ( ALLOCATED(InData%D2_63) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D2_63 )  ! D2_63 
  IF ( ALLOCATED(InData%D2_64) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D2_64 )  ! D2_64 
  IF ( ALLOCATED(InData%F2_61) )   Re_BufSz    = Re_BufSz    + SIZE( InData%F2_61 )  ! F2_61 
  IF ( ALLOCATED(InData%MBB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MBB )  ! MBB 
  IF ( ALLOCATED(InData%KBB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%KBB )  ! KBB 
  IF ( ALLOCATED(InData%MBM) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MBM )  ! MBM 
  IF ( ALLOCATED(InData%PhiL_T) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiL_T )  ! PhiL_T 
  IF ( ALLOCATED(InData%PhiLInvOmgL2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiLInvOmgL2 )  ! PhiLInvOmgL2 
  IF ( ALLOCATED(InData%FGL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FGL )  ! FGL 
  IF ( ALLOCATED(InData%AM2Jac) )   Re_BufSz    = Re_BufSz    + SIZE( InData%AM2Jac )  ! AM2Jac 
  IF ( ALLOCATED(InData%AM2JacPiv) )   Int_BufSz   = Int_BufSz   + SIZE( InData%AM2JacPiv )  ! AM2JacPiv 
  IF ( ALLOCATED(InData%TI) )   Re_BufSz    = Re_BufSz    + SIZE( InData%TI )  ! TI 
  IF ( ALLOCATED(InData%TIreact) )   Re_BufSz    = Re_BufSz    + SIZE( InData%TIreact )  ! TIreact 
  Int_BufSz  = Int_BufSz  + 1  ! NModes
  IF ( ALLOCATED(InData%Elems) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Elems )  ! Elems 
  Int_BufSz  = Int_BufSz  + 1  ! qmL
  Int_BufSz  = Int_BufSz  + 1  ! DofL
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_I
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_L
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_RbarL
  Int_BufSz  = Int_BufSz  + 1  ! DofI
  Int_BufSz  = Int_BufSz  + 1  ! DofR
  Int_BufSz  = Int_BufSz  + 1  ! DofC
  Int_BufSz  = Int_BufSz  + 1  ! NReact
  IF ( ALLOCATED(InData%Reacts) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Reacts )  ! Reacts 
  Int_BufSz  = Int_BufSz  + 1  ! Nmembers
  Int_BufSz  = Int_BufSz  + 1  ! URbarL
  Int_BufSz  = Int_BufSz  + 1  ! IntMethod
  Int_BufSz  = Int_BufSz  + 1  ! NAvgEls
  IF ( ALLOCATED(InData%IDI) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDI )  ! IDI 
  IF ( ALLOCATED(InData%IDR) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDR )  ! IDR 
  IF ( ALLOCATED(InData%IDL) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDL )  ! IDL 
  IF ( ALLOCATED(InData%IDC) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDC )  ! IDC 
  IF ( ALLOCATED(InData%IDY) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDY )  ! IDY 
  Int_BufSz  = Int_BufSz  + 1  ! NMOutputs
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
  Int_BufSz  = Int_BufSz  + 1  ! UnJckF
!  missing buffer for Delim
!  missing buffer for OutFmt
!  missing buffer for OutSFmt
DO i1 = LBOUND(InData%MoutLst,1), UBOUND(InData%MoutLst,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, InData%MoutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst_Buf  ) ! MoutLst
  IF(ALLOCATED(Db_MoutLst_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst_Buf  ) ! MoutLst
  IF(ALLOCATED(Int_MoutLst_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst_Buf ) ! MoutLst
  IF(ALLOCATED(Re_MoutLst_Buf))  DEALLOCATE(Re_MoutLst_Buf)
  IF(ALLOCATED(Db_MoutLst_Buf))  DEALLOCATE(Db_MoutLst_Buf)
  IF(ALLOCATED(Int_MoutLst_Buf)) DEALLOCATE(Int_MoutLst_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst2,1), UBOUND(InData%MoutLst2,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, InData%MoutLst2(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst2_Buf  ) ! MoutLst2
  IF(ALLOCATED(Db_MoutLst2_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst2_Buf  ) ! MoutLst2
  IF(ALLOCATED(Int_MoutLst2_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst2_Buf ) ! MoutLst2
  IF(ALLOCATED(Re_MoutLst2_Buf))  DEALLOCATE(Re_MoutLst2_Buf)
  IF(ALLOCATED(Db_MoutLst2_Buf))  DEALLOCATE(Db_MoutLst2_Buf)
  IF(ALLOCATED(Int_MoutLst2_Buf)) DEALLOCATE(Int_MoutLst2_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst3,1), UBOUND(InData%MoutLst3,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, InData%MoutLst3(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst3_Buf  ) ! MoutLst3
  IF(ALLOCATED(Db_MoutLst3_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst3_Buf  ) ! MoutLst3
  IF(ALLOCATED(Int_MoutLst3_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst3_Buf ) ! MoutLst3
  IF(ALLOCATED(Re_MoutLst3_Buf))  DEALLOCATE(Re_MoutLst3_Buf)
  IF(ALLOCATED(Db_MoutLst3_Buf))  DEALLOCATE(Db_MoutLst3_Buf)
  IF(ALLOCATED(Int_MoutLst3_Buf)) DEALLOCATE(Int_MoutLst3_Buf)
ENDDO
DO i1 = LBOUND(InData%ElemProps,1), UBOUND(InData%ElemProps,1)
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, InData%ElemProps(i1), ErrStat, ErrMsg, .TRUE. ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_ElemProps_Buf  ) ! ElemProps
  IF(ALLOCATED(Db_ElemProps_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_ElemProps_Buf  ) ! ElemProps
  IF(ALLOCATED(Int_ElemProps_Buf))Int_BufSz = Int_BufSz + SIZE( Int_ElemProps_Buf ) ! ElemProps
  IF(ALLOCATED(Re_ElemProps_Buf))  DEALLOCATE(Re_ElemProps_Buf)
  IF(ALLOCATED(Db_ElemProps_Buf))  DEALLOCATE(Db_ElemProps_Buf)
  IF(ALLOCATED(Int_ElemProps_Buf)) DEALLOCATE(Int_ElemProps_Buf)
ENDDO
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! OutAll
  Int_BufSz  = Int_BufSz  + 1  ! OutReact
  Int_BufSz  = Int_BufSz  + 1  ! OutAllInt
  Int_BufSz  = Int_BufSz  + 1  ! OutAllDims
  Int_BufSz  = Int_BufSz  + 1  ! OutDec
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%SDDeltaT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%SttcSolve ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NOmegaM2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%NOmegaM2))-1 ) =  PACK(InData%NOmegaM2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%NOmegaM2)
  ENDIF
  IF ( ALLOCATED(InData%N2OmegaMJDamp) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%N2OmegaMJDamp))-1 ) =  PACK(InData%N2OmegaMJDamp ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%N2OmegaMJDamp)
  ENDIF
  IF ( ALLOCATED(InData%MMB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MMB))-1 ) =  PACK(InData%MMB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MMB)
  ENDIF
  IF ( ALLOCATED(InData%FX) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FX))-1 ) =  PACK(InData%FX ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FX)
  ENDIF
  IF ( ALLOCATED(InData%C1_11) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C1_11))-1 ) =  PACK(InData%C1_11 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C1_11)
  ENDIF
  IF ( ALLOCATED(InData%C1_12) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C1_12))-1 ) =  PACK(InData%C1_12 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C1_12)
  ENDIF
  IF ( ALLOCATED(InData%D1_13) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_13))-1 ) =  PACK(InData%D1_13 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_13)
  ENDIF
  IF ( ALLOCATED(InData%D1_14) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_14))-1 ) =  PACK(InData%D1_14 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_14)
  ENDIF
  IF ( ALLOCATED(InData%FY) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FY))-1 ) =  PACK(InData%FY ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FY)
  ENDIF
  IF ( ALLOCATED(InData%PhiM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiM))-1 ) =  PACK(InData%PhiM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiM)
  ENDIF
  IF ( ALLOCATED(InData%C2_61) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C2_61))-1 ) =  PACK(InData%C2_61 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C2_61)
  ENDIF
  IF ( ALLOCATED(InData%C2_62) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C2_62))-1 ) =  PACK(InData%C2_62 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C2_62)
  ENDIF
  IF ( ALLOCATED(InData%PhiRb_TI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiRb_TI))-1 ) =  PACK(InData%PhiRb_TI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiRb_TI)
  ENDIF
  IF ( ALLOCATED(InData%D2_63) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_63))-1 ) =  PACK(InData%D2_63 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_63)
  ENDIF
  IF ( ALLOCATED(InData%D2_64) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_64))-1 ) =  PACK(InData%D2_64 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_64)
  ENDIF
  IF ( ALLOCATED(InData%F2_61) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F2_61))-1 ) =  PACK(InData%F2_61 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F2_61)
  ENDIF
  IF ( ALLOCATED(InData%MBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBB))-1 ) =  PACK(InData%MBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBB)
  ENDIF
  IF ( ALLOCATED(InData%KBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%KBB))-1 ) =  PACK(InData%KBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%KBB)
  ENDIF
  IF ( ALLOCATED(InData%MBM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBM))-1 ) =  PACK(InData%MBM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBM)
  ENDIF
  IF ( ALLOCATED(InData%PhiL_T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiL_T))-1 ) =  PACK(InData%PhiL_T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiL_T)
  ENDIF
  IF ( ALLOCATED(InData%PhiLInvOmgL2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiLInvOmgL2))-1 ) =  PACK(InData%PhiLInvOmgL2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiLInvOmgL2)
  ENDIF
  IF ( ALLOCATED(InData%FGL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FGL))-1 ) =  PACK(InData%FGL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FGL)
  ENDIF
  IF ( ALLOCATED(InData%AM2Jac) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AM2Jac))-1 ) =  PACK(InData%AM2Jac ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%AM2Jac)
  ENDIF
  IF ( ALLOCATED(InData%AM2JacPiv) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AM2JacPiv))-1 ) = PACK(InData%AM2JacPiv ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AM2JacPiv)
  ENDIF
  IF ( ALLOCATED(InData%TI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TI))-1 ) =  PACK(InData%TI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TI)
  ENDIF
  IF ( ALLOCATED(InData%TIreact) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TIreact))-1 ) =  PACK(InData%TIreact ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TIreact)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NModes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Elems) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Elems))-1 ) = PACK(InData%Elems ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Elems)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%qmL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_I )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_L )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_RbarL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofI )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofR )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofC )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NReact )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Reacts) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Reacts))-1 ) = PACK(InData%Reacts ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Reacts)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Nmembers )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%URbarL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IntMethod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NAvgEls )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%IDI) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDI))-1 ) = PACK(InData%IDI ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDI)
  ENDIF
  IF ( ALLOCATED(InData%IDR) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDR))-1 ) = PACK(InData%IDR ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDR)
  ENDIF
  IF ( ALLOCATED(InData%IDL) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDL))-1 ) = PACK(InData%IDL ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDL)
  ENDIF
  IF ( ALLOCATED(InData%IDC) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDC))-1 ) = PACK(InData%IDC ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDC)
  ENDIF
  IF ( ALLOCATED(InData%IDY) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDY))-1 ) = PACK(InData%IDY ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDY)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NMOutputs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutSwtch )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnJckF )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%MoutLst,1), UBOUND(InData%MoutLst,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, InData%MoutLst(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst_Buf)-1 ) = Re_MoutLst_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst_Buf)-1 ) = Db_MoutLst_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst_Buf)-1 ) = Int_MoutLst_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst_Buf) )  DEALLOCATE(Re_MoutLst_Buf)
  IF( ALLOCATED(Db_MoutLst_Buf) )  DEALLOCATE(Db_MoutLst_Buf)
  IF( ALLOCATED(Int_MoutLst_Buf) ) DEALLOCATE(Int_MoutLst_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst2,1), UBOUND(InData%MoutLst2,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, InData%MoutLst2(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst2_Buf)-1 ) = Re_MoutLst2_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst2_Buf)-1 ) = Db_MoutLst2_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst2_Buf)-1 ) = Int_MoutLst2_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst2_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst2_Buf) )  DEALLOCATE(Re_MoutLst2_Buf)
  IF( ALLOCATED(Db_MoutLst2_Buf) )  DEALLOCATE(Db_MoutLst2_Buf)
  IF( ALLOCATED(Int_MoutLst2_Buf) ) DEALLOCATE(Int_MoutLst2_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst3,1), UBOUND(InData%MoutLst3,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, InData%MoutLst3(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst3_Buf)-1 ) = Re_MoutLst3_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst3_Buf)-1 ) = Db_MoutLst3_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst3_Buf)-1 ) = Int_MoutLst3_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst3_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst3_Buf) )  DEALLOCATE(Re_MoutLst3_Buf)
  IF( ALLOCATED(Db_MoutLst3_Buf) )  DEALLOCATE(Db_MoutLst3_Buf)
  IF( ALLOCATED(Int_MoutLst3_Buf) ) DEALLOCATE(Int_MoutLst3_Buf)
ENDDO
DO i1 = LBOUND(InData%ElemProps,1), UBOUND(InData%ElemProps,1)
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, InData%ElemProps(i1), ErrStat, ErrMsg, OnlySize ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ElemProps_Buf)-1 ) = Re_ElemProps_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Db_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ElemProps_Buf)-1 ) = Db_ElemProps_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Int_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ElemProps_Buf)-1 ) = Int_ElemProps_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_ElemProps_Buf)
  ENDIF
  IF( ALLOCATED(Re_ElemProps_Buf) )  DEALLOCATE(Re_ElemProps_Buf)
  IF( ALLOCATED(Db_ElemProps_Buf) )  DEALLOCATE(Db_ElemProps_Buf)
  IF( ALLOCATED(Int_ElemProps_Buf) ) DEALLOCATE(Int_ElemProps_Buf)
ENDDO
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%OutAll ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%OutReact ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutAllInt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutAllDims )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutDec )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_PackParam

 SUBROUTINE SD_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst2_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst2_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst2_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst3_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst3_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst3_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_ElemProps_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_ElemProps_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_ElemProps_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%SDDeltaT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%NOmegaM2) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NOmegaM2,1)))
  mask1 = .TRUE.
    OutData%NOmegaM2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%NOmegaM2))-1 ),mask1,OutData%NOmegaM2)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%NOmegaM2)
  ENDIF
  IF ( ALLOCATED(OutData%N2OmegaMJDamp) ) THEN
  ALLOCATE(mask1(SIZE(OutData%N2OmegaMJDamp,1)))
  mask1 = .TRUE.
    OutData%N2OmegaMJDamp = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%N2OmegaMJDamp))-1 ),mask1,OutData%N2OmegaMJDamp)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%N2OmegaMJDamp)
  ENDIF
  IF ( ALLOCATED(OutData%MMB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MMB,1),SIZE(OutData%MMB,2)))
  mask2 = .TRUE.
    OutData%MMB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MMB))-1 ),mask2,OutData%MMB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MMB)
  ENDIF
  IF ( ALLOCATED(OutData%FX) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FX,1)))
  mask1 = .TRUE.
    OutData%FX = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FX))-1 ),mask1,OutData%FX)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FX)
  ENDIF
  IF ( ALLOCATED(OutData%C1_11) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C1_11,1),SIZE(OutData%C1_11,2)))
  mask2 = .TRUE.
    OutData%C1_11 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C1_11))-1 ),mask2,OutData%C1_11)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C1_11)
  ENDIF
  IF ( ALLOCATED(OutData%C1_12) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C1_12,1),SIZE(OutData%C1_12,2)))
  mask2 = .TRUE.
    OutData%C1_12 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C1_12))-1 ),mask2,OutData%C1_12)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C1_12)
  ENDIF
  IF ( ALLOCATED(OutData%D1_13) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_13,1),SIZE(OutData%D1_13,2)))
  mask2 = .TRUE.
    OutData%D1_13 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_13))-1 ),mask2,OutData%D1_13)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_13)
  ENDIF
  IF ( ALLOCATED(OutData%D1_14) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_14,1),SIZE(OutData%D1_14,2)))
  mask2 = .TRUE.
    OutData%D1_14 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_14))-1 ),mask2,OutData%D1_14)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_14)
  ENDIF
  IF ( ALLOCATED(OutData%FY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FY,1)))
  mask1 = .TRUE.
    OutData%FY = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FY))-1 ),mask1,OutData%FY)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FY)
  ENDIF
  IF ( ALLOCATED(OutData%PhiM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiM,1),SIZE(OutData%PhiM,2)))
  mask2 = .TRUE.
    OutData%PhiM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiM))-1 ),mask2,OutData%PhiM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiM)
  ENDIF
  IF ( ALLOCATED(OutData%C2_61) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C2_61,1),SIZE(OutData%C2_61,2)))
  mask2 = .TRUE.
    OutData%C2_61 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C2_61))-1 ),mask2,OutData%C2_61)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C2_61)
  ENDIF
  IF ( ALLOCATED(OutData%C2_62) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C2_62,1),SIZE(OutData%C2_62,2)))
  mask2 = .TRUE.
    OutData%C2_62 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C2_62))-1 ),mask2,OutData%C2_62)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C2_62)
  ENDIF
  IF ( ALLOCATED(OutData%PhiRb_TI) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiRb_TI,1),SIZE(OutData%PhiRb_TI,2)))
  mask2 = .TRUE.
    OutData%PhiRb_TI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiRb_TI))-1 ),mask2,OutData%PhiRb_TI)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiRb_TI)
  ENDIF
  IF ( ALLOCATED(OutData%D2_63) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_63,1),SIZE(OutData%D2_63,2)))
  mask2 = .TRUE.
    OutData%D2_63 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_63))-1 ),mask2,OutData%D2_63)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_63)
  ENDIF
  IF ( ALLOCATED(OutData%D2_64) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_64,1),SIZE(OutData%D2_64,2)))
  mask2 = .TRUE.
    OutData%D2_64 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_64))-1 ),mask2,OutData%D2_64)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_64)
  ENDIF
  IF ( ALLOCATED(OutData%F2_61) ) THEN
  ALLOCATE(mask1(SIZE(OutData%F2_61,1)))
  mask1 = .TRUE.
    OutData%F2_61 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F2_61))-1 ),mask1,OutData%F2_61)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F2_61)
  ENDIF
  IF ( ALLOCATED(OutData%MBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBB,1),SIZE(OutData%MBB,2)))
  mask2 = .TRUE.
    OutData%MBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBB))-1 ),mask2,OutData%MBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBB)
  ENDIF
  IF ( ALLOCATED(OutData%KBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%KBB,1),SIZE(OutData%KBB,2)))
  mask2 = .TRUE.
    OutData%KBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%KBB))-1 ),mask2,OutData%KBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%KBB)
  ENDIF
  IF ( ALLOCATED(OutData%MBM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBM,1),SIZE(OutData%MBM,2)))
  mask2 = .TRUE.
    OutData%MBM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBM))-1 ),mask2,OutData%MBM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBM)
  ENDIF
  IF ( ALLOCATED(OutData%PhiL_T) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiL_T,1),SIZE(OutData%PhiL_T,2)))
  mask2 = .TRUE.
    OutData%PhiL_T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiL_T))-1 ),mask2,OutData%PhiL_T)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiL_T)
  ENDIF
  IF ( ALLOCATED(OutData%PhiLInvOmgL2) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiLInvOmgL2,1),SIZE(OutData%PhiLInvOmgL2,2)))
  mask2 = .TRUE.
    OutData%PhiLInvOmgL2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiLInvOmgL2))-1 ),mask2,OutData%PhiLInvOmgL2)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiLInvOmgL2)
  ENDIF
  IF ( ALLOCATED(OutData%FGL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FGL,1)))
  mask1 = .TRUE.
    OutData%FGL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FGL))-1 ),mask1,OutData%FGL)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FGL)
  ENDIF
  IF ( ALLOCATED(OutData%AM2Jac) ) THEN
  ALLOCATE(mask2(SIZE(OutData%AM2Jac,1),SIZE(OutData%AM2Jac,2)))
  mask2 = .TRUE.
    OutData%AM2Jac = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AM2Jac))-1 ),mask2,OutData%AM2Jac)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%AM2Jac)
  ENDIF
  IF ( ALLOCATED(OutData%AM2JacPiv) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AM2JacPiv,1)))
  mask1 = .TRUE.
    OutData%AM2JacPiv = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AM2JacPiv))-1 ),mask1,OutData%AM2JacPiv)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AM2JacPiv)
  ENDIF
  IF ( ALLOCATED(OutData%TI) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TI,1),SIZE(OutData%TI,2)))
  mask2 = .TRUE.
    OutData%TI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TI))-1 ),mask2,OutData%TI)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TI)
  ENDIF
  IF ( ALLOCATED(OutData%TIreact) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TIreact,1),SIZE(OutData%TIreact,2)))
  mask2 = .TRUE.
    OutData%TIreact = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TIreact))-1 ),mask2,OutData%TIreact)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TIreact)
  ENDIF
  OutData%NModes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Elems) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Elems,1),SIZE(OutData%Elems,2)))
  mask2 = .TRUE.
    OutData%Elems = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Elems))-1 ),mask2,OutData%Elems)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Elems)
  ENDIF
  OutData%qmL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_I = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_L = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_RbarL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofI = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofR = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofC = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NReact = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Reacts) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Reacts,1),SIZE(OutData%Reacts,2)))
  mask2 = .TRUE.
    OutData%Reacts = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Reacts))-1 ),mask2,OutData%Reacts)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Reacts)
  ENDIF
  OutData%Nmembers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%URbarL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%IntMethod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NAvgEls = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%IDI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDI,1)))
  mask1 = .TRUE.
    OutData%IDI = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDI))-1 ),mask1,OutData%IDI)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDI)
  ENDIF
  IF ( ALLOCATED(OutData%IDR) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDR,1)))
  mask1 = .TRUE.
    OutData%IDR = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDR))-1 ),mask1,OutData%IDR)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDR)
  ENDIF
  IF ( ALLOCATED(OutData%IDL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDL,1)))
  mask1 = .TRUE.
    OutData%IDL = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDL))-1 ),mask1,OutData%IDL)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDL)
  ENDIF
  IF ( ALLOCATED(OutData%IDC) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDC,1)))
  mask1 = .TRUE.
    OutData%IDC = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDC))-1 ),mask1,OutData%IDC)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDC)
  ENDIF
  IF ( ALLOCATED(OutData%IDY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDY,1)))
  mask1 = .TRUE.
    OutData%IDY = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDY))-1 ),mask1,OutData%IDY)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDY)
  ENDIF
  OutData%NMOutputs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutSwtch = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnJckF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%MoutLst,1), UBOUND(OutData%MoutLst,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, OutData%MoutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) THEN
    Re_MoutLst_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst_Buf)) THEN
    Db_MoutLst_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst_Buf)) THEN
    Int_MoutLst_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst_Buf)
  ENDIF
  CALL SD_UnPackmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, OutData%MoutLst(i1), ErrStat, ErrMsg ) ! MoutLst 
ENDDO
DO i1 = LBOUND(OutData%MoutLst2,1), UBOUND(OutData%MoutLst2,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, OutData%MoutLst2(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) THEN
    Re_MoutLst2_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst2_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst2_Buf)) THEN
    Db_MoutLst2_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst2_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst2_Buf)) THEN
    Int_MoutLst2_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst2_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst2_Buf)
  ENDIF
  CALL SD_UnPackmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, OutData%MoutLst2(i1), ErrStat, ErrMsg ) ! MoutLst2 
ENDDO
DO i1 = LBOUND(OutData%MoutLst3,1), UBOUND(OutData%MoutLst3,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, OutData%MoutLst3(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) THEN
    Re_MoutLst3_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst3_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst3_Buf)) THEN
    Db_MoutLst3_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst3_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst3_Buf)) THEN
    Int_MoutLst3_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst3_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst3_Buf)
  ENDIF
  CALL SD_UnPackmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, OutData%MoutLst3(i1), ErrStat, ErrMsg ) ! MoutLst3 
ENDDO
DO i1 = LBOUND(OutData%ElemProps,1), UBOUND(OutData%ElemProps,1)
 ! first call SD_Packelemproptype to get correctly sized buffers for unpacking
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, OutData%ElemProps(i1), ErrStat, ErrMsg, .TRUE. ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) THEN
    Re_ElemProps_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ElemProps_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Db_ElemProps_Buf)) THEN
    Db_ElemProps_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ElemProps_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Int_ElemProps_Buf)) THEN
    Int_ElemProps_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ElemProps_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_ElemProps_Buf)
  ENDIF
  CALL SD_UnPackelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, OutData%ElemProps(i1), ErrStat, ErrMsg ) ! ElemProps 
ENDDO
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call NWTC_Library_Packoutparmtype to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL NWTC_Library_UnPackoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  OutData%OutAllInt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutAllDims = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutDec = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackParam

 SUBROUTINE SD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(SD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInputData%TPMesh, DstInputData%TPMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyInput:TPMesh')
         IF (ErrStat>=AbortErrLev) RETURN
     CALL MeshCopy( SrcInputData%LMesh, DstInputData%LMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyInput:LMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyInput

 SUBROUTINE SD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(SD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%TPMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%LMesh, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyInput

 SUBROUTINE SD_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_TPMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_TPMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_TPMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LMesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_TPMesh_Buf  ) ! TPMesh
  IF(ALLOCATED(Db_TPMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_TPMesh_Buf  ) ! TPMesh
  IF(ALLOCATED(Int_TPMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_TPMesh_Buf ) ! TPMesh
  IF(ALLOCATED(Re_TPMesh_Buf))  DEALLOCATE(Re_TPMesh_Buf)
  IF(ALLOCATED(Db_TPMesh_Buf))  DEALLOCATE(Db_TPMesh_Buf)
  IF(ALLOCATED(Int_TPMesh_Buf)) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( InData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LMesh_Buf  ) ! LMesh
  IF(ALLOCATED(Db_LMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LMesh_Buf  ) ! LMesh
  IF(ALLOCATED(Int_LMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LMesh_Buf ) ! LMesh
  IF(ALLOCATED(Re_LMesh_Buf))  DEALLOCATE(Re_LMesh_Buf)
  IF(ALLOCATED(Db_LMesh_Buf))  DEALLOCATE(Db_LMesh_Buf)
  IF(ALLOCATED(Int_LMesh_Buf)) DEALLOCATE(Int_LMesh_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_TPMesh_Buf)-1 ) = Re_TPMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_TPMesh_Buf)-1 ) = Db_TPMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_TPMesh_Buf)-1 ) = Int_TPMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_TPMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_TPMesh_Buf) )  DEALLOCATE(Re_TPMesh_Buf)
  IF( ALLOCATED(Db_TPMesh_Buf) )  DEALLOCATE(Db_TPMesh_Buf)
  IF( ALLOCATED(Int_TPMesh_Buf) ) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( InData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LMesh_Buf)-1 ) = Re_LMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LMesh_Buf)-1 ) = Db_LMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LMesh_Buf)-1 ) = Int_LMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_LMesh_Buf) )  DEALLOCATE(Re_LMesh_Buf)
  IF( ALLOCATED(Db_LMesh_Buf) )  DEALLOCATE(Db_LMesh_Buf)
  IF( ALLOCATED(Int_LMesh_Buf) ) DEALLOCATE(Int_LMesh_Buf)
 END SUBROUTINE SD_PackInput

 SUBROUTINE SD_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_TPMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_TPMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_TPMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LMesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) THEN
    Re_TPMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_TPMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_TPMesh_Buf)) THEN
    Db_TPMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_TPMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_TPMesh_Buf)) THEN
    Int_TPMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_TPMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_TPMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg ) ! TPMesh 
  IF( ALLOCATED(Re_TPMesh_Buf) )  DEALLOCATE(Re_TPMesh_Buf)
  IF( ALLOCATED(Db_TPMesh_Buf) )  DEALLOCATE(Db_TPMesh_Buf)
  IF( ALLOCATED(Int_TPMesh_Buf) ) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( OutData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) THEN
    Re_LMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LMesh_Buf)) THEN
    Db_LMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LMesh_Buf)) THEN
    Int_LMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg ) ! LMesh 
  IF( ALLOCATED(Re_LMesh_Buf) )  DEALLOCATE(Re_LMesh_Buf)
  IF( ALLOCATED(Db_LMesh_Buf) )  DEALLOCATE(Db_LMesh_Buf)
  IF( ALLOCATED(Int_LMesh_Buf) ) DEALLOCATE(Int_LMesh_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInput

 SUBROUTINE SD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(SD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcOutputData%Y1Mesh, DstOutputData%Y1Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyOutput:Y1Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
     CALL MeshCopy( SrcOutputData%Y2Mesh, DstOutputData%Y2Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyOutput:Y2Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'SD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE SD_CopyOutput

 SUBROUTINE SD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(SD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%Y1Mesh, ErrStat, ErrMsg )
  CALL MeshDestroy( OutputData%Y2Mesh, ErrStat, ErrMsg )
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE SD_DestroyOutput

 SUBROUTINE SD_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Y1Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Y1Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Y1Mesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_Y2Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Y2Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Y2Mesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Y1Mesh_Buf  ) ! Y1Mesh
  IF(ALLOCATED(Db_Y1Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Y1Mesh_Buf  ) ! Y1Mesh
  IF(ALLOCATED(Int_Y1Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Y1Mesh_Buf ) ! Y1Mesh
  IF(ALLOCATED(Re_Y1Mesh_Buf))  DEALLOCATE(Re_Y1Mesh_Buf)
  IF(ALLOCATED(Db_Y1Mesh_Buf))  DEALLOCATE(Db_Y1Mesh_Buf)
  IF(ALLOCATED(Int_Y1Mesh_Buf)) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( InData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Y2Mesh_Buf  ) ! Y2Mesh
  IF(ALLOCATED(Db_Y2Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Y2Mesh_Buf  ) ! Y2Mesh
  IF(ALLOCATED(Int_Y2Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Y2Mesh_Buf ) ! Y2Mesh
  IF(ALLOCATED(Re_Y2Mesh_Buf))  DEALLOCATE(Re_Y2Mesh_Buf)
  IF(ALLOCATED(Db_Y2Mesh_Buf))  DEALLOCATE(Db_Y2Mesh_Buf)
  IF(ALLOCATED(Int_Y2Mesh_Buf)) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y1Mesh_Buf)-1 ) = Re_Y1Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y1Mesh_Buf)-1 ) = Db_Y1Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y1Mesh_Buf)-1 ) = Int_Y1Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Y1Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Y1Mesh_Buf) )  DEALLOCATE(Re_Y1Mesh_Buf)
  IF( ALLOCATED(Db_Y1Mesh_Buf) )  DEALLOCATE(Db_Y1Mesh_Buf)
  IF( ALLOCATED(Int_Y1Mesh_Buf) ) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( InData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y2Mesh_Buf)-1 ) = Re_Y2Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y2Mesh_Buf)-1 ) = Db_Y2Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y2Mesh_Buf)-1 ) = Int_Y2Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Y2Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Y2Mesh_Buf) )  DEALLOCATE(Re_Y2Mesh_Buf)
  IF( ALLOCATED(Db_Y2Mesh_Buf) )  DEALLOCATE(Db_Y2Mesh_Buf)
  IF( ALLOCATED(Int_Y2Mesh_Buf) ) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE SD_PackOutput

 SUBROUTINE SD_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Y1Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Y1Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Y1Mesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_Y2Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Y2Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Y2Mesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) THEN
    Re_Y1Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y1Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y1Mesh_Buf)) THEN
    Db_Y1Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y1Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y1Mesh_Buf)) THEN
    Int_Y1Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y1Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Y1Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg ) ! Y1Mesh 
  IF( ALLOCATED(Re_Y1Mesh_Buf) )  DEALLOCATE(Re_Y1Mesh_Buf)
  IF( ALLOCATED(Db_Y1Mesh_Buf) )  DEALLOCATE(Db_Y1Mesh_Buf)
  IF( ALLOCATED(Int_Y1Mesh_Buf) ) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( OutData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) THEN
    Re_Y2Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y2Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y2Mesh_Buf)) THEN
    Db_Y2Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y2Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y2Mesh_Buf)) THEN
    Int_Y2Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y2Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Y2Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg ) ! Y2Mesh 
  IF( ALLOCATED(Re_Y2Mesh_Buf) )  DEALLOCATE(Re_Y2Mesh_Buf)
  IF( ALLOCATED(Db_Y2Mesh_Buf) )  DEALLOCATE(Db_Y2Mesh_Buf)
  IF( ALLOCATED(Int_Y2Mesh_Buf) ) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackOutput

 SUBROUTINE SD_CopydYdu( SrcdYduData, DstdYduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialOutputPInputType), INTENT(INOUT) :: SrcdYduData
   TYPE(SD_PartialOutputPInputType), INTENT(INOUT) :: DstdYduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdYduData%DummyOutput, DstdYduData%DummyOutput, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopydYdu:DummyOutput')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopydYdu

 SUBROUTINE SD_DestroydYdu( dYduData, ErrStat, ErrMsg )
  TYPE(SD_PartialOutputPInputType), INTENT(INOUT) :: dYduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dYduData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydYdu

 SUBROUTINE SD_PackdYdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialOutputPInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_PackdYdu

 SUBROUTINE SD_UnPackdYdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialOutputPInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdYdu

 SUBROUTINE SD_CopydXdu( SrcdXduData, DstdXduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialContStatePInputType), INTENT(INOUT) :: SrcdXduData
   TYPE(SD_PartialContStatePInputType), INTENT(INOUT) :: DstdXduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdXduData%DummyContState, DstdXduData%DummyContState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopydXdu:DummyContState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopydXdu

 SUBROUTINE SD_DestroydXdu( dXduData, ErrStat, ErrMsg )
  TYPE(SD_PartialContStatePInputType), INTENT(INOUT) :: dXduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dXduData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydXdu

 SUBROUTINE SD_PackdXdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialContStatePInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_PackdXdu

 SUBROUTINE SD_UnPackdXdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialContStatePInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdXdu

 SUBROUTINE SD_CopydXddu( SrcdXdduData, DstdXdduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialDiscStatePInputType), INTENT(INOUT) :: SrcdXdduData
   TYPE(SD_PartialDiscStatePInputType), INTENT(INOUT) :: DstdXdduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdXdduData%DummyDiscState, DstdXdduData%DummyDiscState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopydXddu:DummyDiscState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopydXddu

 SUBROUTINE SD_DestroydXddu( dXdduData, ErrStat, ErrMsg )
  TYPE(SD_PartialDiscStatePInputType), INTENT(INOUT) :: dXdduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dXdduData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydXddu

 SUBROUTINE SD_PackdXddu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialDiscStatePInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_PackdXddu

 SUBROUTINE SD_UnPackdXddu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialDiscStatePInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdXddu

 SUBROUTINE SD_CopydZdu( SrcdZduData, DstdZduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialConstrStatePInputType), INTENT(INOUT) :: SrcdZduData
   TYPE(SD_PartialConstrStatePInputType), INTENT(INOUT) :: DstdZduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdZduData%DummyConstrState, DstdZduData%DummyConstrState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopydZdu:DummyConstrState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopydZdu

 SUBROUTINE SD_DestroydZdu( dZduData, ErrStat, ErrMsg )
  TYPE(SD_PartialConstrStatePInputType), INTENT(INOUT) :: dZduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dZduData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydZdu

 SUBROUTINE SD_PackdZdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialConstrStatePInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_PackdZdu

 SUBROUTINE SD_UnPackdZdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialConstrStatePInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdZdu

 SUBROUTINE SD_CopyPartialOutputPContStateType( SrcPartialOutputPContStateTypeData, DstPartialOutputPContStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialOutputPContStateType), INTENT(IN) :: SrcPartialOutputPContStateTypeData
   TYPE(SD_PartialOutputPContStateType), INTENT(INOUT) :: DstPartialOutputPContStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcPartialOutputPContStateTypeData%DummyOutput, DstPartialOutputPContStateTypeData%DummyOutput, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialOutputPContStateType:DummyOutput')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialOutputPContStateType

 SUBROUTINE SD_DestroyPartialOutputPContStateType( PartialOutputPContStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialOutputPContStateType), INTENT(INOUT) :: PartialOutputPContStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( PartialOutputPContStateTypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialOutputPContStateType

 SUBROUTINE SD_PackPartialOutputPContStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialOutputPContStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_PackPartialOutputPContStateType

 SUBROUTINE SD_UnPackPartialOutputPContStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialOutputPContStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialOutputPContStateType

 SUBROUTINE SD_CopyPartialContStatePContStateType( SrcPartialContStatePContStateTypeData, DstPartialContStatePContStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialContStatePContStateType), INTENT(IN) :: SrcPartialContStatePContStateTypeData
   TYPE(SD_PartialContStatePContStateType), INTENT(INOUT) :: DstPartialContStatePContStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcPartialContStatePContStateTypeData%DummyContState, DstPartialContStatePContStateTypeData%DummyContState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialContStatePContStateType:DummyContState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialContStatePContStateType

 SUBROUTINE SD_DestroyPartialContStatePContStateType( PartialContStatePContStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialContStatePContStateType), INTENT(INOUT) :: PartialContStatePContStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( PartialContStatePContStateTypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialContStatePContStateType

 SUBROUTINE SD_PackPartialContStatePContStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialContStatePContStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_PackPartialContStatePContStateType

 SUBROUTINE SD_UnPackPartialContStatePContStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialContStatePContStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialContStatePContStateType

 SUBROUTINE SD_CopyPartialDiscStatePContStateType( SrcPartialDiscStatePContStateTypeData, DstPartialDiscStatePContStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialDiscStatePContStateType), INTENT(IN) :: SrcPartialDiscStatePContStateTypeData
   TYPE(SD_PartialDiscStatePContStateType), INTENT(INOUT) :: DstPartialDiscStatePContStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcPartialDiscStatePContStateTypeData%DummyDiscState, DstPartialDiscStatePContStateTypeData%DummyDiscState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialDiscStatePContStateType:DummyDiscState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialDiscStatePContStateType

 SUBROUTINE SD_DestroyPartialDiscStatePContStateType( PartialDiscStatePContStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialDiscStatePContStateType), INTENT(INOUT) :: PartialDiscStatePContStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( PartialDiscStatePContStateTypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialDiscStatePContStateType

 SUBROUTINE SD_PackPartialDiscStatePContStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialDiscStatePContStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_PackPartialDiscStatePContStateType

 SUBROUTINE SD_UnPackPartialDiscStatePContStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialDiscStatePContStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialDiscStatePContStateType

 SUBROUTINE SD_CopyPartialConstrStatePContStateType( SrcPartialConstrStatePContStateTypeData, DstPartialConstrStatePContStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialConstrStatePContStateType), INTENT(IN) :: SrcPartialConstrStatePContStateTypeData
   TYPE(SD_PartialConstrStatePContStateType), INTENT(INOUT) :: DstPartialConstrStatePContStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcPartialConstrStatePContStateTypeData%DummyConstrState, DstPartialConstrStatePContStateTypeData%DummyConstrState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialConstrStatePContStateType:DummyConstrState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialConstrStatePContStateType

 SUBROUTINE SD_DestroyPartialConstrStatePContStateType( PartialConstrStatePContStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialConstrStatePContStateType), INTENT(INOUT) :: PartialConstrStatePContStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( PartialConstrStatePContStateTypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialConstrStatePContStateType

 SUBROUTINE SD_PackPartialConstrStatePContStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialConstrStatePContStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_PackPartialConstrStatePContStateType

 SUBROUTINE SD_UnPackPartialConstrStatePContStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialConstrStatePContStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialConstrStatePContStateType

 SUBROUTINE SD_CopyPartialOutputPDiscStateType( SrcPartialOutputPDiscStateTypeData, DstPartialOutputPDiscStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialOutputPDiscStateType), INTENT(IN) :: SrcPartialOutputPDiscStateTypeData
   TYPE(SD_PartialOutputPDiscStateType), INTENT(INOUT) :: DstPartialOutputPDiscStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcPartialOutputPDiscStateTypeData%DummyOutput, DstPartialOutputPDiscStateTypeData%DummyOutput, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialOutputPDiscStateType:DummyOutput')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialOutputPDiscStateType

 SUBROUTINE SD_DestroyPartialOutputPDiscStateType( PartialOutputPDiscStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialOutputPDiscStateType), INTENT(INOUT) :: PartialOutputPDiscStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( PartialOutputPDiscStateTypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialOutputPDiscStateType

 SUBROUTINE SD_PackPartialOutputPDiscStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialOutputPDiscStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_PackPartialOutputPDiscStateType

 SUBROUTINE SD_UnPackPartialOutputPDiscStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialOutputPDiscStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialOutputPDiscStateType

 SUBROUTINE SD_CopyPartialContStatePDiscStateType( SrcPartialContStatePDiscStateTypeData, DstPartialContStatePDiscStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialContStatePDiscStateType), INTENT(IN) :: SrcPartialContStatePDiscStateTypeData
   TYPE(SD_PartialContStatePDiscStateType), INTENT(INOUT) :: DstPartialContStatePDiscStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcPartialContStatePDiscStateTypeData%DummyContState, DstPartialContStatePDiscStateTypeData%DummyContState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialContStatePDiscStateType:DummyContState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialContStatePDiscStateType

 SUBROUTINE SD_DestroyPartialContStatePDiscStateType( PartialContStatePDiscStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialContStatePDiscStateType), INTENT(INOUT) :: PartialContStatePDiscStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( PartialContStatePDiscStateTypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialContStatePDiscStateType

 SUBROUTINE SD_PackPartialContStatePDiscStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialContStatePDiscStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_PackPartialContStatePDiscStateType

 SUBROUTINE SD_UnPackPartialContStatePDiscStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialContStatePDiscStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialContStatePDiscStateType

 SUBROUTINE SD_CopyPartialDiscStatePDiscStateType( SrcPartialDiscStatePDiscStateTypeData, DstPartialDiscStatePDiscStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialDiscStatePDiscStateType), INTENT(IN) :: SrcPartialDiscStatePDiscStateTypeData
   TYPE(SD_PartialDiscStatePDiscStateType), INTENT(INOUT) :: DstPartialDiscStatePDiscStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcPartialDiscStatePDiscStateTypeData%DummyDiscState, DstPartialDiscStatePDiscStateTypeData%DummyDiscState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialDiscStatePDiscStateType:DummyDiscState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialDiscStatePDiscStateType

 SUBROUTINE SD_DestroyPartialDiscStatePDiscStateType( PartialDiscStatePDiscStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialDiscStatePDiscStateType), INTENT(INOUT) :: PartialDiscStatePDiscStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( PartialDiscStatePDiscStateTypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialDiscStatePDiscStateType

 SUBROUTINE SD_PackPartialDiscStatePDiscStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialDiscStatePDiscStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_PackPartialDiscStatePDiscStateType

 SUBROUTINE SD_UnPackPartialDiscStatePDiscStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialDiscStatePDiscStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialDiscStatePDiscStateType

 SUBROUTINE SD_CopyPartialConstrStatePDiscStateType( SrcPartialConstrStatePDiscStateTypeData, DstPartialConstrStatePDiscStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialConstrStatePDiscStateType), INTENT(IN) :: SrcPartialConstrStatePDiscStateTypeData
   TYPE(SD_PartialConstrStatePDiscStateType), INTENT(INOUT) :: DstPartialConstrStatePDiscStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcPartialConstrStatePDiscStateTypeData%DummyConstrState, DstPartialConstrStatePDiscStateTypeData%DummyConstrState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialConstrStatePDiscStateType:DummyConstrState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialConstrStatePDiscStateType

 SUBROUTINE SD_DestroyPartialConstrStatePDiscStateType( PartialConstrStatePDiscStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialConstrStatePDiscStateType), INTENT(INOUT) :: PartialConstrStatePDiscStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( PartialConstrStatePDiscStateTypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialConstrStatePDiscStateType

 SUBROUTINE SD_PackPartialConstrStatePDiscStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialConstrStatePDiscStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_PackPartialConstrStatePDiscStateType

 SUBROUTINE SD_UnPackPartialConstrStatePDiscStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialConstrStatePDiscStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialConstrStatePDiscStateType

 SUBROUTINE SD_CopyPartialOutputPConstrStateType( SrcPartialOutputPConstrStateTypeData, DstPartialOutputPConstrStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialOutputPConstrStateType), INTENT(IN) :: SrcPartialOutputPConstrStateTypeData
   TYPE(SD_PartialOutputPConstrStateType), INTENT(INOUT) :: DstPartialOutputPConstrStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcPartialOutputPConstrStateTypeData%DummyOutput, DstPartialOutputPConstrStateTypeData%DummyOutput, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialOutputPConstrStateType:DummyOutput')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialOutputPConstrStateType

 SUBROUTINE SD_DestroyPartialOutputPConstrStateType( PartialOutputPConstrStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialOutputPConstrStateType), INTENT(INOUT) :: PartialOutputPConstrStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( PartialOutputPConstrStateTypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialOutputPConstrStateType

 SUBROUTINE SD_PackPartialOutputPConstrStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialOutputPConstrStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_PackPartialOutputPConstrStateType

 SUBROUTINE SD_UnPackPartialOutputPConstrStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialOutputPConstrStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialOutputPConstrStateType

 SUBROUTINE SD_CopyPartialContStatePConstrStateType( SrcPartialContStatePConstrStateTypeData, DstPartialContStatePConstrStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialContStatePConstrStateType), INTENT(IN) :: SrcPartialContStatePConstrStateTypeData
   TYPE(SD_PartialContStatePConstrStateType), INTENT(INOUT) :: DstPartialContStatePConstrStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcPartialContStatePConstrStateTypeData%DummyContState, DstPartialContStatePConstrStateTypeData%DummyContState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialContStatePConstrStateType:DummyContState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialContStatePConstrStateType

 SUBROUTINE SD_DestroyPartialContStatePConstrStateType( PartialContStatePConstrStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialContStatePConstrStateType), INTENT(INOUT) :: PartialContStatePConstrStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( PartialContStatePConstrStateTypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialContStatePConstrStateType

 SUBROUTINE SD_PackPartialContStatePConstrStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialContStatePConstrStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_PackPartialContStatePConstrStateType

 SUBROUTINE SD_UnPackPartialContStatePConstrStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialContStatePConstrStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialContStatePConstrStateType

 SUBROUTINE SD_CopyPartialDiscStatePConstrStateType( SrcPartialDiscStatePConstrStateTypeData, DstPartialDiscStatePConstrStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialDiscStatePConstrStateType), INTENT(IN) :: SrcPartialDiscStatePConstrStateTypeData
   TYPE(SD_PartialDiscStatePConstrStateType), INTENT(INOUT) :: DstPartialDiscStatePConstrStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcPartialDiscStatePConstrStateTypeData%DummyDiscState, DstPartialDiscStatePConstrStateTypeData%DummyDiscState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialDiscStatePConstrStateType:DummyDiscState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialDiscStatePConstrStateType

 SUBROUTINE SD_DestroyPartialDiscStatePConstrStateType( PartialDiscStatePConstrStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialDiscStatePConstrStateType), INTENT(INOUT) :: PartialDiscStatePConstrStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( PartialDiscStatePConstrStateTypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialDiscStatePConstrStateType

 SUBROUTINE SD_PackPartialDiscStatePConstrStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialDiscStatePConstrStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_PackPartialDiscStatePConstrStateType

 SUBROUTINE SD_UnPackPartialDiscStatePConstrStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialDiscStatePConstrStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialDiscStatePConstrStateType

 SUBROUTINE SD_CopyPartialConstrStatePConstrStateType( SrcPartialConstrStatePConstrStateTypeData, DstPartialConstrStatePConstrStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_PartialConstrStatePConstrStateType), INTENT(IN) :: SrcPartialConstrStatePConstrStateTypeData
   TYPE(SD_PartialConstrStatePConstrStateType), INTENT(INOUT) :: DstPartialConstrStatePConstrStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcPartialConstrStatePConstrStateTypeData%DummyConstrState, DstPartialConstrStatePConstrStateTypeData%DummyConstrState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyPartialConstrStatePConstrStateType:DummyConstrState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyPartialConstrStatePConstrStateType

 SUBROUTINE SD_DestroyPartialConstrStatePConstrStateType( PartialConstrStatePConstrStateTypeData, ErrStat, ErrMsg )
  TYPE(SD_PartialConstrStatePConstrStateType), INTENT(INOUT) :: PartialConstrStatePConstrStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( PartialConstrStatePConstrStateTypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyPartialConstrStatePConstrStateType

 SUBROUTINE SD_PackPartialConstrStatePConstrStateType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_PartialConstrStatePConstrStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_PackPartialConstrStatePConstrStateType

 SUBROUTINE SD_UnPackPartialConstrStatePConstrStateType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_PartialConstrStatePConstrStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackPartialConstrStatePConstrStateType


 SUBROUTINE SD_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SD_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SD_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%TPMesh, u_out%TPMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%TPMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshCopy(u(1)%LMesh, u_out%LMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%LMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%TPMesh, u(2)%TPMesh, tin, u_out%TPMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%TPMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp1(u(1)%LMesh, u(2)%LMesh, tin, u_out%LMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%LMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%TPMesh, u(2)%TPMesh, u(3)%TPMesh, tin, u_out%TPMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%TPMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp2(u(1)%LMesh, u(2)%LMesh, u(3)%LMesh, tin, u_out%LMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%LMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SD_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SD_Input_ExtrapInterp


 SUBROUTINE SD_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SD_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SD_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%Y1Mesh, u_out%Y1Mesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y1Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshCopy(u(1)%Y2Mesh, u_out%Y2Mesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y2Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%Y1Mesh, u(2)%Y1Mesh, tin, u_out%Y1Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y1Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp1(u(1)%Y2Mesh, u(2)%Y2Mesh, tin, u_out%Y2Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y2Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%Y1Mesh, u(2)%Y1Mesh, u(3)%Y1Mesh, tin, u_out%Y1Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y1Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp2(u(1)%Y2Mesh, u(2)%Y2Mesh, u(3)%Y2Mesh, tin, u_out%Y2Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y2Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SD_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SD_Output_ExtrapInterp

END MODULE SubDyn_Types
!ENDOFREGISTRYGENERATEDFILE
